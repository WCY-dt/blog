---
layout: post
title:  "【C++】STL"
date:   2021-01-05 00:00:00 +0800
categories: toturial
tags: C++ STL
comments: 1
mathjax: true
copyrights: 转载
---

本文介绍C++的 STL 库。

# array

## array模板类的定义

### array模板类的声明

```cpp
template <class T，size_t N> class array;
```

数组类是固定大小的序列容器，它们包含以严格线性序列排序的特定数量的元素。数组类具有固定大小，并且不通过分配器管理其元素的分配，它们是封装固定大小元素数组的聚合类型。

### 容器属性

- 序列容器中的元素按严格的线性顺序排序。各个元素按其顺序访问它们的位置。
- 元素存储在连续的存储器位置，允许对元素进行恒定时间随机访问。可以偏移元素的指针以访问其他元素。
- 容器使用隐式构造函数和析构函数静态分配所需的空间。它的大小是编译时常量。没有内存或时间开销。

### array模板类的说明

array模板类中T为包含元素的类型（`std::array::value_type`），N为元素个数。

### array模板类头文件

使用array模板类之前需要包含`#include <array>`头文件！

## array模板类的使用

### Iterators

Iterators迭代器的作用是遍历array数组类中的元素。可以通过**begin/end()**、**rbegin/rend()**、**cbegin/cend()**、**crbegin/crend()**等函数进行访问。

| 函数 | 作用 |
| -- | -- |
| `begin`   | Return iterator to beginning                       |
| `end`     | Return iterator to end                             |
| `rbegin`  | Return reverse iterator to reverse beginning       |
| `rend`    | Return reverse iterator to reverse end             |
| `cbegin`  | Return const_iterator to beginning                 |
| `cend`    | Return const_iterator to end                       |
| `crbegin` | Return const_reverse_iterator to reverse beginning |
| `crend`   | Return const_reverse_iterator to reverse end       |

参考代码如下所示：

```cpp
#include <iostream>
#include <array>
int main() 
{
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    std::cout << "array values: ";
    for (auto it = arr.begin(); it != arr.end(); ++it) 
    {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

运行结果如下所示：

```
array values: 1 2 3 4 5
```

### Capacity

array数组容器的大小是固定的。可以通过**sizeof()**、**size()**、**max_size()**、**empty()**等函数进行检测。

| 函数 | 作用 |
| -- | -- |
| `size`       | Return size                |
| `max_size` | Return maximum size        |
| `empty`    | Test whether list is empty |

测试array数组容器大小的参考代码如下所示：

```cpp
#include <iostream>
#include <array>
int main()
{
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    std::cout << "sizeof(array) = " << sizeof(arr) << std::endl;
    std::cout << "size of array = " << arr.size() << std::endl;
    std::cout << "max_size of array = " << arr.max_size() << std::endl;
    if (arr.empty()) 
    {
        std::cout << "array is empty!" << std::endl;
    } else 
    {
        std::cout << "array is not empty!" << std::endl;
    }
    return 0;
}
```

运行结果如下所示：

```
sizeof(array) = 20
size of array = 5
max_size of array = 5
array is not empty!
```

### Element access

可以通过下标**[ ]**、**at()**、**front()**、**back()**、**data()**等函数访问array容器内的元素。

| 函数 | 作用 |
| -- | -- |
| `[]` | Access element            |
| `at`        | Access element            |
| `front`     | Access first element      |
| `back`      | Access last element       |
| `data`      | Get pointer to first data |

参考代码如下：

```cpp
#include <iostream>
#include <array>
int main() 
{
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    std::cout << "array[0] = " << arr[0] << std::endl;
    std::cout << "array.at(4) = " << arr.at(4) << std::endl;
    std::cout << "array.front() = " << arr.front() << std::endl;
    std::cout << "array.back() = " << arr.back() << std::endl;
    std::cout << "&array: " << arr.data() << " = " << &arr << std::endl;
    return 0;
}
```

运行结果如下所示：

```
array[0] = 1
array.at(4) = 5
array.front() = 1
array.back() = 5
&array: 0x7ffd22df6e50 = 0x7ffd22df6e50
```

### Modifiers

可以使用**fill()**、**swap()**等函数对array容器整体进行操作。

| 函数 | 作用 |
| -- | -- |
| `fill`   | Fill array with value |
| `swap` | Swap content          |

参考代码如下所示：

```cpp
#include <iostream>
#include <array>
int main()
{
    std::array<int, 5> arr;
    arr.fill(5);  // fill
    std::cout << "array values: ";
    for (auto i : arr) 
    {
        std::cout << i << " ";
    }
    std::cout << std::endl;
    std::array<int, 3> first = {1, 2, 3};
    std::array<int, 3> second = {6, 5, 4};
    std::cout << "first  array values: ";
    for (auto it = first.begin(); it != first.end(); ++it)
    {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    std::cout << "second array values: ";
    for (auto it = second.begin(); it != second.end(); ++it)
    {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    first.swap(second);  // swap
    std::cout << "swap array success!" << std::endl;
    std::cout << "first  array values: ";
    for (auto it = first.begin(); it != first.end(); ++it) 
    {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    std::cout << "second array values: ";
    for (auto it = second.begin(); it != second.end(); ++it)
    {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

运行结果如下所示：

```
array values: 5 5 5 5 5 
first  array values: 1 2 3 
second array values: 6 5 4 
swap array success!
first  array values: 6 5 4 
second array values: 1 2 3 
```

### Compare

还可以使用> < ==等符号对两个array数组容器进行比较。

```cpp
#include <iostream>
#include <array>
int main()
{
    std::array<int,5> a = {10, 20, 30, 40, 50};
    std::array<int,5> b = {10, 20, 30, 40, 50};
    std::array<int,5> c = {50, 40, 30, 20, 10};
    if (a == b)
    {
        std::cout << "a == b" << std::endl;
    } else 
    {
        std::cout << "a != b" << std::endl;
    }
    if (a == c) 
    {
        std::cout << "a == c" << std::endl;

    } else 
    {
        std::cout << "a != c" << std::endl;
    }
    if (a < c) 
    {
        std::cout << "a < c" << std::endl;
    } else 
    {
        std::cout << "a >= c" << std::endl;
    }
    return 0;
} 
```

运行结果如下所示：

```
a == b
a != c
a < c
```

### Other

c++重载了**get()**函数来访问数组容器中的元素，为了和元组相似，还重载了**tuple_size**和**tuple_element**类型。

| 函数 | 作用 |
| -- | -- |
| `get( array)`            | Get element (tuple interface) |
| `tuple_element<array>` | Tuple element type for array  |
| `tuple_size<array>`    | Tuple size traits for array   |

参考代码如下所示：

```cpp
#include <iostream>
#include <array>
#include <tuple>
int main() 
{
    std::array<int,3> myarray = {10, 20, 30};
    std::tuple<int, int, int> mytuple (10, 20, 30);
    std::tuple_element<0, decltype(myarray)>::type myelement;  // int myelement
    myelement = std::get<2>(myarray);
    std::get<2>(myarray) = std::get<0>(myarray);
    std::get<0>(myarray) = myelement;
    std::cout << "first element in myarray: " << std::get<0>(myarray) << std::endl;
    std::cout << "first element in mytuple: " << std::get<0>(mytuple) << std::endl;
    return 0;
}
```

运行结果如下所示：

```
first element in myarray: 30
first element in mytuple: 10
```

# vector

## 什么是vector？

向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。

## 容器特性

### 顺序序列

顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。

### 动态数组

支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。

### 能够感知内存分配器的Allocator-aware

容器使用一个内存分配器对象来动态地处理它的存储需求。

## 基本函数实现

### 构造函数

- `vector()`:创建一个空vector
- `vector(int nSize)`:创建一个vector,元素个数为nSize
- `vector(int nSize,const t& t)`:创建一个vector，元素个数为nSize,且值均为t
- `vector(const vector&)`:复制构造函数
- `vector(begin,end)`:复制[begin,end)区间内另一个数组的元素到vector中

### 增加函数

- `void push_back(const T& x)`:向量尾部增加一个元素X
- `iterator insert(iterator it,const T& x)`:向量中迭代器指向元素前增加一个元素x
- `iterator insert(iterator it,int n,const T& x)`:向量中迭代器指向元素前增加n个相同的元素x
- `iterator insert(iterator it,const_iterator first,const_iterator last)`:向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据

### 删除函数

- `iterator erase(iterator it)`:删除向量中迭代器指向元素
- `iterator erase(iterator first,iterator last)`:删除向量中[first,last)中元素
- `void pop_back()`:删除向量中最后一个元素
- `void clear()`:清空向量中所有元素

### 遍历函数

- `reference at(int pos)`:返回pos位置元素的引用
- `reference front()`:返回首元素的引用
- `reference back()`:返回尾元素的引用
- `iterator begin()`:返回向量头指针，指向第一个元素
- `iterator end()`:返回向量尾指针，指向向量最后一个元素的下一个位置
- `reverse_iterator rbegin()`:反向迭代器，指向最后一个元素
- `reverse_iterator rend()`:反向迭代器，指向第一个元素之前的位置

### 判断函数

- `bool empty() const`:判断向量是否为空，若为空，则向量中无元素

### 大小函数

- `int size() const`:返回向量中元素的个数
- `int capacity() const`:返回当前向量所能容纳的最大元素值
- `int max_size() const`:返回最大可允许的vector元素数量值

### 其他函数

- `void swap(vector&)`:交换两个同类型向量的数据
- `void assign(int n,const T& x)`:设置向量中第n个元素的值为x
- `void assign(const_iterator first,const_iterator last)`:向量中[first,last)中元素设置成当前向量元素

### 看着清楚

- `push_back` 在数组的最后添加一个数据
- `pop_back` 去掉数组的最后一个数据
- `at` 得到编号位置的数据
- `begin` 得到数组头的指针
- `end` 得到数组的最后一个单元+1的指针
- `front` 得到数组头的引用
- `back` 得到数组的最后一个单元的引用
- `max_size` 得到vector最大可以是多大
- `capacity` 当前vector分配的大小
- `size` 当前使用数据的大小
- `resize` 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值
- `reserve` 改变当前vecotr所分配空间的大小
- `erase` 删除指针指向的数据项
- `clear` 清空当前的vector
- `rbegin` 将vector反转后的开始指针返回(其实就是原来的end-1)
- `rend` 将vector反转构的结束指针返回(其实就是原来的begin-1)
- `empty` 判断vector是否为空
- `swap` 与另一个vector交换数据

## 基本用法

```cpp
#include<vector> 
using namespace std;
```

### 简单介绍

- `Vector<类型>标识符`
- `Vector<类型>标识符(最大容量)`
- `Vector<类型>标识符(最大容量,初始所有值)`
- `Int i[5]={1,2,3,4,5}`
  `Vector<类型>vi(I,i+2);//得到i索引值为3以后的值`
- `Vector< vector< int> >v; 二维向量//这里最外的<>要有空格。否则在比较旧的编译器下无法通过`


### 实例

#### `pop_back()`&`push_back(elem)`

```cpp
#include <string.h> 
#include <vector> 
#include <iostream> 
using namespace std; 
int main() 
{  
    vector<int>obj;//创建一个向量存储容器int  
    for(int i=0;i<10;i++) // push_back(elem)在数组最后添加数据   
    {  
        obj.push_back(i);      
        cout<<obj[i]<<",";      
    }   
    for(int i=0;i<5;i++)//去掉数组最后一个数据   
        obj.pop_back();
    cout<<"\n"<<endl;  
    for(int i=0;i<obj.size();i++)//size()容器中实际数据个数
        cout<<obj[i]<<",";
    return 0; 
}
```

输出结果为：

```
0,1,2,3,4,5,6,7,8,9,

0,1,2,3,4,
```

#### `clear()`

```cpp
#include <string.h>
#include <vector> 
#include <iostream> 
using namespace std;  
int main()
{   
    vector<int>obj; 
    for(int i=0;i<10;i++)//push_back(elem)在数组最后添加数据  
    {       
        obj.push_back(i);   
        cout<<obj[i]<<",";  
    }    
    obj.clear();//清除容器中所以数据  
    for(int i=0;i<obj.size();i++)   
        cout<<obj[i]<<endl;
    return 0;
}
```

输出结果为：

```
0,1,2,3,4,5,6,7,8,9,
```

#### 排序

```cpp
#include <string.h> 
#include <vector> 
#include <iostream>
#include <algorithm>
using namespace std; 
int main()
{  
    vector<int>obj;  
    obj.push_back(1);   
    obj.push_back(3);   
    obj.push_back(0);  
    sort(obj.begin(),obj.end());//从小到大  
    cout<<"从小到大:"<<endl;   
    for(int i=0;i<obj.size();i++)   
        cout<<obj[i]<<",";
    cout<<"\n"<<endl;   
    cout<<"从大到小:"<<endl;   
    reverse(obj.begin(),obj.end());//从大到小 
    for(int i=0;i<obj.size();i++)
        cout<<obj[i]<<",";
    return 0; 
}
```

输出结果为：

```
从小到大:
0,1,3,

从大到小:
3,1,0,
```

1. 注意 `sort` 需要头文件 `#include <algorithm>`
2. 如果想 `sort` 来降序，可重写 `sort`

```cpp
bool compare(int a,int b) 
{ 
    return a< b; //升序排列，如果改为return a>b，则为降序 
} 
int a[20]={2,4,1,23,5,76,0,43,24,65},i; 
for(i=0;i<20;i++) 
    cout<< a[i]<< endl; 
sort(a,a+20,compare);
```

#### 访问（直接数组访问&迭代器访问）

```cpp
#include <string.h> 
#include <vector>
#include <iostream> 
#include <algorithm>
using namespace std; 
int main() 
{    
    //顺序访问 
    vector<int>obj;  
    for(int i=0;i<10;i++)   
        obj.push_back(i);
    cout<<"直接利用数组：";  
    for(int i=0;i<10;i++)//方法一
        cout<<obj[i]<<" ";
    cout<<endl;   
    cout<<"利用迭代器：" ;  
    //方法二，使用迭代器将容器中数据输出 
    vector<int>::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素
    for(it=obj.begin();it!=obj.end();it++)  
        cout<<*it<<" ";
    return 0; 
}
```

输出结果为：
```
直接利用数组：0 1 2 3 4 5 6 7 8 9 
利用迭代器：0 1 2 3 4 5 6 7 8 9
```

#### 二维数组两种定义方法（结果一样）

##### 方法一

```cpp
#include <string.h>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std; 
int main()
{   
    int N=5, M=6;   
    vector<vector<int> > obj(N); //定义二维动态数组大小5行    
    for(int i =0; i< obj.size(); i++)//动态二维数组为5行6列，值全为0
        obj[i].resize(M);
    for(int i=0; i< obj.size(); i++)//输出二维动态数组   
    {      
        for(int j=0;j<obj[i].size();j++)
            cout<<obj[i][j]<<" ";
        cout<<"\n";  
    }  
    return 0; 
}
```

##### 方法二

```cpp
#include <string.h> 
#include <vector>
#include <iostream> 
#include <algorithm> 
using namespace std; 
int main()
{   
    int N=5, M=6;  
    vector<vector<int> > obj(N, vector<int>(M)); //定义二维动态数组5行6列   
    for(int i=0; i< obj.size(); i++)//输出二维动态数组 
    {     
        for(int j=0;j<obj[i].size();j++)  
            cout<<obj[i][j]<<" ";
        cout<<"\n"; 
    }   
    return 0; 
}
```

输出结果为：

```
0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 0 0 0 0 
0 0 0 0 0 0 
```

