---
layout: post
title:  "【算法】网络流 <img src='https://img.shields.io/badge/-原创-019733?style=flat'> <img src='https://img.shields.io/badge/-未完待续-blue?style=flat'>"
date:   2021-05-26 00:00:00 +0800
categories: A&DS
tags: 算法 网络流
comments: 1
mathjax: true
---

本文介绍网络流。未完待续。

# 概念

## 网络

网络是指一个有向图 $G=(V,E)$ 。

每条边 $(u,v)\in E$ 都有一个权值 $c(u,v)$，称之为容量（Capacity），当 $(u,v)\not\in E$ 时有 $c(u,v)=0$。

其中有两个特殊的点：源点（Source）$s\in V$ 和汇点（Sink）$t\in V(s\neq t)$。

## 流

设 $f(u,v)$ 定义在二元组 $u\in V,v\in V$ 上的实数函数且满足

1. 容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 $f(u,v)\leq c(u,v)$
2. 斜对称性：每条边的流量与其相反边的流量之和为 $0$，即 $f(u,v)=-f(v,u)$ 
3. 流守恒性：从源点流出的流量等于汇点流入的流量，即 $\forall x\in V-\left\{s,t\right\},\sum_{(u,v)\in E}{f(u,x)}=\sum_{(x,v)\in E}{f(x,v)}$ 

那么 $f$ 称为网络 $G$ 的流函数。对于 $(u,v)\in E$，$f(u,v)$ 称为边的流量，$c(u,v)$ 称为边的剩余容量。整个网络的流量为 $\sum_{(s,v)\in E}{f(s,v)}$，即从源点发出的所有流量之和。

# 最大流

> 我们有一张图，要求从源点流向汇点的最大流量。

## 残量网络

一条边的剩余容量 $c_f(u,v)=c(u,v)-f(u,v)$（Residual Capacity），它表示的是这条边的容量与流量之差。

对于流函数 $f$，残存网络 $G_f$（Residual Network）是网络 $G$ 中所有结点和剩余容量大于 $0$ 的边构成的子图。形式化的定义，即 $G_f=(V_f-V,E_f=\left\{(u,v)\in E,c_f(u,v)>0\right\})$。

注意，剩余容量大于 $0$ 的边可能不在原图 $G$ 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。

## 增广路

在原图 $G$ 中若一条从源点到汇点的路径上所有边的剩余容量都大于 $0$，这条路被称为增广路（Augmenting Path）。

增广操作则是沿着增广路，减去增广路的最大流。

## Dinic

先用 BFS 来将图分层。设源点的层数为 $0$，那么一个点的层数便是它离源点的最近距离。

通过分层，我们可以干两件事情：

1. 如果不存在到汇点的增广路（即汇点的层数不存在），我们即可停止增广。
2. 确保我们找到的增广路是最短的。

接下来是 DFS 找增广路的过程。

我们每次找增广路的时候，都只找比当前点层数多 $1$ 的点进行增广（这样就可以确保我们找到的增广路是最短的）。

Dinic 算法优化：

- 多路增广：每次找到一条增广路的时候，如果残余流量没有用完怎么办呢？我们可以利用残余部分流量，再找出一条增广路。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。
- 当前弧优化：如果一条边已经被增广过，那么它就没有可能被增广第二次。那么，我们下一次进行增广的时候，就可以不必再走那些已经被增广过的边。

```cpp
#define maxn 250
#define INF 0x3f3f3f3f
struct Edge
{
	int from, to, cap, flow;
	Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};
struct Dinic
{
	int n, m, s, t;
	vector<Edge> edges;
	vector<int> G[maxn];
	int d[maxn], cur[maxn]; // d 记录层数
	bool vis[maxn];
	void init(int n)
	{
		for (int i = 0; i < n; i++)
			G[i].clear();
		edges.clear();
	}
	void AddEdge(int from, int to, int cap)
	{
		edges.push_back(Edge(from, to, cap, 0));
		edges.push_back(Edge(to, from, 0, 0));
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}
	bool BFS() // 用来计算每个节点的层数
	{
		memset(vis, 0, sizeof(vis)); // 均没有访问过
		queue<int> Q; // BFS 用的队列
		Q.push(s);
		d[s] = 0;
		vis[s] = 1;
		while (!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for (int i = 0; i < G[x].size(); i++) // G[x].size 为从 x 出发的边的条数
			{
				Edge &e = edges[G[x][i]];
				if (!vis[e.to] && e.cap > e.flow) // 为访问过 e.to
				{
					vis[e.to] = 1;
					d[e.to] = d[x] + 1;
					Q.push(e.to);
				}
			}
		}
		return vis[t];
	}
	int DFS(int x, int a)
	{
		if (x == t || a == 0)
			return a;
		int flow = 0, f;
		for (int &i = cur[x]; i < G[x].size(); i++)
		{
			Edge &e = edges[G[x][i]];
			if (d[x] + 1 == d[e.to] &&
                (f = DFS(e.to, min(a, e.cap - e.flow))) > 0)
			{
				e.flow += f;
				edges[G[x][i] ^ 1].flow -= f;
				flow += f;
				a -= f;
				if (a == 0)
					break;
			}
		}
		return flow;
	}
	int Maxflow(int s, int t) //s 为源点，t 为汇点
	{
		this->s = s;
		this->t = t;
		int flow = 0; // flow 记录最大流
		while (BFS()) // 分层
		{
			memset(cur, 0, sizeof(cur));
			flow += DFS(s, INF);
		}
		return flow;
	}
};
```

