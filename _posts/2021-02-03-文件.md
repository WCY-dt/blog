---
layout: post
title:  "【C】文件 <img src='https://img.shields.io/badge/-转载-C9284D?style=flat'>"
date:   2021-02-03 00:00:00 +0800
categories: toturial
tags: C 文件
comments: 1
mathjax: true
---

本文主要介绍C文件操作。

# 什么是文件？

我们对文件的概念已经非常熟悉了，比如常见的 Word 文档、txt 文件、源文件等。文件是数据源的一种，最主要的作用是保存数据。

在操作系统中，为了统一对各种硬件的操作，简化接口，**不同的硬件设备也都被看成一个文件**。对这些文件的操作，等同于对磁盘上普通文件的操作。例如：

- 通常把显示器称为标准输出文件，`printf` 就是向这个文件输出数据；
- 通常把键盘称为标准输入文件，`scanf` 就是从这个文件读取数据。

| 文件     | 硬件设备                                                     |
| -------- | ------------------------------------------------------------ |
| `stdin`  | 标准输入文件，一般指键盘；`scanf()`、`getchar() `等函数默认从 `stdin` 获取输入。 |
| `stdout` | 标准输出文件，一般指显示器；`printf()`、`putchar()` 等函数默认向 `stdout` 输出数据。 |
| `stderr` | 标准错误文件，一般指显示器；`perror() `等函数默认向` stderr `输出数据。 |
| `stdprn` | 标准打印文件，一般指打印机。                                 |

> 我们不去探讨硬件设备是如何被映射成文件的，大家只需要记住，在C语言中硬件设备可以看成文件，有些输入输出函数不需要你指明到底读写哪个文件，系统已经为它们设置了默认的文件，当然你也可以更改，例如让 `printf` 向磁盘上的文件输出数据。

操作文件的正确流程为：**`打开文件 --> 读写文件 --> 关闭文件`。文件在进行读写操作之前要先打开，使用完毕要关闭**。

所谓打开文件，就是获取文件的有关信息，例如文件名、文件状态、当前读写位置等，这些信息会被保存到一个 `FILE `类型的结构体变量中。关闭文件就是断开与文件之间的联系，释放结构体变量，同时禁止再对该文件进行操作。

在C语言中，文件有多种读写方式，可以一个字符一个字符地读取，也可以读取一整行，还可以读取若干个字节。文件的读写位置也非常灵活，可以从文件开头读取，也可以从中间位置读取。

## 文件流

所有的文件都要载入内存才能处理，所有的数据必须写入文件才不会丢失。数据在文件和内存之间传递的过程叫做文件流，类似水从一个地方流动到另一个地方。数据从文件复制到内存的过程叫做<mark>输入流</mark>，从内存保存到文件的过程叫做<mark>输出流</mark>。

文件是数据源的一种，除了文件，还有数据库、网络、键盘等；数据传递到内存也就是保存到C语言的变量（例如整数、字符串、数组、缓冲区等）。我们把数据在数据源和程序（内存）之间传递的过程叫做<mark>数据流</mark>(Data Stream)。相应的，数据从数据源到程序（内存）的过程叫做输入流(Input Stream)，从程序（内存）到数据源的过程叫做输出流(Output Stream)。

<mark>输入输出</mark>（Input output，IO）是指程序（内存）与外部设备（键盘、显示器、磁盘、其他计算机等）进行交互的操作。几乎所有的程序都有输入与输出操作，如从键盘上读取数据，从本地或网络上的文件读取数据或写入数据等。通过输入和输出操作可以从外界接收信息，或者是把信息传递给外界。

我们可以说，**打开文件就是打开了一个流**。

# 打开文件

在C语言中，操作文件之前必须先打开文件；所谓<mark>打开文件</mark>，就是让程序和文件建立连接的过程。

打开文件之后，程序可以得到文件的相关信息，例如大小、类型、权限、创建者、更新时间等。在后续读写文件的过程中，程序还可以记录当前读写到了哪个位置，下次可以在此基础上继续操作。

> 标准输入文件 `stdin`（表示键盘）、标准输出文件 `stdout`（表示显示器）、标准错误文件 `stderr`（表示显示器）是由系统打开的，可直接使用。

使用 `<stdio.h> `头文件中的 `fopen() `函数即可打开文件，它的用法为：

```cpp
FILE *fopen(char *filename, char *mode);
```

`filename`为文件名（包括文件路径），`mode`为打开方式，它们都是字符串。

## `fopen()` 函数的返回值

`fopen()` 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 `FILE `类型的结构体变量中，然后将该变量的地址返回。`FILE` 是 `<stdio.h>` 头文件中的一个结构体，它专门用来保存文件信息。我们不用关心 `FILE` 的具体结构，只需要知道它的用法就行。

如果希望接收 `fopen()` 的返回值，就需要定义一个 `FILE` 类型的指针。例如：

```cpp
FILE *fp = fopen("demo.txt", "r");
```

表示以“只读”方式打开当前目录下的` demo.txt `文件，并使` fp `指向该文件，这样就可以通过` fp `来操作 `demo.txt `了。`fp `通常被称为文件指针。

再来看一个例子：

```cpp
FILE *fp = fopen("D:\\demo.txt","rb+");
```

表示以二进制方式打开 D 盘下的`demo.txt `文件，允许读和写。

#### 判断文件是否打开成功

打开文件出错时，`fopen() `将返回一个空指针，也就是 `NULL`，我们可以利用这一点来判断文件是否打开成功，请看下面的代码：

```cpp
FILE *fp;
if( (fp=fopen("D:\\demo.txt","rb") == NULL )
{  
    printf("Fail to open file!\n"); 
    exit(0);  //退出程序（结束程序）
}
```

我们通过判断 `fopen()` 的返回值是否和 `NULL `相等来判断是否打开失败：如果` fopen()` 的返回值为 `NULL`，那么` fp `的值也为` NULL`，此时` if `的判断条件成立，表示文件打开失败。

以上代码是文件操作的规范写法，读者在打开文件时一定要判断文件是否打开成功，因为一旦打开失败，后续操作就都没法进行了，往往以“结束程序”告终。

## `fopen()` 函数的打开方式

不同的操作需要不同的文件权限。例如，只想读取文件中的数据的话，“只读”权限就够了；既想读取又想写入数据的话，“读写”权限就是必须的了。另外，文件也有不同的类型，按照数据的存储方式可以分为二进制文件和文本文件，它们的操作细节是不同的。在调用` fopen() `函数时，这些信息都必须提供，称为<mark>文件打开方式</mark>。最基本的文件打开方式有以下几种：

| 打开方式 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| `r`      | 以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。 |
| `w`      | 以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
| `a`      | 以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |
| `r+`     | 以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。 |
| `w+`     | 以“写入/更新”方式打开文件，相当于`w`和`r+`叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
| `a+`     | 以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |
| `t`      | 文本文件。如果不写，默认为`"t"`。                            |
| `b`      | 二进制文件。                                                 |


调用 `fopen()` 函数时必须指明读写权限，但是可以不指明读写方式（此时默认为`"t"`）。读写权限和读写方式可以组合使用，但是必须将读写方式放在读写权限的中间或者尾部（换句话说，不能将读写方式放在读写权限的开头）。例如：

- 将读写方式放在读写权限的末尾：`rb`、`wt`、`ab`、`r+b`、`w+t`、`a+t`
- 将读写方式放在读写权限的中间：`rb+`、`wt+`、`ab+`


整体来说，文件打开方式由 `r`、`w`、`a`、`t`、`b`、`+` 六个字符拼成，各字符的含义是：

- `r`(read)：读
- `w`(write)：写
- `a`(append)：追加
- `t`(text)：文本文件
- `b`(binary)：二进制文件
- `+`：读和写

## 关闭文件

文件一旦使用完毕，应该用 `fclose() `函数把文件关闭，以释放相关资源，避免数据丢失。`fclose()` 的用法为：

```cpp
int fclose(FILE *fp);
```

`fp` 为文件指针。例如：

```cpp
fclose(fp);
```

文件正常关闭时，`fclose() `的返回值为0，如果返回非零值则表示有错误发生。

最后，我们通过一段完整的代码来演示 `fopen` 函数的用法，这个例子会一行一行地读取文本文件的所有内容：

```cpp
#include <stdio.h>
#include <stdlib.h>
#define N 100
int main() 
{   
    FILE *fp;   
    char str[N + 1]; 
    //判断文件是否打开失败  
    if ( (fp = fopen("d:\\demo.txt", "rt")) == NULL ) 
    {      
        puts("Fail to open file!");   
        exit(0); 
    }  
    //循环读取文件的每一行数据 
    while( fgets(str, N, fp) != NULL ) 
    {     
        printf("%s", str); 
    }      
    //操作结束后关闭文件
    fclose(fp);  
    return 0;
}
```

# `fgetc()`&`fputc()`

在C语言中，读写文件比较灵活，既可以每次读写一个字符，也可以读写一个字符串，甚至是任意字节的数据（数据块）。本节介绍以字符形式读写文件。以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中写入一个字符。主要使用两个函数，分别是` fgetc() `和` fputc()`。

## 字符读取函数 `fgetc`

`fgetc` 是 `file get char `的缩写，意思是从指定的文件中读取一个字符。`fgetc() `的用法为：

```cpp
int fgetc (FILE *fp);
```

`fp` 为文件指针。`fgetc() `读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回`EOF`。

`EOF` 是 `end of file `的缩写，表示文件末尾，是在` stdio.h `中定义的宏，它的值是一个负数，往往是` -1`。`fgetc() `的返回值类型之所以为` int`，就是为了容纳这个负数（`char`不能是负数）。

> EOF 不绝对是 -1，也可以是其他负数，这要看编译器的实现。

`fgetc() `的用法举例：

```cpp
char ch;
FILE *fp = fopen("D:\\demo.txt", "r+");
ch = fgetc(fp);
```

表示从`D:\\demo.txt`文件中读取一个字符，并保存到变量 `ch` 中。

在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 `fgetc()` 函数后，该指针会向后移动一个字节，所以可以连续多次使用 `fgetc() `读取多个字符。

注意：这个文件内部的位置指针与C语言中的指针不是一回事。**位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。文件每读写一次，位置指针就会移动一次**，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是隐藏的。

例如在屏幕上显示 D:\\demo.txt 文件的内容：

```cpp
#include<stdio.h>
int main()
{  
    FILE *fp;    
    char ch;   
    //如果文件不存在，给出提示并退出   
    if( (fp=fopen("D:\\demo.txt","rt")) == NULL )
    {     
        puts("Fail to open file!");  
        exit(0); 
    }   
    //每次读取一个字节，直到读取完毕  
    while( (ch=fgetc(fp)) != EOF )
    {      
        putchar(ch);   
    }  
    putchar('\n'); //输出换行符  
    fclose(fp); 
    return 0;
}
```

在D盘下创建 `demo.txt` 文件，输入任意内容并保存，运行程序，就会看到刚才输入的内容全部都显示在屏幕上。

该程序的功能是从文件中逐个读取字符，在屏幕上显示，直到读取完毕。

程序第 13 行是关键，while 循环的条件为`(ch=fgetc(fp)) != EOF`。`fget()` 每次从位置指针所在的位置读取一个字符，并保存到变量 `ch`，位置指针向后移动一个字节。当文件指针移动到文件末尾时，`fget()` 就无法读取字符了，于是返回 `EOF`，表示文件读取结束了。

### 对 `EOF` 的说明

EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 `EOF`，那么当返回 `EOF` 时，到底是文件读取完毕了还是读取出错了？我们可以借助 `stdio.h` 中的两个函数来判断，分别是 `feof() `和` ferror()`。

`feof()` 函数用来判断文件内部指针是否指向了文件末尾，它的原型是：

```cpp
int feof ( FILE * fp );
```

当指向文件末尾时返回非零值，否则返回零值。

`ferror() `函数用来判断文件操作是否出错，它的原型是：

```cpp
int ferror ( FILE *fp );
```

出错时返回非零值，否则返回零值。

需要说明的是，文件出错是非常少见的情况，上面的示例基本能够保证将文件内的数据读取完毕。如果追求完美，也可以加上判断并给出提示：

```cpp
#include<stdio.h>
int main()
{   
    FILE *fp;  
    char ch;   
    //如果文件不存在，给出提示并退出   
    if( (fp=fopen("D:\\demo.txt","rt")) == NULL )
    {      
        puts("Fail to open file!");        
        exit(0);  
    }   
    //每次读取一个字节，直到读取完毕  
    while( (ch=fgetc(fp)) != EOF )
    {       
        putchar(ch);  
    }   
    putchar('\n');  //输出换行符    
    if(ferror(fp))
    {     
        puts("读取出错");  
    }
    else
    {  
        puts("读取成功");   
    }  
    fclose(fp);   
    return 0;
}
```

这样，不管是出错还是正常读取，都能够做到心中有数。

## 字符写入函数 `fputc`

`fputc `是` file output char `的所以，意思是向指定的文件中写入一个字符。`fputc() `的用法为：

```cpp
int fputc ( int ch, FILE *fp );
```

`ch` 为要写入的字符，`fp `为文件指针。`fputc() `写入成功时返回写入的字符，失败时返回 `EOF`，返回值类型为` int `也是为了容纳这个负数。例如：

```cpp
fputc('a', fp);
```

或者：

```cpp
char ch = 'a';
fputc(ch, fp);
```

表示把字符 `a`写入`fp`所指向的文件中。

### 说明

- 被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。

- 每写入一个字符，文件内部位置指针向后移动一个字节。

例如从键盘输入一行字符，写入文件：

```cpp
#include<stdio.h>
int main()
{  
    FILE *fp;  
    char ch;  
    //判断文件是否成功打开
    if( (fp=fopen("D:\\demo.txt","wt+")) == NULL )
    {
        puts("Fail to open file!"); 
        exit(0); 
    }   
    printf("Input a string:\n");  
    //每次从键盘读取一个字符并写入文件  
    while ( (ch=getchar()) != '\n' )
    {      
        fputc(ch,fp);    
    }   
    fclose(fp);  
    return 0;
}
```

运行程序，输入一行字符并按回车键结束，打开D盘下的 `demo.txt `文件，就可以看到刚才输入的内容。

程序每次从键盘读取一个字符并写入文件，直到按下回车键，`while `条件不成立，结束读取。

# `fgets()`&`fputs()`

`fgetc()` 和 `fputc()` 函数每次只能读写一个字符，速度较慢；实际开发中往往是每次读写一个字符串或者一个数据块，这样能明显提高效率。

## 读字符串函数 `fgets`

`fgets()` 函数用来从指定的文件中读取一个字符串，并保存到字符数组中，它的用法为：

```cpp
char *fgets ( char *str, int n, FILE *fp );
```

`str` 为字符数组，`n `为要读取的字符数目，`fp `为文件指针。

返回值：读取成功时返回字符数组首地址，也即 `str`；读取失败时返回 `NULL`；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 `NULL`。注意，读取到的字符串会在末尾自动添加 `\0`，$n $个字符也包括 `\0`。也就是说，实际只读取到了 $n-1$ 个字符，如果希望读取 100 个字符，$n$ 的值应该为 101。例如：

```cpp
#define N 101
char str[N];
FILE *fp = fopen("D:\\demo.txt", "r");
fgets(str, N, fp);
```

表示从 `D:\\demo.txt `中读取 100 个字符，并保存到字符数组 `str` 中。

需要重点说明的是，在读取到 $n-1$ 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。这就意味着，不管 $n$ 的值多大，`fgets()​` 最多只能读取一行数据，不能跨行。在C语言中，没有按行读取文件的函数，我们可以借助 ​`fgets()`，将 $n$ 的值设置地足够大，每次就可以读取到一行数据。

例如一行一行地读取文件：

```cpp
#include <stdio.h>
#include <stdlib.h>
#define N 100
int main()
{  
    FILE *fp;   
    char str[N+1];  
    if( (fp=fopen("d:\\demo.txt","rt")) == NULL )
    {       
        puts("Fail to open file!");      
        exit(0); 
    }      
    while(fgets(str, N, fp) != NULL)
    {        
        printf("%s", str);  
    }  
    fclose(fp); 
    return 0;
}
```

将下面的内容复制到 `D:\\demo.txt`：

```
a
bb
ccc
```

那么运行结果为：

```
a
bb
ccc
```

`fgets()` 遇到换行时，会将换行符一并读取到当前字符串。该示例的输出结果之所以和 `demo.txt` 保持一致，该换行的地方换行，就是因为 `fgets()` 能够读取到换行符。而 `gets()` 不一样，它会忽略换行符。

## 写字符串函数 `fputs`

`fputs()` 函数用来向指定的文件写入一个字符串，它的用法为：

```cpp
int fputs( char *str, FILE *fp );
```

`str` 为要写入的字符串，`fp` 为文件指针。写入成功返回非负数，失败返回 `EOF`。例如：

```cpp
char *str = "http://";
FILE *fp = fopen("D:\\demo.txt", "at+");
fputs(str, fp);
```

表示把把字符串 `str `写入到 `D:\\demo.txt `文件中。

例如向上例中建立的` d:\\demo.txt `文件中追加一个字符串：

```cpp
#include<stdio.h>
int main()
{   
    FILE *fp;  
    char str[102] = {0}, strTemp[100]; 
    if( (fp=fopen("D:\\demo.txt", "at+")) == NULL )
    {     
        puts("Fail to open file!");     
        exit(0); 
    }    
    printf("Input a string:");  
    gets(strTemp);  
    strcat(str, "\n");   
    strcat(str, strTemp);   
    fputs(str, fp);   
    fclose(fp);   
    return 0;
}
```

运行程序，输入`C C++ Java Linux Shell`，打开` D:\\demo.txt`，文件内容为：

```
a
bb
ccc
C C++ Java Linux Shell
```

# `fread()`&`fwrite()`

`fgets() `有局限性，每次最多只能从文件中读取一行内容，因为` fgets()` 遇到换行符就结束读取。如果希望读取多行内容，需要使用 `fread()` 函数；相应地写入函数为` fwrite()`。对于 Windows 系统，使用 `fread() `和 `fwrite()` 时应该以二进制的形式打开文件。

`fread() `函数用来从指定文件中读取块数据。所谓块数据，也就是若干个字节的数据，可以是一个字符，可以是一个字符串，可以是多行数据，并没有什么限制。`fread() `的原型为：

```cpp
size_t fread ( void *ptr, size_t size, size_t count, FILE *fp );
```

`fwrite() `函数用来向文件中写入块数据，它的原型为：

```cpp
size_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp );
```

对参数的说明：

- `ptr` 为内存区块的指针，它可以是数组、变量、结构体等。`fread()` 中的`ptr `用来存放读取到的数据，`fwrite()` 中的 `ptr `用来存放要写入的数据。
- `size`：表示每个数据块的字节数。
- `count`：表示要读写的数据块的块数。
- `fp`：表示文件指针。
- 理论上，每次读写 $\text{size}*\text{count}$个字节的数据。


`size_t `是在 `stdio.h` 和 `stdlib.h `头文件中使用 `typedef `定义的数据类型，表示无符号整数，也即非负数，常用来表示数量。

返回值：返回成功读写的块数，也即 `count`。如果返回值小于` count`：

- 对于` fwrite()` 来说，肯定发生了写入错误，可以用` ferror() `函数检测。
- 对于 `fread() `来说，可能读到了文件末尾，可能发生了错误，可以用 `ferror() `或` feof() `检测。


例如从键盘输入一个数组，将数组写入文件再读取出来：

```cpp
#include<stdio.h>
#define N 5
int main()
{   
    //从键盘输入的数据放入a，从文件读取的数据放入b  
    int a[N], b[N]; 
    int i, size = sizeof(int);  
    FILE *fp;   
    if( (fp=fopen("D:\\demo.txt", "rb+")) == NULL )
    {
        //以二进制方式打开    
        puts("Fail to open file!");  
        exit(0); 
    }    
    //从键盘输入数据 并保存到数组a  
    for(i=0; i<N; i++)
    {       
        scanf("%d", &a[i]);    
    }   
    //将数组a的内容写入到文件   
    fwrite(a, size, N, fp);   
    //将文件中的位置指针重新定位到文件开头   
    rewind(fp);   
    //从文件读取内容并保存到数组b   
    fread(b, size, N, fp);  
    //在屏幕上显示数组b的内容 
    for(i=0; i<N; i++)
    {        
        printf("%d ", b[i]);  
    }   
    printf("\n");  
    fclose(fp);
    return 0;
}
```

运行结果：

```
23 409 500 100 222
23 409 500 100 222
```

打开 `D:\\demo.txt`，发现文件内容根本无法阅读。这是因为我们使用`"rb+"`方式打开文件，数组会原封不动地以二进制形式写入文件，一般无法阅读。

数据写入完毕后，位置指针在文件的末尾，要想读取数据，必须将文件指针移动到文件开头，这就是`rewind(fp);`的作用。

> 文件的后缀不一定是` .txt`，它可以是任意的，你可以自己命名，例如 demo.ddd、demo.doc、demo.diy 等。

# `fscanf()`&`fprintf()`

`fscanf()` 和 `fprintf()` 函数与前面使用的 `scanf() `和` printf() `功能相似，都是格式化读写函数，两者的区别在于 `fscanf() `和` fprintf() `的读写对象不是键盘和显示器，而是磁盘文件。

这两个函数的原型为：

```cpp
int fscanf ( FILE *fp, char * format, ... );
int fprintf ( FILE *fp, char * format, ... );
```

`fp` 为文件指针，`format` 为格式控制字符串，`... `表示参数列表。与` scanf() `和` printf() `相比，它们仅仅多了一个 `fp `参数。例如：

```cpp
FILE *fp;
int i, j;
char *str, ch;
fscanf(fp, "%d %s", &i, str);
fprintf(fp,"%d %c", j, ch);
```

`fprintf() `返回成功写入的字符的个数，失败则返回负数。`fscanf()` 返回参数列表中被成功赋值的参数个数。用` fprintf() `和 `fscanf()` 函数读写配置文件、日志文件会非常方便，不但程序能够识别，用户也可以看懂，可以手动修改。如果将` fp `设置为` stdin`，那么 `fscanf() `函数将会从键盘读取数据，与 `scanf `的作用相同；设置为` stdout`，那么 `fprintf()` 函数将会向显示器输出内容，与` printf `的作用相同。

# 随机读写

前面介绍的文件读写函数都是顺序读写，即读写文件只能从头开始，依次读写各个数据。但在实际开发中经常需要读写文件的中间部分，要解决这个问题，就得先移动文件内部的位置指针，再进行读写。这种读写方式称为<mark>随机读写</mark>，也就是说从文件的任意位置开始读写。实现随机读写的关键是要按要求移动位置指针，这称为文件的定位。

## 文件定位函数`rewind`和`fseek`

移动文件内部位置指针的函数主要有两个，即 `rewind() `和` fseek()`。

`rewind()` 用来将位置指针移动到文件开头，前面已经多次使用过，它的原型为：

```cpp
void rewind ( FILE *fp );
```

`fseek() `用来将位置指针移动到任意位置，它的原型为：

```cpp
int fseek ( FILE *fp, long offset, int origin );
```

参数说明：

- `fp` 为文件指针，也就是被移动的文件。
- `offset `为偏移量，也就是要移动的字节数。之所以为 `long`类型，是希望移动的范围更大，能处理的文件更大。`offset` 为正时，向后移动；`offset` 为负时，向前移动。
- `origin` 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为文件开头、当前位置和文件末尾，每个位置都用对应的常量来表示：

| 起始点   | 常量名     | 常量值 |
| -------- | ---------- | ------ |
| 文件开头 | `SEEK_SET` | 0      |
| 当前位置 | `SEEK_CUR` | 1      |
| 文件末尾 | `SEEK_END` | 2      |

例如，把位置指针移动到离文件开头100个字节处：

```cpp
fseek(fp, 100, 0);
```

值得说明的是，`fseek()` 一般用于二进制文件，**在文本文件中由于要进行转换，计算的位置有时会出错**。

## 文件的随机读写

在移动位置指针之后，就可以用前面介绍的任何一种读写函数进行读写了。由于是二进制文件，因此常用 `fread() `和 `fwrite() `读写。

例如从键盘输入三组学生信息，保存到文件中，然后读取第二个学生的信息：

```cpp
#include<stdio.h>
#define N 3
struct stu{
    char name[10]; //姓名  
    int num;  //学号  
    int age;  //年龄
    float score;  //成绩
}boys[N], boy, *pboys;
int main()
{   
    FILE *fp;  
    int i;   
    pboys = boys; 
    if( (fp=fopen("d:\\demo.txt", "wb+")) == NULL )
    {     
        printf("Cannot open file, press any key to exit!\n");   
        getch();      
        exit(1);  
    }   
    printf("Input data:\n");  
    for(i=0; i<N; i++,pboys++)
    {      
        scanf("%s %d %d %f", pboys->name, &pboys->num, &pboys->age, &pboys->score); 
    }    
    fwrite(boys, sizeof(struct stu), N, fp);  //写入三条学生信息 
    fseek(fp, sizeof(struct stu), SEEK_SET);  //移动位置指针  
    fread(&boy, sizeof(struct stu), 1, fp);  //读取一条学生信息   
    printf("%s  %d  %d %f\n", boy.name, boy.num, boy.age, boy.score);  
    fclose(fp);   
    return 0;
}
```

运行结果：

```
Tom 2 15 90.5
Hua 1 14 99
Zhao 10 16 95.5
Hua 1 14 99.000000
```

# `FILE`结构体及缓冲区

在C语言中，用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。

定义文件指针的一般形式为：

```cpp
FILE  *fp;
```

这里的`FILE`，实际上是在`stdio.h`中定义的一个结构体，该结构体中含有文件名、文件状态和文件当前位置等信息。我们通过`fopen`返回一个文件指针(指向`FILE`结构体的指针)来进行文件操作。

注意：`FILE`是文件缓冲区的结构，`fp`也是指向文件缓冲区的指针。

不同编译器 `stdio.h` 头文件中对 `FILE` 的定义略有差异，这里以标准C举例说明：

```cpp
#define NULL 0
#define EOF (-1)
#define BUFSIZ 1024
#define OPEN_MAX 20 // 一次打开的最大文件数
// 定义FILE结构体
typedef struct _iobuf {
	int cnt; // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取
	char *ptr; // 下一个要被读取的字符的地址
	char *base; // 缓冲区基地址
	int flag; // 读写状态标志位
	int fd; // 文件描述符
} FILE;
extern FILE _iob[OPEN_MAX];
#define stdin (&_iob[0]) // stdin 的文件描述符为0
#define stdout (&_iob[1]) // stdout 的文件描述符为1
#define stderr (&_iob[2]) // stdout 的文件描述符为2
enum _flags {
	_READ =01, // 读文件
	_WRITE =02, // 写文件
	_UNBUF =04, // 无缓冲
	_EOF = 010, // 文件结尾EOF
	_ERR = 020 // 出错
};
int _fillbuf(FILE *); // 函数声明，填充缓冲区
int _flushbuf(int, FILE *); // 函数声明，刷新缓冲区
#define feof(p) ((p)->flag & _EOF) != 0)
#define ferror(p) ((p)->flag & _ERR) != 0)
#define fileno(p) ((p)->fd)
#define getc(p) (--(p)->cnt >= 0 \
				? (unsigned char) *(p)->ptr++ : _fillbuf(p))
#define putc(x,p) (--(p)->cnt >= 0 \
				? *(p)->ptr++ = (x) : _flushbuf((x),p))
#define getchar() getc(stdin)
#define putcher(x) putc ((x), stdout)
```

看吧，经常使用的` NULL`、`EOF`、`feof()`、`getc()` 等都是 `stdio.h `中定义的宏。

下面说一下如果控制缓冲区。当我们从键盘输入数据的时候，数据并不是直接被我们得到，而是放在了缓冲区中，然后我们从缓冲区中得到我们想要的数据 。如果我们通过 `setbuf() `或` setvbuf() `函数将缓冲区设置10个字节的大小，而我们从键盘输入了20个字节大小的数据，这样我们输入的前10个数据会放在缓冲区中，因为我们设置的缓冲区的大小只能够装下10个字节大小的数据，装不下20个字节大小的数据。那么剩下的那10个字节大小的数据怎么办呢？暂时放在了输入流中。请看下图：

![img](https://img-blog.csdn.net/20150427182158084)

上面的箭头表示的区域就相当是一个输入流，红色的地方相当于一个开关，这个开关可以控制往深绿色区域（标注的是缓冲区）里放进去的数据，输入20个字节的数据只往缓冲区中放进去了10个字节，剩下的10个字节的数据就被停留在了输入流里！等待下去往缓冲区中放入！接下来系统是如何来控制这个缓冲区呢？

再说一下 `FILE `结构体中几个相关成员的含义：

```cpp
cnt  // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取
ptr  // 下一个要被读取的字符的地址
base  // 缓冲区基地址
```

在上面我们向缓冲区中放入了10个字节大小的数据，`FILE`结构体中的 `cnt `变为了10 ，说明此时缓冲区中有10个字节大小的数据可以读，同时我们假设缓冲区的基地址也就是`base `是`0x00428e60 `，它是不变的 ，而此时` ptr` 的值也为`0x00428e60 `，表示从`0x00428e60`这个位置开始读取数据，当我们从缓冲区中读取5个数据的时候，`cnt` 变为了5 ，表示缓冲区还有5个数据可以读，`ptr `则变为了`0x0042e865`表示下次应该从这个位置开始读取缓冲区中的数据 ，如果接下来我们再读取5个数据的时候，`cnt `则变为了0 ，表示缓冲区中已经没有任何数据了，`ptr `变为了`0x0042869`表示下次应该从这个位置开始从缓冲区中读取数据，但是此时缓冲区中已经没有任何数据了，所以要将输入流中的剩下的那10个数据放进来，这样缓冲区中又有了10个数据，此时 `cnt `变为了10 ，注意了刚才我们讲到` ptr `的值是`0x00428e69` ，而当缓冲区中重新放进来数据的时候这个 `ptr` 的值变为了`0x00428e60 `，这是因为当缓冲区中没有任何数据的时候要将 `ptr` 这个值进行一下刷新，使其指向缓冲区的基地址也就是`0x0042e860`这个值！因为下次要从这个位置开始读取数据！

在这里有点需要说明：当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键`\r`会被转换为一个换行符`\n`，这个换行符`\n`也会被存储在缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了`123456`这个字符串，然后敲一下回车键`\r`将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。

缓冲区的刷新就是将指针 `ptr` 变为缓冲区的基地址 ，同时 `cnt` 的值变为0 ，因为缓冲区刷新后里面是没有数据的！

# 获取文件大小

实际开发中，有时候需要先获取文件大小再进行下一步操作。C语言没有提供获取文件大小的函数，要想实现该功能，必须自己编写函数。

## `ftell()`函数

`ftell()` 函数用来获取文件内部指针（位置指针）距离文件开头的字节数，它的原型为：

```cpp
long int ftell (FILE * fp);
```

注意：`fp` 要以二进制方式打开，如果以文本方式打开，函数的返回值可能没有意义。

先使用 `fseek()` 将文件内部指针定位到文件末尾，再使用` ftell() `返回内部指针距离文件开头的字节数，这个返回值就等于文件的大小。请看下面的代码：

```cpp
long fsize(FILE *fp)
{
    fseek(fp, 0, SEEK_END);
    return ftell(fp);
}
```

这段代码并不健壮，它移动了文件内部指针，可能会导致接下来的文件操作错误。例如：

```cpp
long size = fsize(fp);
fread(buffer, 1, 1, fp);
```

`fread() `函数将永远读取不到内容。

所以，获取到文件大小后还需要恢复文件内部指针，请看下面的代码：

```cpp
long fsize(FILE *fp)
{
    long n;
    fpos_t fpos; //当前位置
    fgetpos(fp, &fpos); //获取当前位置
    fseek(fp, 0, SEEK_END);
    n = ftell(fp);
    fsetpos(fp,&fpos); //恢复之前的位置
    return n;
}
```

`fpos_t `是在` stdio.h `中定义的结构体，用来保存文件的内部指针。`fgetpos() `用来获取文件内部指针，`fsetpos()` 用来设置文件内部指针。

完整的示例：

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
 
long fsize(FILE *fp);
 
int main()
{
	long size = 0;
	FILE *fp = NULL;
	char filename[30] = "D:\\1.mp4";
	if( (fp = fopen(filename, "rb")) == NULL ){ //以二进制方式打开文件
		printf("Failed to open %s...", filename);
		getch();
		exit(EXIT_SUCCESS);
	}
 
	printf("%ld\n", fsize(fp));
	return 0;
}
 
long fsize(FILE *fp)
{
	long n;
	fpos_t fpos; //当前位置
	fgetpos(fp, &fpos); //获取当前位置
	fseek(fp, 0, SEEK_END);
	n = ftell(fp);
	fsetpos(fp,&fpos); //恢复之前的位置
	return n;
}
```

