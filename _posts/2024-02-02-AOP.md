---
layout: post
title:  "AOP"
date:   2024-02-02 00:00:00 +0800
categories: 编程
tags: java spring
series: 深入 Spring 源码
series_index: 2
comments: true
copyrights: 原创
draft: true
---

Spring 是一个开源的轻量级 JavaEE 框架。它的核心是控制反转（IoC）和面向切面编程（AOP）。Spring 的 IoC 容器负责管理 JavaBean 的生命周期，而 AOP 容器负责管理切面。Spring 还提供了一系列的模块，如 Spring MVC、Spring JDBC、Spring Security 等。

## AOP

### 为什么需要 AOP

我们再次回顾一下三层架构：

![倒金字塔型](/assets/post/images/spring1.svg)

在实际开发中，我们的业务逻辑并不是完全自上而下的，日志、事务、权限控制等横向贯穿在各个层次之间。这些辅助功能被成为切面（Aspect）。

在严格的 OOP 中，如果要向业务代码中添加日志功能，需要这样做：

```java
@Service
public class CalculatorServiceImpl implements CalculatorService {
    @Autowired
    private CalculatorDao calculatorDao;

    public int add(int a, int b) {
        System.out.println("[INFO] add method start");
        int result = calculatorDao.add(a, b);
        System.out.println("[INFO] add method end");
        return result;
    }

    public int subtract(int a, int b) {
        System.out.println("[INFO] subtract method start");
        int result = calculatorDao.subtract(a, b);
        System.out.println("[INFO] subtract method end");
        return result;
    }

    /* ... */
}
```

可以看到，这样做有几个问题：

- **代码冗余**

  每个方法都需要写高度雷同日志代码，导致了代码冗余。

- **耦合度高**

  业务代码和日志代码耦合在一起，导致了耦合度过高，不利于集中维护。

- **横切关注点**

  日志代码是横切关注点，它贯穿在各个方法中，但是却和业务逻辑无关。

AOP 的目的就是解决这些问题。它将横切关注点从业务代码中剥离出来，使得业务代码更加简洁、清晰。

> 它和 Python 中的装饰器有点类似，都是对原先的代码进行进一步包装，在其运行前、运行后、运行中额外执行一些代码。

### AOP 术语

- **横切关注点（Cross-cutting Concern）**

  横切关注点是指那些和业务逻辑无关，但是贯穿在各个方法中的代码。例如日志、事务、权限控制等。

- **通知（Advice）**

  通知是指在横切关注点中需要执行的代码。例如输出日志、开启事务、检查权限等。它有以下几种类型：

  - **前置通知（Before）**：在目标方法执行前执行
  - **后置通知（After）**：在目标方法执行后执行
  - **返回通知（After Returning）**：在目标方法返回结果后执行
  - **异常通知（After Throwing）**：在目标方法抛出异常后执行
  - **环绕通知（Around）**：在目标方法执行前后执行，包括了前面四种通知

- **切面（Aspect）**

  切面是横切关注点和通知结合而成的类。
  
- **目标对象（Target）**

  目标对象是被增强的对象。例如 `CalculatorServiceImpl`。

- **代理对象（Proxy）**

  代理对象是 Spring 生成的代理对象，它将目标对象和切面结合在一起。

- **连接点（Join Point）**

  连接点是指在程序执行过程中能够插入切面的点。例如方法调用、方法执行、异常抛出等。

- **切入点（Pointcut）**

  切入点是指用于定位连接点的表达式。

### 代理模式

在讲解 AOP 之前，我们先来看看代理模式。

#### 静态代理

在静态代理中，代理类和目标类实现了同一个接口，代理类中持有目标类的引用，通过调用目标类的方法来实现代理：

```java
public interface CalculatorService {
    int add(int a, int b);
}

public class CalculatorServiceImpl implements CalculatorService {
    public int add(int a, int b) {
        return a + b;
    }
}

public class CalculatorServiceProxy implements CalculatorService {
    private CalculatorService calculatorService;

    public CalculatorServiceProxy(calculatorService) {
        this.calculatorService = calculatorService;
    }

    public int add(int a, int b) {
        System.out.println("[INFO] add method start");
        int result = calculatorService.add(a, b);
        System.out.println("[INFO] add method end");
        return result;
    }
}

public class TestCalculator {
    @Test
    public void testCalculator() {
        CalculatorService calculatorService = new CalculatorServiceImpl();
        CalculatorService calculatorServiceProxy = new CalculatorServiceProxy(calculatorService);
        int result = calculatorServiceProxy.add(1, 2);
    }
}
```

这种方法只能代理一个接口，如果有多个接口需要代理，就需要写多个代理类。

#### 动态代理

在动态代理中，代理类和目标类没有实现同一个接口，代理类通过实现 `InvocationHandler` 接口来实现代理：

```java
public interface CalculatorService {
    int add(int a, int b);
}

public class CalculatorServiceImpl implements CalculatorService {
    public int add(int a, int b) {
        return a + b;
    }
}

public class CalculatorServiceProxy implements InvocationHandler {
    private Object target;

    public CalculatorServiceProxy(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("[INFO] " + method.getName() + " method start, args: " + Arrays.toString(args));
        Object result = method.invoke(target, args);
        System.out.println("[INFO] " + method.getName() + " method end");
        return result;
    }
}

public class TestCalculator {
    @Test
    public void testCalculator() {
        CalculatorService calculatorService = new CalculatorServiceImpl();
        CalculatorService calculatorServiceProxy = (CalculatorService) Proxy.newProxyInstance(
                calculatorService.getClass().getClassLoader(),
                calculatorService.getClass().getInterfaces(),
                new CalculatorServiceProxy(calculatorService)
        );
        int result = calculatorServiceProxy.add(1, 2);
    }
}
```

这里的 `Proxy.newProxyInstance` 方法会返回一个代理对象，它实现了 `CalculatorService` 接口，通过 `CalculatorServiceProxy` 来实现代理。

在 Spring 中，AOP 使用的就是动态代理。它通过将以上内容封装进一个类，来实现代理。

### AOP 使用

Spring 提供了两种 AOP 使用方式：基于 XML 配置和基于注解配置。我们先来看看基于注解配置的方式。

首先，我们需要在配置类中开启 AOP：

```java
@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages = "com.example")
public class AppConfig {
}
```

这里，`@EnableAspectJAutoProxy` 注解用于开启 AOP，它会自动扫描 `@Aspect` 注解标记的类，并将其注册为切面，创建代理对象。

然后，我们需要定义一个切面类。我们将各种通知都实现了一下：

```java
@Aspect
@Component
public class LogAspect {
    @Before("execution(* com.example.CalculatorService.*(..))")
    public void before(JoinPoint joinPoint) {
        System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method start, args: " + Arrays.toString(joinPoint.getArgs()));
    }

    @After("execution(* com.example.CalculatorService.*(..))")
    public void after(JoinPoint joinPoint) {
        System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method end");
    }

    @AfterReturning(pointcut = "execution(* com.example.CalculatorService.*(..))", returning = "result")
    public void afterReturning(JoinPoint joinPoint, Object result) {
        System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method return " + result);
    }

    @AfterThrowing(pointcut = "execution(* com.example.CalculatorService.*(..))", throwing = "e")
    public void afterThrowing(JoinPoint joinPoint, Throwable e) {
        System.out.println("[ERROR] " + joinPoint.getSignature().getName() + " method throw " + e);
    }

    @Around("execution(* com.example.CalculatorService.*(..))")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = null;

        try {
            System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method start, args: " + Arrays.toString(joinPoint.getArgs()));
            result = joinPoint.proceed();
            System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method return " + result);
        } catch (Throwable e) {
            System.out.println("[ERROR] " + joinPoint.getSignature().getName() + " method throw " + e);
            throw e;
        } finally {
            System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method end");
        }

        return result;
    }
}
```

这里：

- `@Component` 表明这依然是一个 Bean
- `@Aspect` 表明这是一个切面
- `@Before`、`@After`、`@AfterReturning`、`@AfterThrowing`、`@Around` 分别表示前置通知、后置通知、返回通知、异常通知和环绕通知

  这些通知都需要一个切入点表达式来定位连接点。切入点表达式使用的是 SpEL 表达式。我们会在[下文](#切入点表达式)中讲解。

然后，`CalculatorServiceImpl` 中什么也不用做，就能正常输出日志了：

```java
@Service
public class CalculatorServiceImpl implements CalculatorService {
    public int add(int a, int b) {
        int result = a + b;
        return result;
    }

    public int subtract(int a, int b) {
        int result = a - b;
        return result;
    }

    /* ... */
}
```

这样，我们就实现了 AOP。

对于有多个切面的情况，可以使用 `@Order` 注解来指定切面的优先级：

```java
@Aspect
@Component
@Order(1)
public class LogAspect {
    /* ... */
}

@Aspect
@Component
@Order(2)
public class TransactionAspect {
    /* ... */
}
```

这样，`TransactionAspect` 的优先级高于 `LogAspect`，会先执行 `TransactionAspect`。

### 切入点表达式

在上面的例子中，我们使用了切入点表达式来定位连接点。切入点表达式是一个字符串，它有以下几种：

- `execution`：用于匹配方法执行的连接点

  语法：`execution([访问修饰符] 返回类型 [包名.类名].方法名(参数) [异常])`

  - 访问修饰符：`public`、`protected`、`private`、省略
  - 返回类型：`*`、具体类型
  - 包名：`*` 表示一层任意包，`..` 表示当前包及其子包
  
    例如，`*.example` 表示某一层包下的 `example` 包，`com.example..*` 表示 `com.example` 包及其子包下的所有类

  - 类名：`*` 表示任意类，`*Service` 表示以 `Service` 结尾的类
  - 方法名：`*` 表示任意方法，`add*` 表示以 `add` 开头的方法
  - 参数：`(..)` 表示任意参数，`(*)` 表示一个参数，`(*, *)` 表示两个参数，`(*, String)` 表示第一个参数任意，第二个参数为 `String` 类型

- `within`：用于匹配指定类型内的方法执行连接点，例如 `within(com.example..*)` 表示 `com.example` 包及其子包下的所有类

  语法：`within([包名.类名])`

- `this`：用于匹配当前代理对象类型的方法执行连接点，例如 `this(com.example.CalculatorService)` 表示当前代理对象为 `CalculatorService` 类型的方法执行连接点

  语法：`this([包名.类名])`

- `target`：用于匹配当前目标对象类型的方法执行连接点，例如 `target(com.example.CalculatorService)` 表示当前目标对象为 `CalculatorService` 类型的方法执行连接点

  语法：`target([包名.类名])`

- `args`：用于匹配参数类型的方法执行连接点，例如 `args(int)` 表示参数为 `int` 类型的方法执行连接点

  语法：`args([参数类型])`

- `@annotation`：用于匹配标注了指定注解的方法执行连接点，例如 `@annotation(com.example.Log)` 表示标注了 `Log` 注解的方法执行连接点

  语法：`@annotation([注解类型])`

- `bean`：用于匹配指定 Bean 的方法执行连接点，例如 `bean(calculatorService)` 表示 Bean 名称为 `calculatorService` 的方法执行连接点

  语法：`bean([Bean 名称])`

切入点表达式也可以一次定义，多次使用：

```java
@Pointcut("execution(* com.example.CalculatorService.*(..))")
public void pointcut() {}

@Before("pointcut()")
public void before(JoinPoint joinPoint) {
    System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method start, args: " + Arrays.toString(joinPoint.getArgs()));
}
```

这里的 `pointcut()` 方法被称为切入点方法，它的返回值类型可以是 `void`、`String`、`Object`，也可以没有返回值。

如果要在不同的切面中使用，可以：

```java
@Before("com.example.LogAspect.pointcut()")
public void before(JoinPoint joinPoint) {
    System.out.println("[INFO] " + joinPoint.getSignature().getName() + " method start, args: " + Arrays.toString(joinPoint.getArgs()));
}
```

### 基于 XML 配置

<details>
<summary>点击展开</summary>
<div markdown="1">

如果不适用配置类，也可以在 XML 配置文件中开启 AOP：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
  
      <aop:aspectj-autoproxy/>
      <context:component-scan base-package="com.example"/>

</beans>
```

AOP 同样能够完全基于 XML 配置：

```xml
<bean id="logAspect" class="com.example.LogAspect"/>

<aop:config>
    <aop:aspect ref="logAspect">
        <aop:pointcut id="pointcut" expression="execution(* com.example.CalculatorService.*(..))"/>
        <aop:before method="before" pointcut-ref="pointcut"/>
        <aop:after method="after" pointcut-ref="pointcut"/>
        <aop:after-returning method="afterReturning" pointcut-ref="pointcut" returning="result"/>
        <aop:after-throwing method="afterThrowing" pointcut-ref="pointcut" throwing="e"/>
        <aop:around method="around" pointcut-ref="pointcut"/>
    </aop:aspect>
</aop:config>
```

</div>
</details>

## AOP 源码解读

我们来看看 Spring 是如何实现 AOP 的。

### 配置类开启 AOP

<details>
<summary>点击查看配置类开启 AOP 源码解读</summary>
<div markdown="1">

先来看 `@EnableAspectJAutoProxy` 注解：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
    boolean proxyTargetClass() default false;
    boolean exposeProxy() default false;
}
```

这里的 `@Import` 注解表明要导入 `AspectJAutoProxyRegistrar` 类。我们来看看这个类：

```java
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(
        AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 注册 AOP 代理实现的 Bean
        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

        AnnotationAttributes enableAspectJAutoProxy =
            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
        if (enableAspectJAutoProxy != null) {
            if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
            }
            if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
            }
        }
    }
}
```

跟踪到 `registerAspectJAnnotationAutoProxyCreatorIfNecessary` 方法，最终来到

```java
@Nullable
private static BeanDefinition registerOrEscalateApcAsRequired(
		Class<?> cls, BeanDefinitionRegistry registry, @Nullable Object source) {

		Assert.notNull(registry, "BeanDefinitionRegistry must not be null");

    // 如果已经注册了
		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
        // 判断优先级，如果更高，则替换
        if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
            int requiredPriority = findPriorityForClass(cls);
            if (currentPriority < requiredPriority) {
                apcDefinition.setBeanClassName(cls.getName());
            }
        }
        return null;
		}

    // 将代理后的 Bean 注册到容器中
		RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
		beanDefinition.setSource(source);
		beanDefinition.getPropertyValues().add("order", Ordered.HIGHEST_PRECEDENCE);
		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
		return beanDefinition;
}
```

总体来讲，就是将已经代理过的 Bean 注册到容器中。

</div>
</details>

### 切面类

前文我们多次提到 `BeanPostProcessor`，但我故意回避了谈论它，不过现在可以了。

`BeanPostProcessor` 是 Spring 中的一个扩展点，它允许我们对 Bean 进行修改。

AOP 的实现就是通过 `BeanPostProcessor` 来实现的。Spring 中有一个 `AspectJAwareAdvisorAutoProxyCreator` 类，它实现了 `BeanPostProcessor` 接口。
它的作用就是对 Bean 进行修改，将切面织入到 Bean 中。

前后执行的函数分别为 `postProcessBeforeInstantiation` 和 `postProcessAfterInstantiation`。

<details>
<summary>点击查看切面类源码解读</summary>
<div markdown="1">

我们先从 `postProcessBeforeInstantiation` 方法开始。它有多个实现类，我们先看 `AbstractAutoProxyCreator`：

```java
@Override
@Nullable
public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {
    Object cacheKey = getCacheKey(beanClass, beanName);

    if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {
        // 如果已经代理过了，直接返回
        if (this.advisedBeans.containsKey(cacheKey)) {
            return null;
        }
        // 如果是基础类或者需要跳过的类，则放入缓存，并注明不需要代理
        if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
            this.advisedBeans.put(cacheKey, Boolean.FALSE);
            return null;
        }
    }

    // 获取目标对象
    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
    if (targetSource != null) {
        if (StringUtils.hasLength(beanName)) {
            this.targetSourcedBeans.add(beanName);
        }

        // 获取通知
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
        // 创建代理
        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
        // 将代理对象注册到容器中
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    return null;
}
```

</div>
</details>

### 获取通知

`getAdvicesAndAdvisorsForBean` 方法用于获取通知。

<details>
<summary>点击查看获取通知源码解读</summary>
<div markdown="1">

```java
@Override
@Nullable
protected Object[] getAdvicesAndAdvisorsForBean(
    Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {

    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
    if (advisors.isEmpty()) {
        return DO_NOT_PROXY;
    }
    return advisors.toArray();
}
```

继续跟踪到 `findEligibleAdvisors` 方法：

```java
protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
    // 获取所有通知
    List<Advisor> candidateAdvisors = findCandidateAdvisors();
    // 筛选出符合条件的通知
    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    extendAdvisors(eligibleAdvisors);
    if (!eligibleAdvisors.isEmpty()) {
        try {
            eligibleAdvisors = sortAdvisors(eligibleAdvisors);
        }
        catch (BeanCreationException ex) {
            throw new AopConfigException("Advisor sorting failed with unexpected bean creation, probably due " +
                "to custom use of the Ordered interface. Consider using the @Order annotation instead.", ex);
        }
    }
    return eligibleAdvisors;
}
```

- 先看 `findCandidateAdvisors()` 方法

  ```java
  @Override
	protected List<Advisor> findCandidateAdvisors() {
      // 加载配置文件中的 AOP 声明
      List<Advisor> advisors = super.findCandidateAdvisors();
      if (this.aspectJAdvisorsBuilder != null) {
          // 加载 @Aspect 声明
          advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
      }
      return advisors;
	}
  ```

  跟踪 `buildAspectJAdvisors()` 方法：

  ```java
  public List<Advisor> buildAspectJAdvisors() {
      List<String> aspectNames = this.aspectBeanNames;

      if (aspectNames == null) {
          synchronized (this) {
              aspectNames = this.aspectBeanNames;
              if (aspectNames == null) {
                  List<Advisor> advisors = new ArrayList<>();
                  aspectNames = new ArrayList<>();
                  // 获取所有 Bean 的名称
                  String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                      this.beanFactory, Object.class, true, false);
                  for (String beanName : beanNames) {
                      if (!isEligibleBean(beanName)) {
                          continue;
                      }
                      Class<?> beanType = this.beanFactory.getType(beanName, false);
                      if (beanType == null) {
                          continue;
                      }
                      // 判断是否带有 @Aspect 注解
                      if (this.advisorFactory.isAspect(beanType)) {
                          try {
                              AspectMetadata amd = new AspectMetadata(beanType, beanName);
                              // 如果是单例
                              if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
                                  MetadataAwareAspectInstanceFactory factory =
                                      new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
                                  // 解析所有的通知
                                  List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);
                                  if (this.beanFactory.isSingleton(beanName)) {
                                      this.advisorsCache.put(beanName, classAdvisors);
                                  }
                                  else {
                                      this.aspectFactoryCache.put(beanName, factory);
                                  }
                                  advisors.addAll(classAdvisors);
                              }
                              else {
                                  if (this.beanFactory.isSingleton(beanName)) {
                                      throw new IllegalArgumentException("Bean with name '" + beanName +
                                          "' is a singleton, but aspect instantiation model is not singleton");
                                  }
                                  MetadataAwareAspectInstanceFactory factory =
                                      new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
                                  this.aspectFactoryCache.put(beanName, factory);
                                  advisors.addAll(this.advisorFactory.getAdvisors(factory));
                              }
                              aspectNames.add(beanName);
                          }
                          catch (IllegalArgumentException | IllegalStateException | AopConfigException ex) {
                              if (logger.isDebugEnabled()) {
                                  logger.debug("Ignoring incompatible aspect [" + beanType.getName() + "]: " + ex);
                              }
                          }
                      }
                  }
                  this.aspectBeanNames = aspectNames;
                  return advisors;
              }
          }
      }

      if (aspectNames.isEmpty()) {
          return Collections.emptyList();
      }
      List<Advisor> advisors = new ArrayList<>();
      for (String aspectName : aspectNames) {
          List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);
          if (cachedAdvisors != null) {
              advisors.addAll(cachedAdvisors);
          }
          else {
              MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
              advisors.addAll(this.advisorFactory.getAdvisors(factory));
          }
      }
      return advisors;
	}
  ```

  继续进入 `getAdvisors` 方法：

  ```java
  @Override
	public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
      // 获取所有 Aspect 类
      Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
      String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
      validate(aspectClass);

      MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
          new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

      List<Advisor> advisors = new ArrayList<>();
      // 遍历类中的所有方法
      for (Method method : getAdvisorMethods(aspectClass)) {
          if (method.equals(ClassUtils.getMostSpecificMethod(method, aspectClass))) {
              // 获取通知
              Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, 0, aspectName);
              if (advisor != null) {
                  advisors.add(advisor);
              }
          }
      }

      // 如果配置了延迟通知，则在第一个位置添加同步实例化通知方法
      if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
          Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
          advisors.add(0, instantiationAdvisor);
      }

      // 获取字段增强
      for (Field field : aspectClass.getDeclaredFields()) {
        Advisor advisor = getDeclareParentsAdvisor(field);
        if (advisor != null) {
          advisors.add(advisor);
        }
      }

      return advisors;
	}
  ```

</div>
</details>
