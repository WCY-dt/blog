---
layout: post
title:  "【C++】杂项 <img src='https://img.shields.io/badge/-转载-C9284D?style=flat'>"
date:   2021-01-19 00:00:00 +0800
categories: toturial
tags: C++ 杂项
comments: 1
mathjax: true
---

本文整理了一些C++较琐碎的知识。

# namespace和头文件

一个中大型软件往往由多名程序员共同开发，会使用大量的变量和函数，不可避免地会出现变量或函数的命名冲突。当所有人的代码都测试通过，没有问题时，将它们结合到一起就有可能会出现命名冲突。

例如小李和小韩都参与了一个文件管理系统的开发，它们都定义了一个全局变量 `fp`，用来指明当前打开的文件，将他们的代码整合在一起编译时，很明显编译器会提示` fp`<mark> 重复定义</mark>（Redefinition）错误。

为了解决合作开发时的命名冲突问题，C++引入了<mark>命名空间</mark>（Namespace）的概念。请看下面的例子：

```cpp
namespace Li{  
    //小李的变量定义 
    FILE fp = NULL;
}
namespace Han{  
    //小韩的变量定义 
    FILE fp = NULL
}
```

小李与小韩各自定义了以自己姓氏为名的命名空间，此时再将他们的` fp `变量放在一起编译就不会有任何问题。

> 命名空间有时也被称为名字空间、名称空间。

`namespace` 是C++中的关键字，用来定义一个命名空间，语法格式为：

```cpp
namespace name{
  //variables, functions, classes
}
```

`name`是命名空间的名字，它里面可以包含变量、函数、类、`typedef`、`#define` 等，最后由`{ }`包围。

使用变量、函数时要指明它们所在的命名空间。以上面的 `fp `变量为例，可以这样来使用：

```cpp
Li::fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```

`::`是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。

除了直接使用域解析操作符，还可以采用 `using `关键字声明，例如：

```cpp
using Li::fp;
fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han :: fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```

在代码的开头用`using`声明了 `Li::fp`，它的意思是，`using` 声明以后的程序中如果出现了未指明命名空间的 `fp`，就使用 `Li::fp`；但是若要使用小韩定义的` fp`，仍然需要 `Han::fp`。

`using` 声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间，例如：

```cpp
using namespace Li;
fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
```

如果命名空间 `Li` 中还定义了其他的变量，那么同样具有 `fp` 变量的效果。在 `using `声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间 `Li `中的变量。

命名空间内部不仅可以声明或定义变量，对于其它能在命名空间以外声明或定义的名称，同样也都能在命名空间内部进行声明或定义，例如类、函数、`typedef`、`#define` 等都可以出现在命名空间中。

站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种<mark>符号</mark>（Symbol）。有的符号可以指代一个内存位置，例如变量名、函数名；有的符号仅仅是一个新的名称，例如 `typedef` 定义的类型别名。

下面来看一个命名空间完整示例代码：

```cpp
#include <stdio.h>
//将类定义在命名空间中
namespace Diy{  
    class Student{  
    public:  
        char *name;   
        int age;     
        float score;   
    public:     
        void say(){  
            printf("%s的年龄是 %d，成绩是 %f\n", name, age, score); 
        }  
    };
}
int main()
{  
    Diy::Student stu1;  
    stu1.name = "小明";  
    stu1.age = 15;  
    stu1.score = 92.5f;   
    stu1.say(); 
    return 0;
}
```

运行结果：

```
小明的年龄是 15，成绩是 92.500000
```

C++是在C语言的基础上开发的，早期的 C++ 还不完善，不支持命名空间，没有自己的编译器，而是将 C++ 代码翻译成C代码，再通过C编译器完成编译。这个时候的 C++ 仍然在使用C语言的库，`stdio.h`、`stdlib.h`、`string.h`等头文件依然有效；此外 C++ 也开发了一些新的库，增加了自己的头文件，例如：

- `iostream.h`：用于控制台输入输出头文件。
- `fstream.h`：用于文件操作的头文件。
- `complex.h`：用于复数计算的头文件。


和C语言一样，C++ 头文件仍然以`.h`为后缀，它们所包含的类、函数、宏等都是全局范围的。

后来 C++ 引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是`std`。std 是 standard 的缩写，意思是<mark>标准命名空间</mark>。

但是这时已经有很多用老式 C++ 开发的程序了，它们的代码中并没有使用命名空间，直接修改原来的库会带来一个很严重的后果：程序员会因为不愿花费大量时间修改老式代码而极力反抗，拒绝使用新标准的 C++ 代码。C++ 开发人员想了一个好办法，保留原来的库和头文件，它们在 C++ 中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间 std 下，就成了新版 C++ 标准库。这样共存在了两份功能相似的库，使用了老式 C++ 的程序可以继续使用原来的库，新开发的程序可以使用新版的 C++ 库。

为了避免头文件重名，新版 C++ 库也对头文件的命名做了调整，去掉了后缀`.h`，所以老式 C++ 的`iostream.h`变成了`iostream`，`fstream.h`变成了`fstream`。而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个`c`字母，所以C语言的`stdio.h`变成了`cstdio`，`stdlib.h`变成了`cstdlib`。

需要注意的是，旧的 C++ 头文件是官方所反对使用的，已明确提出不再支持，但旧的C头文件仍然可以使用，以保持对C的兼容性。实际上，编译器开发商不会停止对客户现有软件提供支持，可以预计，旧的 C++ 头文件在未来数年内还是会被支持。

下面是我总结的 C++ 头文件的现状：

- 旧的 C++ 头文件，如 `iostream.h`、`fstream.h `等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间 std 中。

- 新的 C++ 头文件，如 `iostream`、`fstream `等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间` std `中。

> 注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。

- 标准C头文件如 `stdio.h`、`stdlib.h` 等继续被支持。头文件的内容不在` std `中。

- 具有C库功能的新C++头文件具有如` cstdio`、`cstdlib` 这样的名字。它们提供的内容和相应的旧的C头文件相同，只是内容在 `std `中。

可以发现，对于不带`.h`的头文件，所有的符号都位于命名空间 `std` 中，使用时需要声明命名空间 `std`；对于带`.h`的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的。

不过现实情况和 C++ 标准所期望的有些不同，对于原来C语言的头文件，即使按照 C++ 的方式来使用，即`#include <cstdio>`这种形式，那么符号可以位于命名空间 std 中，也可以位于全局范围中，请看下面的两段代码。

1) 使用命名空间 `std`：

```cpp
#include <cstdio>
int main()
{  
    std::printf("hi\n");   
    return 0;
}
```


2) 不使用命名空间 `std`：

```cpp
#include <cstdio>
int main()
{  
    printf("hi\n");   
    return 0;
}
```

这两种形式在 Microsoft Visual C++ 和 GCC下都能够编译通过，也就是说，大部分编译器在实现时并没有严格遵循C++标准，它们对两种写法都支持，程序员可以使用 `std `也可以不使用。第 1) 种写法是标准的，第 2) 种不标准，虽然它们在目前的编译器中都没有错误，但我依然推荐使用第 1) 种写法，因为标准写法会一直被编译器支持，非标准写法可能会在以后的升级版本中不再支持。

虽然 C++ 几乎完全兼容C语言，C语言的头文件在 C++ 中依然被支持，但 C++ 新增的库更加强大和灵活，请读者尽量使用这些 C++ 新增的头文件，例如 `iostream`、`fstream`、`string `等。

前面几节我们使用了C语言的格式输出函数 `printf`，引入了C语言的头文件 `stdio.h`，将C代码和 C++ 代码混合在了一起，我不推荐这样做，请尽量使用 C++ 的方式。下面的例子演示了如何使用 C++ 库进行输入输出：

```cpp
#include <iostream>
#include <string>
int main()
{   
    //声明命名空间std   
    using namespace std;  
    //定义字符串变量   
    string str;   
    //定义 int 变量 
    int age;   
    //从控制台获取用户输入 
    cin>>str>>age;  
    //将数据输出到控制台 
    cout<<str<<"已经成立"<<age<<"年了！"<<endl;   
    return 0;
}
```

运行结果：

```
baidu
666
baidu已经成立666了！
```

读者暂时不需要深入了解这段代码的细节，只需要留意`using namespace std;`，它声明了命名空间 `std`，后续如果有未指定命名空间的符号，那么默认使用 `std`，代码中的 `string`、`cin`、`cout` 都位于命名空间 `std`。

在 `main()` 函数中声明命名空间 `std`，它的作用范围就位于` main() `函数内部，如果在其他函数中又用到了 `std`，就需要重新声明，请看下面的例子：

```cpp
#include <iostream>
void func()
{  
    //必须重新声明 
    using namespace std; 
    cout<<"hi"<<endl;
}
int main()
{  
    //声明命名空间std  
    using namespace std;   
    cout<<"C语言"<<endl;
    func();   
    return 0;
}
```

如果希望在所有函数中都使用命名空间 `std`，可以将它声明在全局范围中，例如：

```cpp
#include <iostream>
//声明命名空间std
using namespace std;
void func()
{   
    cout<<"hi"<<endl;
}
int main()
{  
    cout<<"C语言"<<endl;  
    func();  
    return 0;
}
```

很多教程中都是这样做的，将 `std `直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，我推荐在函数内部声明 `std`。

# `new()`&`delete()`

在C语言中，动态分配内存用 `malloc() `函数，释放内存用` free() `函数。如下所示：

```c
int *p = (int*) malloc( sizeof(int) * 10 );  //分配10个int型的内存空间
free(p);  //释放内存
```

在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，`new `和 `delete`：`new` 用来动态分配内存，`delete `用来释放内存。

用 `new `和` delete `分配内存更加简单：

```cpp
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存
```

`new `操作符会根据后面的数据类型来推断所需空间的大小。

如果希望分配一组连续的数据，可以使用 `new[]`：

```cpp
int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
```

用 `new[] `分配的内存需要用 `delete[] `释放，它们是一一对应的。

和 `malloc()` 一样，`new` 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常` new `和 `delete`、`new[]` 和 `delete[] `操作符应该成对出现，并且不要和C语言中 `malloc()`、`free() `一起混用。

# inline函数

函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。

一个 C/C++程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 `main()`，终点也是` main()`。当 `main() `调用完了所有的函数，它会返回一个值（例如`return 0;`）来结束自己的生命，从而结束整个程序。

函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。

如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为<mark>内联函数</mark>（Inline Function），又称内嵌函数或者内置函数。

指定内联函数的方法很简单，只需要在函数定义处增加 inline 关键字。请看下面的例子：

```cpp
#include <iostream>
using namespace std;
//内联函数，交换两个数的值
inline void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main()
{
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;
    return 0;
}
```

运行结果：

```
45 99
45, 99
99, 45
```

注意，要在函数定义处添加 `inline `关键字，在函数声明处添加` inline `关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 `inline `关键字。

当编译器遇到函数调用`swap(&m, &n)`时，会用 `swap()` 函数的代码替换`swap(&m, &n)`，同时用实参代替形参。这样，程序第 16 行就被置换成：

```cpp
int temp;
temp = *(&m);
*(&m) = *(&n);
*(&n) = temp;
```

编译器可能会将 `*(&m)`、`*(&n)` 分别优化为 `m`、`n`。

当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

由于内联函数比较短小，我们通常的做法是省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。下面的例子是一个反面教材，这样的写法是不被推荐的：

```cpp
#include <iostream>
using namespace std;
//声明内联函数
void swap1(int *a, int *b);  //也可以添加inline，但编译器会忽略
int main()
{
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap1(&m, &n);
    cout<<m<<", "<<n<<endl;

    return 0;
}
//定义内联函数
inline void swap1(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。

最后需要说明的是，对函数作` inline` 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为` inline` 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。

# 引用

我们知道，参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。

对于像 `char`、`bool`、`int`、`float `等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。

C/C++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组指针。而对于结构体和对象没有这种限制，调用函数时既可以传递指针，也可以直接传递内容；为了提高效率，我曾建议传递指针，这样做在大部分情况下并没有什么不妥。

但是在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是<mark>引用</mark>（Reference）。

> 在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为基本类型，将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型（在讲解结构体时也曾使用复杂类型、构造类型这两种说法）。

引用（Reference）是 C++ 相对于C语言的又一个扩充。引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；引用还类似于人的绰号（笔名），使用绰号（笔名）和本名都能表示一个人。

引用的定义方式类似于指针，只是用`&`取代了`*`，语法格式为：

```cpp
type &name = data;
```

`type` 是被引用的数据的类型，name 是引用的名称，data 是被引用的数据。引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。

下面是一个演示引用的实例：

```cpp
#include <iostream>
using namespace std;
int main() {
    int a = 99;
    int &r = a;
    cout << a << ", " << r << endl;
    cout << &a << ", " << &r << endl;
    return 0;
}
```

运行结果：

```
99, 99
0x28ff44, 0x28ff44
```

本例中，变量` r` 就是变量 `a `的引用，它们用来指代同一份数据；也可以说变量 `r` 是变量` a `的另一个名字。从输出结果可以看出，`a` 和` r` 的地址一样，都是`0x28ff44`；或者说地址为`0x28ff44`的内存有两个名字，`a `和 `r`，想要访问该内存上的数据时，使用哪个名字都行。

注意，引用在定义时需要添加`&`，在使用时不能添加`&`，使用时添加`&`表示取地址。如上面代码所示，第 6 行中的`&`表示引用，第 8 行中的`&`表示取地址。除了这两种用法，`&`还可以表示位运算中的与运算。

由于引用` r` 和原始变量` a `都是指向同一地址，所以通过引用也可以修改原始变量中所存储的数据，请看下面的例子：

```cpp
#include <iostream>
using namespace std;
int main() {
    int a = 99;
    int &r = a;
    r = 47;
    cout << a << ", " << r << endl;
    return 0;
}
```

运行结果：

```
47, 47
```

最终程序输出两个 47，可见原始变量 `a `的值已经被引用变量` r `所修改。

如果读者不希望通过引用来修改原始的数据，那么可以在定义时添加` const` 限制，形式为：

```cpp
const type &name = value;
```

也可以是：

```cpp
type const &name = value;
```

这种引用方式为常引用

## 引用作为函数参数

在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。

一个能够展现按引用传参的优势的例子就是交换两个数的值，请看下面的代码：

```cpp
#include <iostream>
using namespace std;

void swap1(int a, int b);
void swap2(int *p1, int *p2);
void swap3(int &r1, int &r2);


int main() {
    int num1, num2;
    cout << "Input two integers: ";
    cin >> num1 >> num2;
    swap1(num1, num2);
    cout << num1 << " " << num2 << endl;

    cout << "Input two integers: ";
    cin >> num1 >> num2;
    swap2(&num1, &num2);
    cout << num1 << " " << num2 << endl;

    cout << "Input two integers: ";
    cin >> num1 >> num2;
    swap3(num1, num2);
    cout << num1 << " " << num2 << endl;

    return 0;
}

//直接传递参数内容
void swap1(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

//传递指针
void swap2(int *p1, int *p2) {
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

//按引用传参
void swap3(int &r1, int &r2) {
    int temp = r1;
    r1 = r2;
    r2 = temp;
}
```

运行结果：

```
Input two integers: 12 34
12 34
Input two integers: 88 99
99 88
Input two integers: 100 200
200 100
```

本例演示了三种交换变量的值的方法：

- `swap1() `直接传递参数的内容，不能达到交换两个数的值的目的。对于 `swap1()` 来说，`a`、`b` 是形参，是作用范围仅限于函数内部的局部变量，它们有自己独立的内存，和 `num1`、`num2` 指代的数据不一样。调用函数时分别将 `num1`、`num2 `的值传递给 `a`、`b`，此后 `num1`、`num2` 和` a`、`b `再无任何关系，在` swap1() `内部修改` a`、`b `的值不会影响函数外部的 `num1`、`num2`，更不会改变` num1`、`num2` 的值。

- `swap2()` 传递的是指针，能够达到交换两个数的值的目的。调用函数时，分别将` num1`、`num2` 的指针传递给` p1`、`p2`，此后 `p1`、`p2 `指向 `a`、`b `所代表的数据，在函数内部可以通过指针间接地修改` a`、`b `的值。

- `swap3() `是按引用传递，能够达到交换两个数的值的目的。调用函数时，分别将 `r1`、`r2 `绑定到 `num1`、`num2` 所指代的数据，此后 `r1 `和 `num1`、`r2` 和 `num2` 就都代表同一份数据了，通过` r1 `修改数据后会影响 `num1`，通过` r2 `修改数据后也会影响` num2`。

从以上代码的编写中可以发现，按引用传参在使用形式上比指针更加直观。在以后的 C++ 编程中，我鼓励读者大量使用引用，它一般可以代替指针（当然指针在C++中也不可或缺），C++ 标准库也是这样做的。

## 引用作为函数返回值

引用除了可以作为函数形参，还可以作为函数返回值，请看下面的例子：

```cpp
#include <iostream>
using namespace std;
int &plus10(int &r) {
    r += 10;
    return r;
}
int main() {
    int num1 = 10;
    int num2 = plus10(num1);
    cout << num1 << " " << num2 << endl;
    return 0;
}
```

运行结果：

```
20 20
```

在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。

更改上面的例子，让 `plus10() `返回一个局部数据的引用：

```cpp
#include <iostream>
using namespace std;
int &plus10(int &r) {
    int m = r + 10;
    return m;  //返回局部数据的引用
}
int main() {
    int num1 = 10;
    int num2 = plus10(num1);
    cout << num2 << endl;
    int &num3 = plus10(num1);
    int &num4 = plus10(num3);
    cout << num3 << " " << num4 << endl;
    return 0;
}
```

在 Visual Studio 下的运行结果：

```
20
-858993450 -858993450
```

在 GCC下的运行结果：

```
20
30 30
```

在 C-Free 下的运行结果：

```
20
30 0
```

而我们期望的运行结果是：

```
20
20 30
```

`plus10() `返回一个对局部变量` m `的引用，这是导致运行结果非常怪异的根源，因为函数是在栈上运行的，并且运行结束后会放弃对所有局部数据的管理权，后面的函数调用会覆盖前面函数的局部数据。本例中，第二次调用 `plus10() `会覆盖第一次调用 `plus10() `所产生的局部数据，第三次调用` plus10() `会覆盖第二次调用 `plus10() `所产生的局部数据。

# `string`

C++大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的` string` 类。`string` 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针。

`string `是 C++ 中常用的一个类，它非常重要，我们有必要在此单独讲解一下。

使用 `string` 类需要包含头文件`<string>`，下面的例子介绍了几种定义` string `变量（对象）的方法：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1;
    string s2 = "c plus plus";
    string s3 = s2;
    string s4 (5, 's');
    return 0;
}
```

变量 `s1` 只是定义但没有初始化，编译器会将默认值赋给` s1`，默认值是`""`，也即空字符串。

变量 `s2 `在定义的同时被初始化为`"c plus plus"`。与C风格的字符串不同，`string` 的结尾没有结束标志`'\0'`。

变量 `s3 `在定义的时候直接用` s2` 进行初始化，因此` s3 `的内容也是`"c plus plus"`。

变量 `s4` 被初始化为由 5 个`'s'`字符组成的字符串，也就是`"sssss"`。

从上面的代码可以看出，`string` 变量可以直接通过赋值操作符`=`进行赋值。`string `变量也可以用C风格的字符串进行赋值，例如，`s2 `是用一个字符串常量进行初始化的，而 `s3 `则是通过` s2 `变量进行初始化的。

与C风格的字符串不同，当我们需要知道字符串长度时，可以调用 `string` 类提供的` length()` 函数。如下所示：

```cpp
string s = "hi";
int len = s.length();
cout<<len<<endl;
```

输出结果为`2`。由于 string 的末尾没有`'\0'`字符，所以 `length()` 返回的是字符串的真实长度，而不是长度 +1。

## 转换为C风格的字符串

虽然 C++ 提供了 `string` 类来替代C语言中的字符串，但是在实际编程中，有时候必须要使用C风格的字符串（例如打开文件时的路径），为此，`string `类为我们提供了一个转换函数 `c_str()`，该函数能够将 `string` 字符串转换为C风格的字符串，并返回该字符串的 `const` 指针（`const char*`）。请看下面的代码：

```cpp
string path = "D:\\demo.txt";
FILE *fp = fopen(path.c_str(), "rt");
```

为了使用C语言中的` fopen()` 函数打开文件，必须将` string` 字符串转换为C风格的字符串。

## string 字符串的输入输出

`string` 类重载了输入输出运算符，可以像对待普通变量那样对待 `string` 变量，也就是用`>>`进行输入，用`<<`进行输出。请看下面的代码：

```cpp
#include <iostream>
#include <string>

using namespace std;

int main(){
    string s;
    cin>>s;  //输入字符串
    cout<<s<<endl;  //输出字符串
    return 0;
}
```

运行结果：

```
hi hello
hi
```



虽然我们输入了两个由空格隔开的网址，但是只输出了一个，这是因为输入运算符`>>`默认会忽略空格，遇到空格就认为输入结束，所以最后输入的`hello`没有被存储到变量 `s`。

## 访问字符串中的字符

`string` 字符串也可以像C风格的字符串一样按照下标来访问其中的每一个字符。`string` 字符串的起始下标仍是从 0 开始。请看下面的代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s = "1234567890";
    for(int i=0,len=s.length(); i<len; i++){
        cout<<s[i]<<" ";
    }
    cout<<endl;
    s[5] = '5';
    cout<<s<<endl;
    return 0;
}
```

运行结果：

```
1 2 3 4 5 6 7 8 9 0
1234557890
```

本例定义了一个` string` 变量 `s`，并赋值 `1234567890`，之后用 `for` 循环遍历输出每一个字符。借助下标，除了能够访问每个字符，也可以修改每个字符，`s[5] = '5';`就将第6个字符修改为`5`，所以 `s` 最后为 `1234557890`。

## 字符串的拼接

有了` string` 类，我们可以使用`+`或`+=`运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 `strcat()`、`strcpy()`、`malloc()` 等函数来拼接字符串了，再也不用担心空间不够会溢出了。

用`+`来拼接字符串时，运算符的两边可以都是 `string `字符串，也可以是一个` string `字符串和一个C风格的字符串，还可以是一个` string `字符串和一个字符数组，或者是一个` string `字符串和一个单独的字符。请看下面的例子：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first ";
    string s2 = "second ";
    char *s3 = "third ";
    char s4[] = "fourth ";
    char ch = '@';

    string s5 = s1 + s2;
    string s6 = s1 + s3;
    string s7 = s1 + s4;
    string s8 = s1 + ch;
    
    cout<<s5<<endl<<s6<<endl<<s7<<endl<<s8<<endl;

    return 0;
}
```

运行结果：

```
first second
first third
first fourth
first @
```

## string 字符串的增删改查

C++ 提供的 `string `类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。

### 插入字符串

`insert()` 函数可以在 `string` 字符串中指定的位置插入另一个字符串，它的一种原型为：

```cpp
string& insert (size_t pos, const string& str);
```

`pos` 表示要插入的位置，也就是下标；`str` 表示要插入的字符串，它可以是 `string` 字符串，也可以是C风格的字符串。

请看下面的代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1, s2, s3;
    s1 = s2 = "1234567890";
    s3 = "aaa";
    s1.insert(5, s3);
    cout<< s1 <<endl;
    s2.insert(5, "bbb");
    cout<< s2 <<endl;
    return 0;
}
```

运行结果：

```
12345aaa67890
12345bbb67890
```

`insert() `函数的第一个参数有越界的可能，如果越界，则会产生运行时异常。

### 删除字符串

`erase()` 函数可以删除` string` 中的一个子字符串。它的一种原型为：

```cpp
string& erase (size_t pos = 0, size_t len = npos);
```

`pos` 表示要删除的子字符串的起始下标，`len` 表示要删除子字符串的长度。如果不指明 `len` 的话，那么直接删除从` pos` 到字符串结束处的所有字符（此时 `len = str.length - pos`）。

请看下面的代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1, s2, s3;
    s1 = s2 = s3 = "1234567890";
    s2.erase(5);
    s3.erase(5, 3);
    cout<< s1 <<endl;
    cout<< s2 <<endl;
    cout<< s3 <<endl;
    return 0;
}
```

运行结果：

```
1234567890
12345
1234590
```

有读者担心，在` pos` 参数没有越界的情况下，` len `参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，`erase() `函数会从以下两个值中取出最小的一个作为待删除子字符串的长度：

- `len` 的值；
- 字符串长度减去 `pos` 的值。

说得简单一些，待删除字符串最多只能删除到字符串结尾。

### 提取子字符串

`substr() `函数用于从` string `字符串中提取子字符串，它的原型为：

```cpp
string substr (size_t pos = 0, size_t len = npos) const;
```

`pos` 为要提取的子字符串的起始下标，`len` 为要提取的子字符串的长度。

请看下面的代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second third";
    string s2;
    s2 = s1.substr(6, 6);
    cout<< s1 <<endl;
    cout<< s2 <<endl;
    return 0;
}
```

运行结果：

```
first second third
second
```

系统对 `substr()` 参数的处理和 `erase() `类似：

- 如果 `pos` 越界，会抛出异常；
- 如果 `len` 越界，会提取从 `pos` 到字符串结尾处的所有字符。

### 字符串查找

`string `类提供了几个与字符串查找有关的函数，如下所示。

#### `find()` 函数

`find()` 函数用于在`string `字符串中查找子字符串出现的位置，它其中的两种原型为：

```cpp
size_t find (const string& str, size_t pos = 0) const;
size_t find (const char* s, size_t pos = 0) const;
```

第一个参数为待查找的子字符串，它可以是 `string` 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。

请看下面的代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second third";
    string s2 = "second";
    int index = s1.find(s2,5);
    if(index < s1.length())
        cout<<"Found at index : "<< index <<endl;
    else
        cout<<"Not found"<<endl;
    return 0;
}
```

运行结果：

```
Found at index : 6
```

`find() `函数最终返回的是子字符串第一次出现在字符串中的起始下标。本例最终是在下标6处找到了` s2 `字符串。如果没有查找到子字符串，那么会返回一个无穷大值 `4294967295`。

#### `rfind()` 函数

`rfind()` 和` find() `很类似，同样是在字符串中查找子字符串，不同的是` find() `函数从第二个参数开始往后查找，而 `rfind()` 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值`4294967295`。

请看下面的例子：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second third";
    string s2 = "second";
    int index = s1.rfind(s2,6);
    if(index < s1.length())
        cout<<"Found at index : "<< index <<endl;
    else
        cout<<"Not found"<<endl;
    return 0;
}
```

运行结果：

```
Found at index : 6
```

#### `find_first_of()` 函数

`find_first_of()` 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。请看下面的代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s1 = "first second second third";
    string s2 = "asecond";
    int index = s1.find_first_of(s2);
    if(index < s1.length())
        cout<<"Found at index : "<< index <<endl;
    else
        cout<<"Not found"<<endl;
    return 0;
}
```

运行结果：

```
Found at index : 3
```

本例中` s1` 和 `s2 `共同具有的字符是`s`，该字符在 `s1 `中首次出现的下标是3，故查找结果返回3。

## `string`内部实现

C++程序员编码过程中经常会使用`string`(`wstring`)类，你是否思考过它的内部实现细节。比如这个类的迭代器是如何实现的？对象占多少字节的内存空间？内部有没有虚函数？内存是如何分配的？构造和析构的成本有多大？笔者综合这两天阅读的源代码及个人理解简要介绍之，错误的地方望读者指出。

首先看看`string`和`wstring`类的定义：

```cpp
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t> allocator<wchar_t> > wstring;
```

从这个定义可以看出`string`和`wstring`分别是模板类`basic_string`对`char`和`wchar_t`的特化。

再看看`basic_string`类的继承关系（类方法未列出）：

![img](https://img-blog.csdn.net/20140803012500174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGFzc2lvbl93dTEyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

最顶层的类是`_Container_base`，它也是STL容器的基类，Debug下包含一个`_Iterator_base*`的成员，指向容器的最开始的元素，这样就能遍历容器了，并定义了了两个函数

```cpp
void _Orphan_all() const;	// orphan all iterators
void _Swap_all(_Container_base_secure&) const;	// swaps all iterators
```

Release下`_Container_base`只是一个空的类。

`_String_base`类没有数据成员，只定义了异常处理的三个函数：

```cpp
static void _Xlen();	// report a length_error
static void _Xran();	// report an out_of_range error
static void _Xinvarg();
```

`_String_val`包含一个`alloctor`的对象，这个类也非常简单，除了构造函数没有定义其它函数。
上面三个基类都定义得很简单，而`basic_string`类的实现非常复杂。不过它的设计和大多数标准库一样，把复杂的功能分成几部分去实现，充分体现了模块的低耦合。

迭代器有关的操作交给`_String_iterator`类去实现，元素相关的操作交给`char_traits`类去实现，内存分配交给`allocator`类去实现。

`_String_iterator`类的继承关系如下图：

![img](https://img-blog.csdn.net/20140803013924953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGFzc2lvbl93dTEyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这个类实现了迭代器的通用操作，比如：

```cpp
reference  operator*() const;
pointer operator->() const
_String_iterator & operator++()
_String_iterator operator++(int)
_String_iterator& operator--()
_String_iterator operator--(int)
_String_iterator& operator+=(difference_type _Off)
_String_iterator operator+(difference_type _Off) const
_String_iterator& operator-=(difference_type _Off)
_String_iterator operator-(difference_type _Off) const
difference_type operator-(const _Mybase& _Right) const
reference operator[](difference_type _Off) const
```

有了迭代器的实现，就可以很方便的使用算法库里面的函数了，比如将所有字符转换为小写：

```cpp
string s("Hello String");
transform(s.begin(), s.end(), s.begin(), tolower);
```

`char_traits`类图如下：

![img](https://img-blog.csdn.net/20140803014825721?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGFzc2lvbl93dTEyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这个类定义了字符的赋值，拷贝，比较等操作，如果有特殊需求也可以重新定义这个类。

`allocator`类图如下：

![img](https://img-blog.csdn.net/20140803015032971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGFzc2lvbl93dTEyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这个类使用`new`和`delete`完成内存的分配与释放等操作。你也可以定义自己的`allocator`。

再看看`basic_string`类的数据成员：

`_Mysize`表示实际的元素个数，初始值为0；

`_Myres`表示当前可以存储的最大元素个数(超过这个大小就要重新分配内存)，初始值是`_BUF_SIZE-1`；

`_BUF_SIZE`是一个`enum`类型：

```cpp
enum
{	// length of internal buffer, [1, 16]
	_BUF_SIZE = 16 / sizeof (_Elem) < 1 ? 1: 16 / sizeof(_Elem)
};
```

从这个定义可以得出，针对`char`和`wchar_t`它的值分别是16和8。

`_Bxty`是一个`union`：

```cpp
union _Bxty
{	// storage for small buffer or pointer to larger one
	_Elem _Buf[_BUF_SIZE];
	_Elem *_Ptr;
} _Bx;
```

为什么要那样定义`_Bxty`呢，看下面这段代码：

```cpp
_Elem * _Myptr()
{	// determine current pointer to buffer for mutable string
	return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
}
```

这个函数返回`basic_string`内部的元素指针（`c_str`函数就是调用这个函数）。

所以当元素个数小于`_BUF_SIZE`时不用分配内存，直接使用`_Buf`数组，`_Myptr`返回`_Buf`。否则就要分配内存了，`_Myptr`返回`_Ptr`。

不过内存分配策略又是怎样的呢？看下面这段代码：

```cpp
void _Copy(size_type _Newsize, size_type _Oldlen)
{	// copy _Oldlen elements to newly allocated buffer
	size_type _Newres = _Newsize | _ALLOC_MASK;
	if (max_size() < _Newres)
		_Newres = _Newsize;	// undo roundup if too big
	else if (_Newres / 3 < _Myres / 2 && _Myres <= max_size() - _Myres / 2)
		_Newres = _Myres + _Myres / 2;	// grow exponentially if possible
	//other code
}
```

`_ALLOC_MASK`的值是`_BUF_SIZE-1`。这段代码看起来有点复杂，简单描述就是： 最开始`_Myres`每次增加`_BUF_SIZE`，当值达到一定大小时每次增加一半。

针对`char`和`wchar_t`，每次分配内存的临界值分别是(超过这些值就要重新分配)：

`char`：15，31，47，70，105，157，235，352，528，792，1188，1782……
`wchar_t`：7, 15, 23, 34, 51, 76, 114, 171, 256, 384, 576, 864, 1296, 1944……

重新分配后都会先将旧的元素拷贝到新的内存地址。所以当处理一个长度会不断增长而又大概知道最大大小时可以先调用`reserve`函数预分配内存以提高效率。

`string`类占多少字节的内存空间呢？

`_Container_base Debug`下含有一个指针，4字节，`Release`下是空类，0字节。`_String_val`类含有一个`allocator`对象。`string`类使用默认的`allocator`类，这个类没有数据成员，不过按字节对齐的原则，它占4字节。`basic_string`类的成员加起来是24，所以总共是32字节（Debug）或28字节（Relase)。`wstring`也是32或28，至于原因文中已经分析。

综上所述：`string`和`wstring`类借助`_String_iterator`实现迭代器操作，都占32(Debug)或28(Release)字节的内存空间，没有虚函数，构造和析构开销较低，内存分配比较灵活。

# `typeid`

`typeid` 运算符用来获取一个表达式的类型信息。类型信息对于编程语言非常重要，它描述了数据的各种属性：

- 对于基本类型（`int`、`float` 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。
- 对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。

类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。

`typeid` 的操作对象既可以是表达式，也可以是数据类型，下面是它的两种使用方法：

```cpp
typeid(dataType)
typeid(expression)
```

`dataType` 是数据类型，`expression` 是表达式，这和 `sizeof `运算符非常类似，只不过 `sizeof` 有时候可以省略括号`( )`，而` typeid `必须带上括号。

`typeid` 会把获取到的类型信息保存到一个` type_info `类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。`typeid `的使用非常灵活，请看下面的例子（只能在 VC/VS 下运行）：

```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

class Base{ };

struct STU{ };

int main(){
    //获取一个普通变量的类型信息
    int n = 100;
    const type_info &nInfo = typeid(n);
    cout<<nInfo.name()<<" | "<<nInfo.raw_name()<<" | "<<nInfo.hash_code()<<endl;

    //获取一个字面量的类型信息
    const type_info &dInfo = typeid(25.65);
    cout<<dInfo.name()<<" | "<<dInfo.raw_name()<<" | "<<dInfo.hash_code()<<endl;

    //获取一个对象的类型信息
    Base obj;
    const type_info &objInfo = typeid(obj);
    cout<<objInfo.name()<<" | "<<objInfo.raw_name()<<" | "<<objInfo.hash_code()<<endl;

    //获取一个类的类型信息
    const type_info &baseInfo = typeid(Base);
    cout<<baseInfo.name()<<" | "<<baseInfo.raw_name()<<" | "<<baseInfo.hash_code()<<endl;

    //获取一个结构体的类型信息
    const type_info &stuInfo = typeid(struct STU);
    cout<<stuInfo.name()<<" | "<<stuInfo.raw_name()<<" | "<<stuInfo.hash_code()<<endl;

    //获取一个普通类型的类型信息
    const type_info &charInfo = typeid(char);
    cout<<charInfo.name()<<" | "<<charInfo.raw_name()<<" | "<<charInfo.hash_code()<<endl;

    //获取一个表达式的类型信息
    const type_info &expInfo = typeid(20 * 45 / 4.5);
    cout<<expInfo.name()<<" | "<<expInfo.raw_name()<<" | "<<expInfo.hash_code()<<endl;

    return 0;
}
```

运行结果：

```
int | .H | 529034928
double | .N | 667332678
class Base | .?AVBase@@ | 1035034353
class Base | .?AVBase@@ | 1035034353
struct STU | .?AUSTU@@ | 734635517
char | .D | 4140304029
double | .N | 667332678
```

从本例可以看出，`typeid `的使用非常灵活，它的操作数可以是普通变量、对象、内置类型（`int`、`float`等）、自定义类型（结构体和类），还可以是一个表达式。

本例中还用到了` type_info `类的几个成员函数，下面是对它们的介绍：

- `name()` 用来返回类型的名称。
- `raw_name() `用来返回<mark>名字编码</mark>（Name Mangling）算法产生的新名称。
- `hash_code()` 用来返回当前类型对应的` hash` 值。hash 值是一个可以用来标志当前类型的整数，有点类似学生的学号、公民的身份证号、银行卡号等。不过 hash 值有赖于编译器的实现，在不同的编译器下可能会有不同的整数，但它们都能唯一地标识某个类型。


遗憾的是，C++ 标准只对` type_info` 类做了很有限的规定，不仅成员函数少，功能弱，而且各个平台的实现不一致。例如上面代码中的 `name()` 函数，`nInfo.name()`、`objInfo.name()`在 VC/VS 下的输出结果分别是`int`和`class Base`，而在 GCC下的输出结果分别是`i`和`4Base`。

C++ 标准规定，`type_info `类至少要有如下所示的 4 个 `public` 属性的成员函数，其他的扩展函数编译器开发者可以自由发挥，不做限制。

### `const char* name() const;`

返回一个能表示类型名称的字符串。但是C++标准并没有规定这个字符串是什么形式的，例如对于上面的`objInfo.name()`语句，VC/VS 下返回`class Base`，但 GCC 下返回`4Base`。

### `bool before (const type_info& rhs) const;`

判断一个类型是否位于另一个类型的前面，`rhs` 参数是一个` type_info `对象的引用。但是C++标准并没有规定类型的排列顺序，不同的编译器有不同的排列规则，程序员也可以自定义。要特别注意的是，这个排列顺序和继承顺序没有关系，基类并不一定位于派生类的前面。

### `bool operator== (const type_info& rhs) const;`

重载运算符`==`，判断两个类型是否相同，`rhs` 参数是一个 `type_info `对象的引用。

### `bool operator!= (const type_info& rhs) const;`

重载运算符`!=`，判断两个类型是否不同，`rhs` 参数是一个` type_info` 对象的引用。

`raw_name() `是 VC/VS 独有的一个成员函数，`hash_code() `在 VC/VS 和较新的 GCC 下有效。

可以发现，不像 Java、C# 等动态性较强的语言，C++ 能获取到的类型信息非常有限，也没有统一的标准，如同“鸡肋”一般，大部分情况下我们只是使用重载过的`==`运算符来判断两个类型是否相同。

## 判断类型是否相等

`typeid` 运算符经常被用来判断两个类型是否相等。

### 内置类型的比较

例如有下面的定义：

```cpp
char *str;
int a = 2;
int b = 10;
float f;
```

类型判断结果为：

| 类型比较                        | 结果    | 类型比较                       | 结果    |
| ------------------------------- | ------- | ------------------------------ | ------- |
| `typeid(int) == typeid(int)`    | `true`  | `typeid(int) == typeid(char)`  | `false` |
| `typeid(char*) == typeid(char)` | `false` | `typeid(str) == typeid(char*)` | `true`  |
| `typeid(a) == typeid(int)`      | `true`  | `typeid(b) == typeid(int)`     | `true`  |
| `typeid(a) == typeid(a)`        | `true`  | `typeid(a) == typeid(b)`       | `true`  |
| `typeid(a) == typeid(f)`        | `false` | `typeid(a/b) == typeid(int)`   | `true`  |

`typeid` 返回 `type_info` 对象的引用，而表达式`typeid(a) == typeid(b)`的结果为 `true`，可以说明，一个类型不管使用了多少次，编译器都只为它创建一个对象，所有 `typeid `都返回这个对象的引用。

需要提醒的是，为了减小编译后文件的体积，编译器不会为所有的类型创建 `type_info `对象，只会为使用了 `typeid `运算符的类型创建。不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用 `typeid` 运算符，编译器都会为带虚函数的类创建 `type_info `对象。

### 类的比较

例如有下面的定义：

```cpp
class Base{};
class Derived: public Base{};

Base obj1;
Base *p1;
Derived obj2;
Derived *p2 = new Derived;
p1 = p2;
```

类型判断结果为：

| 类型比较                       | 结果    | 类型比较                         | 结果    |
| ------------------------------ | ------- | -------------------------------- | ------- |
| `typeid(obj1) == typeid(p1)`   | `false` | `typeid(obj1) == typeid(*p1)`    | `true`  |
| `typeid(&obj1) == typeid(p1)`  | `true`  | `typeid(obj1) == typeid(obj2)`   | `false` |
| `typeid(obj1) == typeid(Base)` | `true`  | `typeid(*p1) == typeid(Base)`    | `true`  |
| `typeid(p1) == typeid(Base*)`  | `true`  | `typeid(p1) == typeid(Derived*)` | `false` |


表达式`typeid(*p1) == typeid(Base)`和`typeid(p1) == typeid(Base*)`的结果为` true` 可以说明：即使将派生类指针`p2` 赋值给基类指针` p1`，`p1 `的类型仍然为` Base*`。

## `type_info` 类的声明

最后我们再来看一下 `type_info` 类的声明，以进一步了解它所包含的成员函数以及这些函数的访问权限。`type_info` 类位于`typeinfo`头文件，声明形式类似于：

```cpp
class type_info {
public:
    virtual ~type_info();
    int operator==(const type_info& rhs) const;
    int operator!=(const type_info& rhs) const;
    int before(const type_info& rhs) const;
    const char* name() const;
    const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};
```

它的构造函数是 `private` 属性的，所以不能在代码中直接实例化，只能由编译器在内部实例化（借助友元）。而且还重载了`=`运算符，也是 `private` 属性的，所以也不能赋值。

## RTTI

通过RTTI，能够通过基类的指针或引用来检索其所指对象的实际类型。c++通过下面两个操作符提供RTTI。

1. `typeid`：返回指针或引用所指对象的实际类型。

2. `dynamic_cast`：将基类类型的指针或引用安全的转换为派生类型的指针或引用。

对于带虚函数的类，在运行时执行RTTI操作符，返回动态类型信息；对于其他类型，在编译时执行RTTI，返回静态类型信息。

当具有基类的指针或引用，但需要执行派生类操作时，需要动态的强制类型转换（`dynamic_cast`）。这种机制的使用容易出错，最好以虚函数机制代替之。

### `dynamic_cast` **操作符**

如果`dynamic_cast`转换指针类型失败，则返回0；如果转换引用类型失败，则抛出一个`bad_cast`类型的异常。

可以对值为0的指针使用`dynamic_cast`，结果为0。

`dynamic_cast`会首先验证转换是否有效，只有转换有效，操作符才进行实际的转换。

```cpp
if (Derived *derivedPtr = dynamic_cast<Derived *>(basePtr))
{
    // use the Derived object to which derivedPtr points
}
else
{ // basePtr points at a Base object
    // use the Base object to which basePtr points
}
```

也可以使用`dynamic_cast`将基类引用转换为派生类引用：`dynamic_cast<Type&>(val)`

因为不存在空引用，所以不能像指针一样对转换结果进行判断。不过转换引用类型失败时，会抛出`std::bad_cast`异常。

```cpp
try
{ 
    const Derived &d = dynamic_cast<const Derived&>(b);
}
catch (bad_cast) {
    // handle the fact that the cast failed.
}
```

### RTTI的使用

如果有一个类层次，希望为它实现“==”操作符。假设类层次中只有2个类型，那么需要4个函数：

```cpp
bool operator==(const Base&, const Base&)
bool operator==(const Derived&, const Derived &)
bool operator==(const Derived &, const Base&)
bool operator==(const Base&, const Derived &)
```

如果类层次中有4个类型，就要实现16个操作符函数，这种实现就太麻烦了。下面来看如何使用RTTI解决这个问题。

只定义1个`==`操作符函数，每个类定义一个虚函数`equal`。

```cpp
class Base
{
    friend bool operator==(const Base&, const Base&);
public:
    // interface members for Base
protected:
    virtual bool equal(const Base&) const;
    // data and other implementation members of Base
};

bool Base::equal(const Base &rhs) const
{
    // do whatever is required to compare to Base objects
}

class Derived: public Base
{
    friend bool operator==(const Base&, const Base&);
public:
    // other interface members for Derived
private:
    bool equal(const Base&) const;
    // data and other implementation members of Derived
};

bool Derived::equal(const Base &rhs) const
{
    if (const Derived *dp = dynamic_cast<const Derived *>(&rhs))
    {
        // do work to compare two Derived objects and return result
    }
    else
        return false;
}

bool operator==(const Base &lhs, const Base &rhs)
{
    // returns false if typeids are different otherwise
    // returns lhs.equal(rhs)
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}
```

如果操作数类型不同，操作符就返回假；如果操作数类型相同，就将实际比较操作数的工作委派给适当的虚函数`equal`。

`Derived::equal()`中的`dynamic_cast`强制转换是必要的。因为要比较派生类的成员，必须将操作数`Base &`转换为`Derived`类型。

