---
layout: post
title:  "docker 入门"
date:   2021-04-25 00:00:00 +0800
categories: toturial
tags: docker
comments: 1
copyrights: 原创
---

Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。

# 准备工作

## 虚拟化

进入任务管理器->性能->CPU，查看CPU是否启动了虚拟化。若没有，重新开机，进入 BIOS 界面，设置 virtulization。

## Hyper-V

家庭版的 Windows 是没有 Hyper-V 的，因此需要手动安装。[^1]

新建文件 `Hyper-V.cmd`，编辑内容为

```cmd
pushd "%~dp0"
dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum >hyper-v.txt
for /f %%i in ('findstr /i . hyper-v.txt 2^>nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"
del hyper-v.txt
Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL
```

右键以管理员身份运行，然后重启。

## Docker Hub

前往 [Docker Hub](https://hub.docker.com/) 注册账号。

## Docker 安装

在[官网](https://www.docker.com/get-started)下载 Docker for Windows。安装即可。

安装后重启电脑，docker 会开启自启。如果遇到要求安装 WSL2，请参照 [适用于 Linux 的 Windows 子系统安装指南](https://docs.microsoft.com/zh-cn/windows/wsl/install-win10)安装WSL。

# 入门

## 启动

命令行输入

```bash
$ docker run -d -p 80:80 docker/getting-started
```

即可启动一个 docker image。

在上面的命令中，有如下参数

- `-d` ：后台运行容器
- `-p 80:80` 将本地 80 端口映射到容器 80 端口
- `docker/getting-started`要使用的镜像

当然，上面的命令也可以简写为

```bash
$ docker run -dp 80:80 docker/getting-started
```

然后，你可以在 docker dashboard 上看到如下界面

<img src="https://i.loli.net/2021/04/14/lVkDSm8Q4Oq732L.png" alt="image-20210414080731485" style="zoom: 33%;" />

我们刚刚一直在说**容器**和**镜像**，那他们到底是什么呢？我们可以这么理解：容器就是一个隔离运行的系统，里面的镜像存储着运行所需要的一切文件。

## 创建

我们将会以一个 App 为例子讲解 docker 的使用。假设这个 App 目前只有自己在编写，而现在希望能和一个大型团队一起开发，我们希望利用 docker 实现。

当然，我们为你提供了写好的 App，在这里[下载 App](http://localhost/assets/app.zip)。下载完后解压。

要想运行这个程序，我们需要编写 Dockerfile。新建一个名为`Dockerfile`的文件（*注意：文件不能有后缀名*），修改内容如下

```dockerfile
FROM node:12-alpine
RUN apk add --no-cache python g++ make
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
```

然后使用`cd`切换至 App 文件夹并执行命令

```bash
$ docker build -t getting-started .
```

在 Dockerfile 中，我们使用了 `node:12-alpine`，而我们电脑上并没有这个镜像，因此，在执行上面的命令后，会自动进行下载。

什么的命令中，参数 `-t getting-started`  是给启动的镜像命名为 `getting-started`，最后的 `.` 表示 Dockerfile 在当前文件夹中。

现在我们已经下载好镜像了，我们需要启动一个容器

```bash
$ docker run -dp 3000:3000 getting-started
```

然后访问 [http://localhost:3000/](http://localhost:3000/)可看到如下界面

<img src="https://i.loli.net/2021/04/14/uJ4cYyn8edmgSH7.png" alt="image-20210414082541898" style="zoom:50%;" />

并且可以正常使用。

同时，我们的 docker dashboard 也多了一项

<img src="https://i.loli.net/2021/04/14/MQxbJ68R9357ZDe.png" alt="image-20210414082736935" style="zoom: 33%;" />

## 更新

现在我们有需求，需要更新 App：将`src/static/js/app.js`的第 56 行改为

```js
<p className="text-center">You have no todo items yet! Add one above!</p>
```

然后启动容器

```bash
$ docker build -t getting-started .
$ docker run -dp 3000:3000 getting-started
```

然而，docker 报错了

```
run: The term 'run' is not recognized as the name of a cmdlet, function, script file, or operable program.
Check the spelling of the name, or if a path was included, verify that the path is correct and try again.
```

这是因为，我们刚刚已经在运行 app 的容器了，要想启动新的，就必须把旧的移除。

首先，你需要执行

```bash
$ docker ps
```

获取容器的 ID，由于每个人 ID 都不一样，我们下面用 `<ID>` 代指你的 ID。

执行指令

```bash
$ docker stop <ID>
$ docker rm <ID>
```

或者可以将上面两条指令合为一条

```bash
$ docker rm -f <ID>
```

当然了，最简单的删除方法其实是直接点击 dashboard 上的垃圾桶图标。

现在我们重新启动容器

```bash
$ docker run -dp 3000:3000 getting-started
```

刷新 [http://localhost:3000/](http://localhost:3000/) 就可以看到变化了。

## 分享

打开 docker hub，点击 Repositories->Create Repository，更改 name 为 `getting-started`，然后点击创建。

现在我们将刚刚的镜像 push 上去。假设你的用户名为 `<USR>`，我们先登录

```bash
$ docker login -u <USR>
```

然后给镜像打上标签

```bash
$ docker tag getting-started <USR>/getting-started
```

最后再 push

```bash
$ docker push <USR>/getting-started
```

我们知道，docker 最大的特点就是在哪里都能运行，下面我们来测试一下这一点。

打开 [Play with Docker](http://play-with-docker.com/) 并登录。点击 +ADD NEW INSTANCE，将会看到一个 Terminal

<img src="https://i.loli.net/2021/04/14/ScIL45Ux1bOrwW6.png" alt="image-20210414090329177" style="zoom: 33%;" />

运行我们刚刚的镜像

```bash
$ docker run -dp 3000:3000 <USR>/getting-started
```

然后点击界面上出现的 3000 按钮，就可以看到我们的 App 了。

## 持久化——named volume

在上面的例子中我们看到，每次启动 App 时，都会从0开始启动，为什么会这样呢？

我们启动一个 Ubuntu 镜像，它可以创建 `data,txt` 并给一个 1-10000 之间的随机数

```bash
docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null"
```

在上面的命令中，`&&`用来连接两个命令。

进入 dashboard 并点击 cli。我们获取创建的文件

```bash
$ cat /data.txt
```

当然，上面两步也可以合为一步

```bash
$ docker exec <ID> cat /data.txt
```

然后我们试着开启另一个 Ubuntu 容器

```bash
$ docker run -it ubuntu ls /
```

可以看到，第一个容器中的 data.txt 是不存在的。

上面演示了不同的容器之间数据是不通的，那么如果我们要互通数据怎么办？这里，我们用到卷（volume） 来实现持久化。我们的 App 利用 `/etc/todos/todo.db` 存储数据，我们试着利用它实现容器间的数据互通。

删除刚刚所有的镜像，创建 docker volume

```bash
$ docker volume create todo-db
$ docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
```

上面的命令中，我们使用 `-v` 来指定卷装载点。

进入网页随意添加几个条目

<img src="https://i.loli.net/2021/04/14/SBetW5ymqNMTUXh.png" alt="image-20210414130656798" style="zoom:67%;" />

然后删除这个镜像，启动新的镜像，可以看到，刚刚添加的条目还在。

深入探究，存储镜像数据的文件到底在哪里呢？我们可以使用如下命令查看

```bash
$ docker volume inspect todo-db
```

## 持久化——bind mounts

上一节我们用 named volume 实现了持久化，它的特点是我们不需要关心数据存储在哪里。但是，如果我们希望指定挂载点，就需要用到绑定挂载（ bind mounts）。通常，我们用它来实时查看代码变化等。

下面，我们启动一个开发模式容器。运行命令

```bash
$ docker run -dp 3000:3000 \
    -w /app -v "$(pwd):/app" \
    node:12-alpine \
    sh -c "yarn install && yarn run dev"
```

如果使用的是 powershell，则运行

```bash
$ docker run -dp 3000:3000 `
    -w /app -v "$(pwd):/app" `
    node:12-alpine `
    sh -c "yarn install && yarn run dev"
```

在上面的命令中

- `-w /app`：设置工作目录
- `-v "$(pwd):/app"`把容器当前目录绑定挂载到`/app`
- `sh -c "yarn install && yarn run dev"` ：加载必须的依赖项

最后一行的安装有点慢，且之间没有任何提示信息。我们可以使用

```bash
$ docker logs -f <container-id>
```

查看日志。查看完成后，使用 <kbd>ctrl</kbd>+<kbd>C</kbd> 终止。

现在，我们修改 `src/static/js/app.js` 第 109 行为

```js
{submitting ? 'Adding...' : 'Add'}
```

然后我们只要刷新网页就能看到变化了。

之后当你关闭容器想要再打开时，只要使用

```bash
$ docker build -t getting-started .
```

## 多容器

现在我们需要把数据库从 sqlite 迁移到 MySQL，这必然需要两个容器：一个是 App，另一个是 MySQL，我们该如何做呢？答案是建立网络（networking）

我们先创建网络

```bash
$ docker network create todo-app
```

然后启动 MySQL（这个过程可能巨慢无比）

```bash
$ docker run -d `
    --network todo-app --network-alias mysql `
    -v todo-mysql-data:/var/lib/mysql `
    -e MYSQL_ROOT_PASSWORD=secret `
    -e MYSQL_DATABASE=todos `
    mysql:5.7
```

然后查看连接

```bash
$ docker exec -it <mysql-ID> mysql -p
```

密码为 `secret`。确认是否有 `todos` 数据库

```mysql
mysql> SHOW DATABASES;
```

可以看到如下输出

```
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| todos              |
+--------------------+
5 rows in set (0.00 sec)
```

现在两个容器都在网络上了，它们要找到对方，就必须知道对方的地址。这里，我们使用 [nicolaka/netshoot](https://github.com/nicolaka/netshoot) 容器

```bash
$ docker run -it --network todo-app nicolaka/netshoot
```

然后查找 IP

```bash
$ dig mysql
```

得到如下结果

```
; <<>> DiG 9.16.11 <<>> mysql
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 51971
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;mysql.                         IN      A

;; ANSWER SECTION:
mysql.                  600     IN      A       172.18.0.2

;; Query time: 10 msec
;; SERVER: 127.0.0.11#53(127.0.0.11)
;; WHEN: *** *** ** **:**:** UTC 2021
;; MSG SIZE  rcvd: 44
```

这说明我们的 mysql 地址为 172.18.0.2。

现在，我们终于可以启动了！

重启 `node:12-alpine`

```bash
$ docker run -dp 3000:3000 `
  -w /app -v "$(pwd):/app" `
  --network todo-app `
  -e MYSQL_HOST=mysql `
  -e MYSQL_USER=root `
  -e MYSQL_PASSWORD=secret `
  -e MYSQL_DB=todos `
  node:12-alpine `
  sh -c "yarn install && yarn run dev"
```

进入数据库查询字段

```mysql
mysql> select * from todo_items;
```

得到结果

```
+--------------------------------------+-------------------------------+-----------+
| id                                   | name                          | completed |
+--------------------------------------+-------------------------------+-----------+
| b905c1b7-4307-4a00-acc8-1379f5de34da | register a docker hub account |         0 |
| 66624fe3-c8f1-46da-a848-65435295625f | Learn docker                  |         0 |
+--------------------------------------+-------------------------------+-----------+
2 rows in set (0.00 sec)
```

## Docker Compose

如果你已经安装了 docker 桌面版，那么你已经拥有了 docker compose，可用下面的命令查看

```bash
$ docker-compose version
```

在 App 文件夹下新建 `docker-compose.yml`。在 [Compose file reference](https://docs.docker.com/compose/compose-file/) 查看版本。编辑文件为

```yaml
version: "3.7"

services:
  app:
    image: node:12-alpine
    command: sh -c "yarn install && yarn run dev"
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment: 
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
```

这与我们启动容器的命令是对应的。

下面我们开始启动这个容器。首先关闭其他所有容器。启动程序栈

```bash
$ docker-compose up -d
```

这里，`-d`指后台运行。可以看到，docker 自动启动了 network 和 volume。

查看日志

```bash
$ docker-compose logs -f
```

这里，`-f`指 follow。当然，也可以使用如

```bash
$ docker-compose logs -f app
```

查看具体的镜像。

此时，我们在网页上已经可以看到我们的程序。

打开 dashboard，可以看到如下界面

<img src="https://i.loli.net/2021/04/15/tbDuqLGwzxs7NXF.png" alt="image-20210415084217647" style="zoom:33%;" />

如果我们需要关闭它，只需要执行命令

```bash
$ docker-compose down
```

# 镜像创建规范

镜像当然可以随意创建，但如果我们按照规范执行，可以保证其健壮性。

## 安全扫描

扫描我们的镜像

```bash
$ docker scan getting-started
```

得到如下结果

```
Testing getting-started...

Organization:      undefined
Package manager:   apk
Project name:      docker-image|getting-started
Docker image:      getting-started
Platform:          linux/amd64

✓ Tested 38 dependencies for known vulnerabilities, no vulnerable paths found.
```

我们可以在 [docker scan documentation](https://docs.docker.com/engine/scan/) 中查看更多用法。

## 镜像分层

使用命令

```bash
$ docker image history getting-started
```

查看镜像历史。注意到有些行被截断了，我们使用下面的命令查看完整历史

```bash
$ docker image history --no-trunc getting-started
```

## Layer Caching

如果我们改变了镜像，那么重启时需要启动新的分层，这是很慢的。因此我们希望复用不变的部分。具体的来讲，就是先复制文件、安装依赖项，再把剩下的所有文件拷贝过来。我们修改 dockerfile

```dockerfile
FROM node:12-alpine
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --production
COPY . .
CMD ["node", "src/index.js"]
```

创建 `.dockerignore` 文件，修改内容为

```dockerfile
node_modules
```

然后我们创建镜像

```bash
$ docker build -t getting-started .
```

看到如下输出

```
[+] Building 29.1s (10/10) FINISHED
 => [internal] load build definition from Dockerfile                                0.0s
 => => transferring dockerfile: 175B                                                0.0s
 => [internal] load .dockerignore                                                   0.0s
 => => transferring context: 52B                                                    0.0s
 => [internal] load metadata for docker.io/library/node:12-alpine                   0.0s
 => CACHED [1/5] FROM docker.io/library/node:12-alpine                              0.0s
 => [internal] load build context                                                   0.4s
 => => transferring context: 8.65kB                                                 0.4s
 => [2/5] WORKDIR /app                                                              0.0s
 => [3/5] COPY package.json yarn.lock ./                                            0.0s
 => [4/5] RUN yarn install --production                                             27.0s
 => [5/5] COPY . .                                                                  0.1s
 => exporting to image                                                              1.5s
 => => exporting layers                                                             1.5s
 => => writing image sha256:271e1a5d91d9396839711adc4bc3c83e850f6da400065d9f8e6461b8058c217e             0.0s
 => => naming to docker.io/library/getting-started
```

修改 `src/static/index.html`，增添如下语句

```html
<title>
    The Awesome Todo App
</title>
```

重启镜像，速度大大提升。

## Multi-Stage Builds

Multi-Stage Builds 有如下两个好处

- 将构建依赖项和运行依赖项隔离
- 减小镜像体积

当创建响应式程序时，我们需要 Node 环境，但运行时却不需要。我们可以编辑 dockerfile

```dockerfile
FROM node:12 AS build
WORKDIR /app
COPY package* yarn.lock ./
RUN yarn install
COPY public ./public
COPY src ./src
RUN yarn run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
```

更为常用的，我们使用 Java 时只在编译时引入 JDK

```dockerfile
FROM maven AS build
WORKDIR /app
COPY . .
RUN mvn package

FROM tomcat
COPY --from=build /app/target/file.war /usr/local/tomcat/webapps 
```

[^1]: [www.win7999.com/news/332510800](http://www.win7999.com/news/332510800.html)

