---
layout: post
title:  "ä» C10K åˆ° C10Mâ€”â€”ä»æºç æ·±å…¥ I/O æ¨¡å‹çš„æ¼”è¿›"
date:   2025-07-12 00:00:00 +0800
categories: ç³»ç»Ÿ
tags: select poll epoll io_uring
summary: "I/O æ¨¡å‹æ˜¯æ“ä½œç³»ç»Ÿå’Œåº”ç”¨ç¨‹åºä¹‹é—´çš„æ¡¥æ¢ï¼Œéšç€ç½‘ç»œå’Œè®¡ç®—éœ€æ±‚çš„å¢é•¿ï¼Œä» C10K åˆ° C10M çš„æ¼”è¿›ï¼ŒI/O æ¨¡å‹ç»å†äº†ä»é˜»å¡åˆ°éé˜»å¡ã€ä»è½®è¯¢åˆ°äº‹ä»¶é©±åŠ¨çš„è½¬å˜ã€‚æœ¬æ–‡å°†å…¨é¢ä»‹ç»è¿™ä¸€æ¼”è¿›è¿‡ç¨‹åŠå…¶èƒŒåçš„æŠ€æœ¯ç»†èŠ‚ã€‚"
comments: true
copyrights: åŸåˆ›
mermaid: true
mathjax: true
---

***å¦‚ä½•è®©ä¸€å°æœåŠ¡å™¨æ¥å—å°½å¯èƒ½å¤šçš„è¿æ¥ï¼Ÿ***

{% cite https://en.wikipedia.org/wiki/C10k_problem title="Wikipedia" favicon="https://en.wikipedia.org/static/favicon/wikipedia.ico" %}
The ***C10k problem*** is the problem of optimizing network sockets to handle a large number of clients at the same time. The name C10k is a numeronym for concurrently handling ten thousand connections. Handling many concurrent connections is a different problem from handling many requests per second: the latter requires high throughput (processing them quickly), while the former does not have to be fast, but requires efficient scheduling of connections.
{% endcite %}

æ—©åœ¨ 1999 å¹´ï¼ŒDan Kegel å°±æå‡ºäº† `C10K` é—®é¢˜[^1]ï¼Œæ—¨åœ¨è§£å†³å¦‚ä½•è®©ä¸€å°æœåŠ¡å™¨åŒæ—¶å¤„ç† $$10,000$$ ä¸ªè¿æ¥çš„é—®é¢˜ï¼›åˆ°äº† 2010 å¹´å‰åï¼Œè¿™ä¸ªé—®é¢˜å˜ä¸ºäº† `C10M`â€”â€”å³å¦‚ä½•ç”¨ 1U æœåŠ¡å™¨å¤„ç† $$10,000,000$$ ä¸ªè¿æ¥ï¼›è€Œå¦‚ä»Šï¼Œéšç€æœåŠ¡å™¨æ€§èƒ½å’Œç½‘ç»œæŠ€æœ¯çš„å‘å±•ï¼Œè¿™ä¸ªæ•°å­—è¿˜åœ¨ä¸æ–­æ”€å‡ã€‚

[^1]: Kegel, Dan. "The C10K Problem." 1999. [Link](https://www.kegel.com/c10k.html)

åœ¨æœ€åŸºæœ¬çš„ socket ç¼–ç¨‹æ¨¡å‹ä¸­ï¼ŒæœåŠ¡å™¨é€šå¸¸é‡‡ç”¨é˜»å¡ I/O æ¨¡å‹ï¼Œå³æ¯ä¸ªè¿æ¥éƒ½å¯¹åº”ä¸€ä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹ã€‚å½“é¢ä¸´æˆåƒä¸Šä¸‡ä¸ªè¿æ¥æ—¶ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸å¼€å¯æˆåƒä¸Šä¸‡ä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹ï¼Œè¿™ä¼šæ¶ˆè€—å¤§é‡çš„ç³»ç»Ÿèµ„æºï¼Œå¹¶å¯¼è‡´é¢‘ç¹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œä¸¥é‡å½±å“æ€§èƒ½ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ“ä½œç³»ç»Ÿæä¾›äº†å¤šç§ I/O æ¨¡å‹ï¼Œä½¿å¾—å•ä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹èƒ½å¤ŸåŒæ—¶å¤„ç†å¤šä¸ªè¿æ¥ï¼Œä»è€Œå¤§å¹…æå‡æœåŠ¡å™¨çš„å¹¶å‘å¤„ç†èƒ½åŠ›ã€‚ä»Šå¤©æˆ‘ä»¬å°±æ¥èŠèŠï¼Œæ˜¯ä»€ä¹ˆæŠ€æœ¯ï¼Œä½¿å¾—è¿™ä¸€åˆ‡æˆä¸ºå¯èƒ½ã€‚

## `select`

### åŸºæœ¬ä½¿ç”¨

`select` æ˜¯ Unix/Linux ç³»ç»Ÿä¸­æœ€ä¼ ç»Ÿçš„ â€‹â€‹I/O å¤šè·¯å¤ç”¨æœºåˆ¶ä¹‹ä¸€ï¼Œå®ƒå…è®¸ç¨‹åºåŒæ—¶ç›‘è§†å¤šä¸ª fdï¼ˆå¦‚ socketã€ç®¡é“ç­‰ï¼‰ï¼Œå¹¶åœ¨å…¶ä¸­ä»»ä½•ä¸€ä¸ª fd å°±ç»ªï¼ˆè¯» / å†™ / å¼‚å¸¸ï¼‰æ—¶é€šçŸ¥åº”ç”¨ç¨‹åºè¿›è¡Œå¤„ç†ã€‚

`select` çš„å‡½æ•°åŸå‹åœ¨ `sys/select.h` ä¸­ï¼š

```c
int select (int nfds,
            fd_set *readfds,
            fd_set *writefds,
            fd_set *exceptfds,
            struct timeval *timeout);
```

å…¶ä¸­ï¼Œ

- `nfds` æ˜¯éœ€è¦ç›‘è§†çš„ fd çš„æ•°é‡ï¼›
- `readfds` æ˜¯ä¸€ä¸ª fd é›†åˆï¼Œç”¨äºç›‘è§†å¯è¯»äº‹ä»¶ï¼›
- `writefds` æ˜¯ä¸€ä¸ª fd é›†åˆï¼Œç”¨äºç›‘è§†å¯å†™äº‹ä»¶ï¼›
- `exceptfds` æ˜¯ä¸€ä¸ª fd é›†åˆï¼Œç”¨äºç›‘è§†å¼‚å¸¸äº‹ä»¶ï¼›
- `timeout` æ˜¯ä¸€ä¸ªæŒ‡å‘ `struct timeval` çš„æŒ‡é’ˆï¼Œç”¨äºè®¾ç½®è¶…æ—¶æ—¶é—´ã€‚è®¾ç½®ä¸º `NULL` è¡¨ç¤ºæ— é™ç­‰å¾…ï¼Œè®¾ç½®ä¸º `{0, 0}` è¡¨ç¤ºç«‹å³è¿”å›ã€‚

`select` å‡½æ•°ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å…¶ä¸­æœ‰è‡³å°‘ä¸€ä¸ª fd å°±ç»ªï¼Œæˆ–è€…é•¿æ—¶é—´æ²¡æœ‰ fd å°±ç»ªè€Œå¯¼è‡´è¶…æ—¶ã€‚å®ƒçš„è¿”å›å€¼ï¼š

- æ­£å¸¸æƒ…å†µä¸‹ï¼Œè¿”å›å°±ç»ªçš„ fd æ•°é‡ï¼›
- å¦‚æœè¶…æ—¶ï¼Œè¿”å› `0`ï¼›
- å¦‚æœå‡ºé”™ï¼Œè¿”å› `-1`ã€‚

> `fd_set` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ç»“æ„ä½“ï¼Œç”¨äºè¡¨ç¤º fd é›†åˆã€‚å®ƒè¢«å®šä¹‰ä¸ºï¼š
>
> ```c
> #define __FD_SETSIZE 1024
> 
> typedef long int __fd_mask;
> #define __NFDBITS (sizeof(__fd_mask) * 8)
> 
> typedef struct {
>     __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
> } fd_set;
> ```
>
> `fd_set` æ˜¯ä¸€ä¸ª bitmapï¼Œæ¯ä¸ª fd å¯¹åº”ä¸€ä¸ªæ¯”ç‰¹ä½ï¼Œæ¯”ç‰¹ä½ä¸º `1` è¡¨ç¤º fd å·²å°±ç»ªã€‚å®ƒæ€»å…±æœ‰ `__FD_SETSIZE` å³ 1024 ä½ï¼Œå› æ­¤ `select` æœ€å¤šåªèƒ½ç›‘è§† 1024 ä¸ª fd ã€‚
>
> `fd_set` ä¸»è¦ä¾é å››ä¸ªå®æ¥æ“ä½œï¼š
>
> - `FD_ZERO(fdsetp)`ï¼šå°† `fdsetp` ä¸­çš„æ‰€æœ‰æ¯”ç‰¹ä½ç½® `0`
> - `FD_SET(fd, fdsetp)`ï¼šå°† `fdsetp` ä¸­å¯¹åº” `fd` çš„æ¯”ç‰¹ä½ç½® `1`
> - `FD_CLR(fd, fdsetp)`ï¼šå°† `fdsetp` ä¸­å¯¹åº” `fd` çš„æ¯”ç‰¹ä½ç½® `0`
> - `FD_ISSET(fd, fdsetp)`ï¼šæ£€æŸ¥ `fdsetp` ä¸­å¯¹åº” `fd` çš„æ¯”ç‰¹ä½æ˜¯å¦ä¸º `1`
>
> è¿™äº›å®çš„å®ç°åœ¨ `select.h` ä¸­ã€‚
>
> <details>
> <summary>ç‚¹å‡»æŸ¥çœ‹æºç </summary>
> <div markdown="1">
>
> ```c
> #define __FDS_BITS(set) ((set)->fds_bits)
>
> #define __FD_ZERO(s)                                                 \
>     do {                                                             \
>         unsigned int __i;                                            \
>         fd_set *__arr = (s);                                         \
>         for (__i = 0; __i < sizeof(fd_set)/sizeof(__fd_mask); ++__i) \
>             __FDS_BITS[__arr](__i) = 0;                              \
>     } while (0)
> #define __FD_SET(d, s)                                               \
>     ((void)(__FDS_BITS[s](__FD_ELT(d)) |= __FD_MASK(d)))
> #define __FD_CLR(d, s)                                               \
>     ((void)(__FDS_BITS[s](__FD_ELT(d)) &= ~__FD_MASK(d)))
> #define __FD_ISSET(d, s)                                             \
>     ((__FDS_BITS[s](__FD_ELT(d))&__FD_MASK(d)) != 0)
>
> #define FD_SET(fd, fdsetp)   __FD_SET (fd, fdsetp)
> #define FD_CLR(fd, fdsetp)   __FD_CLR (fd, fdsetp)
> #define FD_ISSET(fd, fdsetp) __FD_ISSET (fd, fdsetp)
> #define FD_ZERO(fdsetp)      __FD_ZERO (fdsetp)
> ```
>
> </div>
> </details>

åœ¨ä½¿ç”¨ `select` æ—¶ï¼Œéœ€è¦ä¾æ¬¡ï¼š

1. ä½¿ç”¨ `FD_ZERO` æ¸…ç©º `fd_set`
2. ä½¿ç”¨ `FD_SET` å°†éœ€è¦ç›‘è§†çš„ fd æ·»åŠ åˆ° `fd_set` ä¸­
3. è°ƒç”¨ `select` å‡½æ•°è¿›è¡Œç›‘è§†
4. å¯¹è¿”å›çš„ `fd_set` è¿›è¡Œå¤„ç†ï¼Œä½¿ç”¨ `FD_ISSET` æ£€æŸ¥å“ªäº› fd å°±ç»ª

ä¸‹é¢æ˜¯ä¸€ä¸ªå…¸å‹çš„ `select` ä½¿ç”¨ç¤ºä¾‹[^3]ã€‚

[^3]: [select(2) - Linux Manual Page](https://man7.org/linux/man-pages/man2/select.2.html)

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ä»£ç </summary>
<div markdown="1">

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/select.h>
#include <sys/time.h>

int
main(void)
{
    int             retval;
    fd_set          rfds;
    struct timeval  tv;

    // ç›‘æ§ stdin (fd 0) æ˜¯å¦æœ‰è¾“å…¥
    FD_ZERO(&rfds);
    FD_SET(0, &rfds);

    // è¶…æ—¶æ—¶é—´è®¾ç½®ä¸º 5 ç§’
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(1, &rfds, NULL, NULL, &tv);
    // æ­¤æ—¶ï¼Œtv å¯èƒ½å·²ç»è¢«ä¿®æ”¹

    if (retval == -1)
        perror("select()");
    else if (retval)
        printf("Data is available now.\n");
        // FD_ISSET(0, &rfds) ä¸ºçœŸ
    else
        printf("No data within five seconds.\n");

    exit(EXIT_SUCCESS);
}
```

</div>
</details>

### æºç è§£è¯»

`select` å†…éƒ¨æ‰§è¡Œæ—¶ç»è¿‡äº†ä»¥ä¸‹æ­¥éª¤ï¼š

1. å°†ä¼ å…¥çš„ `fd_set` æ‹·è´è‡³å†…æ ¸æ€
2. å†æ–°å»ºä¸‰ä¸ª `fd_set` ä½œä¸ºè¾“å‡ºï¼ˆin / out / exceptï¼‰
3. éå†æ¯ä¸€ä½ï¼Œå¦‚æœè®¾ç½®äº†ç›‘è§†ä¸”æœ‰äº‹ä»¶å‘ç”Ÿï¼Œåˆ™å°†è¾“å‡ºçš„å¯¹åº”ä½è®¾ç½®ä¸º `1`
4. å¦‚æœæ²¡æœ‰äº‹ä»¶å‘ç”Ÿï¼Œåˆ™é˜»å¡ç­‰å¾…
5. å¦‚æœæœ‰äº‹ä»¶å‘ç”Ÿæˆ–è¶…æ—¶ï¼Œåˆ™è¿”å›è¾“å‡º

```mermaid
flowchart LR
  F[å°† fd_set<br>æ‹·è´è‡³<br>å†…æ ¸æ€] --> G[æ–°å»ºä¸‰ä¸ª<br>fd_set<br>ä½œä¸ºè¾“å‡º] --> H[éå†<br>æ¯ä¸€ä½<br>æ£€æŸ¥çŠ¶æ€] --> I{fd è®¾ç½®äº†ç›‘è§†<br>ä¸”æœ‰äº‹ä»¶<br>å‘ç”Ÿ?}
  I -->|æ˜¯| J[å°†è¾“å‡ºçš„<br>å¯¹åº”ä½<br>è®¾ç½®ä¸º 1]
  I -->|å¦| K{æ‰€æœ‰ä½<br>éƒ½æ£€æŸ¥<br>å®Œäº†?}
  
  J --> K
  K -->|å¦| H
  K -->|æ˜¯| N{è¶…æ—¶æˆ–<br>æœ‰äº‹ä»¶<br>å‘ç”Ÿ?}
  N -->|å¦| H
  N -->|æ˜¯| O[è¿”å›<br>è¾“å‡º]
```

ä¸ºäº†åˆç†è°ƒåº¦èµ„æºï¼Œ`select` è¿˜å¼•å…¥äº†è®¸å¤šä¼˜åŒ–æœºåˆ¶ï¼š

- ***æ ˆç©ºé—´ä¼˜å…ˆ***

  å½“ `select` éœ€è¦å¤„ç†çš„ fd æ•°é‡è¾ƒå°‘ï¼ˆå°‘äº 256ï¼‰æ—¶ï¼Œå†…æ ¸ä¼šä¼˜å…ˆä½¿ç”¨æ ˆç©ºé—´æ¥å­˜å‚¨ `fd_set`ï¼Œè¿™æ ·å¯ä»¥å‡å°‘å†…å­˜åˆ†é…çš„å¼€é”€ã€‚è€Œå½“æ•°é‡è¾ƒå¤šæ—¶ï¼Œæ‰ä¼šä½¿ç”¨å †ç©ºé—´åˆ†é…ã€‚

- ***å¿™ç­‰å¾…***

  å¿™ç­‰å¾…ä¸»è¦è¢«ç”¨äºç½‘ç»œé©±åŠ¨ä¸­ã€‚å¯¹äºé«˜é¢‘å°åŒ…ç½‘ç»œåº”ç”¨ï¼Œå¯ä»¥å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œä¸­æ–­å¤„ç†çš„å¼€é”€ï¼Œä»è€Œæé«˜æ€§èƒ½ã€‚

  å¿™ç­‰å¾…çš„è§¦å‘éœ€è¦åŒæ—¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

  - ç½‘ç»œå­ç³»ç»Ÿå¯ç”¨å¿™ç­‰å¾…
  - å½“å‰æ²¡æœ‰æ›´é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡éœ€è¦è°ƒåº¦
  - è‡³å°‘æœ‰ä¸€ä¸ªsocketè®¾ç½®äº† `SO_BUSY_POLL` é€‰é¡¹
  - æ²¡æœ‰æ£€æµ‹åˆ°ä»»ä½•å°±ç»ªäº‹ä»¶

  åœ¨æ¯æ¬¡ä¸»å¾ªç¯æ£€æŸ¥æ—¶ï¼Œä¼šè®¡ç®—å½“å‰æ—¶é—´ä¸ä¸Šæ¬¡å¿™ç­‰å¾…å¼€å§‹çš„æ—¶é—´å·®ï¼Œå¦‚æœè¶…è¿‡äº†å¿™ç­‰å¾…çš„è¶…æ—¶æ—¶é—´ï¼ˆé€šå¸¸è®¾ç½®ä¸º 2 ä¸ª CPU å‘¨æœŸï¼‰ï¼Œåˆ™ä¼šæ‰§è¡Œä¸€æ¬¡æ­£å¸¸çš„æ£€æŸ¥æµç¨‹ã€‚

- ***å»¶è¿Ÿå”¤é†’***

  åœ¨åˆå§‹åŒ–æ—¶ï¼Œ`wait->_qproc` ä¼šæŒ‡å‘ `__pollwait()` å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ç›¸å½“äºä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œå½“æœ‰äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œå†…æ ¸ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥å”¤é†’ç­‰å¾…çš„è¿›ç¨‹ã€‚

  å½“æ–‡ä»¶æè¿°ç¬¦å°±ç»ªæ—¶ï¼Œä¼šå°† `_qproc` ç½®ä¸º `NULL`ï¼Œè¿™æ ·åç»­æ£€æŸ¥æ—¶ï¼Œå¯ä»¥é¿å…é‡å¤å”¤é†’ã€‚

ä»¥ç›®å‰æœ€æ–°çš„ Linux 6.16 ä¸ºä¾‹ï¼Œ`select` çš„å®ç°åœ¨ `fs/select.c` ä¸­[^2]ã€‚

[^2]: [Linux Kernel Source - fs/select.c](https://elixir.bootlin.com/linux/v6.16/source/fs/select.c#L483-L726)

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹æºç è§£æ</summary>
<div markdown="1">

ç³»ç»Ÿè°ƒç”¨çš„å…¥å£ï¼š

```c
SYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,
                fd_set __user *, exp, struct __kernel_old_timeval __user *, tvp)
{
    return kern_select(n, inp, outp, exp, tvp);
}
```

æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼š

```c
static int kern_select(int n, fd_set __user *inp, fd_set __user *outp,
                       fd_set __user *exp, struct __kernel_old_timeval __user *tvp)
{
    struct timespec64 end_time, *to = NULL;
    struct __kernel_old_timeval tv;
    int ret;

    // å¦‚æœè®¾ç½®äº†è¶…æ—¶æ—¶é—´ï¼Œåˆ™æ‹·è´è¿›å†…æ ¸æ€å¹¶è½¬æ¢ä¸º timespec64
    if (tvp) {
        if (copy_from_user(&tv, tvp, sizeof(tv)))
            return -EFAULT;

        to = &end_time;
        if (poll_select_set_timeout(to,
                                    tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),
                                     (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))
            return -EINVAL;
    }

    // å¤„ç†æ ¸å¿ƒé€»è¾‘ï¼ˆè§ä¸‹æ–‡ï¼‰
    ret = core_sys_select(n, inp, outp, exp, to);
    // å¤„ç†ç»“æœ
    return poll_select_finish(&end_time, tvp, PT_TIMEVAL, ret);
}
```

æ ¸å¿ƒå¤„ç†é€»è¾‘ï¼š

```c
int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,
                    fd_set __user *exp, struct timespec64 *end_time)
{
    fd_set_bits fds;
    void *bits;
    int ret, max_fds;
    size_t size, alloc_size;
    struct fdtable *fdt;
    long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];

    ret = -EINVAL;
    if (unlikely(n < 0))
        goto out_nofds;

    rcu_read_lock();
    fdt = files_fdtable(current->files);
    max_fds = fdt->max_fds;
    rcu_read_unlock();
    if (n > max_fds)
        n = max_fds;

    // æ€»å…±éœ€è¦ 6 ä¸ª bitmapï¼Œåˆ†åˆ«å­˜å‚¨ in/out/ex çš„è¾“å…¥å’Œè¾“å‡º
    size = FDS_BYTES(n);
    // å¦‚æœæ•°é‡è¾ƒå°‘ï¼Œåˆ™ä½¿ç”¨æ ˆåˆ†é…
    bits = stack_fds;
    if (size > sizeof(stack_fds) / 6) {
        ret = -ENOMEM;
        if (size > (SIZE_MAX / 6))
            goto out_nofds;
        alloc_size = 6 * size;
        // å¦‚æœæ•°é‡è¾ƒå¤šï¼Œåˆ™ä½¿ç”¨å †åˆ†é…
        bits = kvmalloc(alloc_size, GFP_KERNEL);
        if (!bits)
            goto out_nofds;
    }
    fds.in      = bits;
    fds.out     = bits +   size;
    fds.ex      = bits + 2*size;
    fds.res_in  = bits + 3*size;
    fds.res_out = bits + 4*size;
    fds.res_ex  = bits + 5*size;

    // å°†ç”¨æˆ·æ€çš„ fd_set æ‹·è´è‡³å†…æ ¸æ€
    if ((ret = get_fd_set(n, inp, fds.in)) ||
        (ret = get_fd_set(n, outp, fds.out)) ||
        (ret = get_fd_set(n, exp, fds.ex)))
        goto out;
    // æ¸…ç©ºè¾“å‡º
    zero_fd_set(n, fds.res_in);
    zero_fd_set(n, fds.res_out);
    zero_fd_set(n, fds.res_ex);

    // è°ƒç”¨ do_select è¿›è¡Œå®é™…ç›‘æ§ï¼ˆè§ä¸‹æ–‡ï¼‰
    ret = do_select(n, &fds, end_time);

    if (ret < 0)
        goto out;
    if (!ret) {
        ret = -ERESTARTNOHAND;
        if (signal_pending(current))
            goto out;
        ret = 0;
    }

    // å°†ç»“æœæ‹·è´å›ç”¨æˆ·æ€
    if (set_fd_set(n, inp, fds.res_in) ||
        set_fd_set(n, outp, fds.res_out) ||
        set_fd_set(n, exp, fds.res_ex))
        ret = -EFAULT;

 out:
     if (bits != stack_fds)
         kvfree(bits);
 out_nofds:
       return ret;
}
```

å…³é”®ç›‘æ§é€»è¾‘ï¼š

```c
// å¯è¯»äº‹ä»¶åŒ…æ‹¬ï¼šæ™®é€šæ•°æ®å¯è¯»ã€ä¼˜å…ˆçº§å¸¦æ•°æ®å¯è¯»ã€æ•°æ®å¯è¯»ã€æŒ‚èµ·ã€é”™è¯¯ã€æ— æ•ˆ
#define POLLIN_SET  (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR | \
                     EPOLLNVAL)
// å¯å†™äº‹ä»¶åŒ…æ‹¬ï¼šæ™®é€šæ•°æ®å¯å†™ã€ä¼˜å…ˆçº§å¸¦æ•°æ®å¯å†™ã€æ•°æ®å¯å†™ã€é”™è¯¯ã€æ— æ•ˆ
#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR |           \
                     EPOLLNVAL)
// å¼‚å¸¸äº‹ä»¶åŒ…æ‹¬ï¼šé«˜ä¼˜å…ˆçº§æ•°æ®å¯è¯»ã€æ— æ•ˆ
#define POLLEX_SET  (EPOLLPRI | EPOLLNVAL)

static noinline_for_stack int do_select(int n, fd_set_bits *fds, struct timespec64*end_time)
{
    ktime_t expire, *to = NULL;
    struct poll_wqueues table;
    poll_table*wait;
    int retval, i, timed_out = 0;
    u64 slack = 0;
    __poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;
    unsigned long busy_start = 0;

    // è·å–æœ€å¤§çš„æœ‰æ•ˆ fd
    rcu_read_lock();
    retval = max_select_fd(n, fds);
    rcu_read_unlock();
    if (retval < 0)
        return retval;
    n = retval;

    // åˆå§‹åŒ–ç­‰å¾…é˜Ÿåˆ—
    poll_initwait(&table);
    wait = &table.pt;

    // å¤„ç†å·²ç»è¶…æ—¶çš„æƒ…å†µ
    if (end_time && !end_time->tv_sec && !end_time->tv_nsec) {
        wait->_qproc = NULL;
        timed_out = 1;
    }
    if (end_time && !timed_out)
        slack = select_estimate_accuracy(end_time);
    retval = 0;

    // å¾ªç¯æ£€æŸ¥æ–‡ä»¶æè¿°ç¬¦çŠ¶æ€
    for (;;) {
        unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;
        bool can_busy_loop = false;

        inp = fds->in; outp = fds->out; exp = fds->ex;
        rinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;

        // éå†æ‰€æœ‰æ–‡ä»¶æè¿°ç¬¦
        for (i = 0; i < n; ++rinp, ++routp, ++rexp) {
            unsigned long in, out, ex, all_bits, bit = 1, j;
            unsigned long res_in = 0, res_out = 0, res_ex = 0;
            __poll_t mask;

            // æ¯æ¬¡å¤„ç† BITS_PER_LONG ä½ fd
            in = *inp++; out = *outp++; ex = *exp++;
            all_bits = in | out | ex;
            // å¦‚æœè¿™ä¸€æ®µ fd æ²¡æœ‰è®¾ç½®ä»»ä½•ç›‘æ§ï¼Œåˆ™è·³è¿‡
            if (all_bits == 0) {
                i += BITS_PER_LONG;
                continue;
            }

            // æ£€æŸ¥è¿™ä¸€æ®µ fd çš„æ¯ä¸ª bit ä½
            for (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {
                if (i >= n)
                    break;
                // å¦‚æœè¯¥ bit ä½æ²¡æœ‰è®¾ç½®ç›‘æ§ï¼Œåˆ™è·³è¿‡
                if (!(bit & all_bits))
                    continue;
                // å¦‚æœè¯¥ bit ä½è®¾ç½®äº†ç›‘æ§ï¼Œåˆ™è°ƒç”¨ select_poll_one æ£€æŸ¥çŠ¶æ€ï¼ˆè§ä¸‹æ–‡ï¼‰
                mask = select_poll_one(i, wait, in, out, bit, busy_flag);
                // æ£€æµ‹åˆ°å¯è¯»äº‹ä»¶
                if ((mask & POLLIN_SET) && (in & bit)) {
                    res_in |= bit;
                    retval++;
                    wait->_qproc = NULL;
                }
                // æ£€æµ‹åˆ°å¯å†™äº‹ä»¶
                if ((mask & POLLOUT_SET) && (out & bit)) {
                    res_out |= bit;
                    retval++;
                    wait->_qproc = NULL;
                }
                // æ£€æµ‹åˆ°å¼‚å¸¸äº‹ä»¶
                if ((mask & POLLEX_SET) && (ex & bit)) {
                    res_ex |= bit;
                    retval++;
                    wait->_qproc = NULL;
                }
                if (retval) {
                    // å¦‚æœæ£€æµ‹åˆ°äº‹ä»¶ï¼Œåˆ™ç»“æŸå¿™ç­‰å¾…
                    can_busy_loop = false;
                    busy_flag = 0;
                } else if (busy_flag & mask)
                    can_busy_loop = true;
            }
            // ä¿å­˜ç»“æœ
            if (res_in)
                *rinp = res_in;
            if (res_out)
                *routp = res_out;
            if (res_ex)
                *rexp = res_ex;
            // é‡æ–°è°ƒåº¦
            cond_resched();
        }
        // æ¸…ç©ºç­‰å¾…é˜Ÿåˆ—
        wait->_qproc = NULL;
        // æ£€æŸ¥æ˜¯å¦æœ‰å°±ç»ªçš„æ–‡ä»¶æè¿°ç¬¦æˆ–è¶…æ—¶
        if (retval || timed_out || signal_pending(current))
            break;
        if (table.error) {
            retval = table.error;
            break;
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥å¿™ç­‰å¾…
        if (can_busy_loop && !need_resched()) {
            if (!busy_start) {
                busy_start = busy_loop_current_time();
                continue;
            }
            if (!busy_loop_timeout(busy_start))
                continue;
        }
        busy_flag = 0;

        if (end_time && !to) {
            expire = timespec64_to_ktime(*end_time);
            to = &expire;
        }

        // è¿›å…¥ç­‰å¾…
        if (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,
                       to, slack))
            timed_out = 1;
    }

    poll_freewait(&table);

    return retval;
}
```

å…·ä½“æ£€æŸ¥æŸä¸€ä¸ª fd çš„å®ç°ï¼š

```c
static inline __poll_t select_poll_one(int fd, poll_table *wait, unsigned long in,
                                       unsigned long out, unsigned long bit,
                                       __poll_t ll_flag)
{
    CLASS(fd, f)(fd);

    if (fd_empty(f))
        return EPOLLNVAL;
    
    // å¼‚å¸¸æˆ–è€…ä½å»¶è¿Ÿæ€»æ˜¯ä¼šè¿›è¡Œæ£€æµ‹
    wait->_key = POLLEX_SET | ll_flag;
    // è®¾ç½®å¯è¯»å’Œå¯å†™çš„ç›‘æ§ä½
    if (in & bit)
        wait->_key |= POLLIN_SET;
    if (out & bit)
        wait->_key |= POLLOUT_SET;
    
    // è¯»å– fd çš„çŠ¶æ€
    return vfs_poll(fd_file(f), wait);
}
```

</div>
</details>

æ ¹æ®è¿™æ®µæºç ï¼Œé™¤äº†å‰æ–‡æ‰€è¿°çš„å‡ ä¸ªä¼˜åŒ–ç‚¹ï¼Œè¿˜å¯ä»¥å‘ç°ï¼Œå°½ç®¡åœ¨è¿è¡Œæ—¶åŒºåˆ†äº†è¾“å…¥çš„ `fd_set` å’Œè¾“å‡ºçš„ `fd_set`ï¼Œä½†è¿”å›ç»“æœæ—¶ï¼Œè¾“å‡ºä¼šè¦†ç›–æ‰åŸæ¥çš„è¾“å…¥ã€‚å› æ­¤ï¼Œ***`select` åœ¨æ¯æ¬¡ä½¿ç”¨åï¼Œéƒ½å¿…é¡»é‡æ–°è®¾ç½®æ‰€æœ‰ä¼ å…¥çš„å‚æ•°***ã€‚

### è®¨è®º

ç»¼åˆä»¥ä¸Šè®¨è®ºï¼Œæˆ‘ä»¬å¾—å‡ºç»“è®ºï¼Œ`select` å­˜åœ¨å¦‚ä¸‹é—®é¢˜ï¼š

- æœ€å¤šåªèƒ½ç›‘è§† 1024 ä¸ª fd
- æ¯æ¬¡è°ƒç”¨ `select` éƒ½éœ€è¦å°†ç”¨æˆ·ä¼ å…¥çš„é›†åˆæ‹·è´è¿›å‡ºå†…æ ¸ï¼Œå¼€é”€è¾ƒå¤§
- æ¯æ¬¡è¿”å›ç»“æœåï¼Œéƒ½éœ€è¦é‡æ–°è®¾ç½®å‚æ•°
- è¿è¡Œæ—¶éœ€è¦éå†é›†åˆçš„æ¯ä¸€ä½ï¼Œæ•ˆç‡è¾ƒä½

é‚£ä¹ˆï¼Œæœ‰æ²¡æœ‰æ›´å¥½çš„æ”¹è¿›æ–¹æ¡ˆå‘¢ï¼Ÿ

## `poll`

### åŸºæœ¬ä½¿ç”¨

`poll` æ˜¯å¯¹ `select` çš„æ”¹è¿›ï¼Œå®ƒè§£å†³äº† `select` çš„ä¸€äº›é™åˆ¶ï¼Œæ¯”å¦‚ fd æ•°é‡çš„é™åˆ¶å’Œé›†åˆæ‹·è´çš„é—®é¢˜ã€‚

`poll` çš„å‡½æ•°åŸå‹åœ¨ `poll.h` ä¸­ï¼š

```c
int poll (struct pollfd *fds,
          nfds_t nfds,
          int timeout)
```

ç±»ä¼¼çš„ï¼Œå…¶ä¸­ï¼š

- `fds` æ˜¯ä¸€ä¸ªæŒ‡å‘ `pollfd` ç»“æ„ä½“æ•°ç»„çš„æŒ‡é’ˆï¼Œæ¯ä¸ªç»“æ„ä½“è¡¨ç¤ºä¸€ä¸ª fd åŠå…¶æ„Ÿå…´è¶£çš„äº‹ä»¶

  > `pollfd` ç»“æ„ä½“å®šä¹‰åœ¨ `sys/poll.h` ä¸­ï¼š
  >
  > ```c
  > struct pollfd {
  >     int fd;            // è¦ç›‘è§†çš„æ–‡ä»¶æè¿°ç¬¦
  >     short int events;  // æ„Ÿå…´è¶£çš„äº‹ä»¶ç±»å‹
  >     short int revents; // å°±ç»ªçš„äº‹ä»¶ç±»å‹
  > };
  > ```
  >
  > `events` å’Œ `revents` å­—æ®µå‡ä¸º bitmapï¼Œç”¨äºè¡¨ç¤ºäº‹ä»¶ç±»å‹ã€‚ä¸åŒçš„ç³»ç»Ÿå¯èƒ½æ”¯æŒä¸åŒçš„ç±»å‹ï¼Œä¾‹å¦‚å¯¹äº GNU/Linux ç³»ç»Ÿï¼Œæ”¯æŒçš„äº‹ä»¶ç±»å‹å®šä¹‰åœ¨ `bits/poll.h` ä¸­ï¼š
  >
  > ```c
  > // æ‰€æœ‰ç³»ç»Ÿå…±æœ‰
  > #define POLLIN     0x001  // å¯è¯»äº‹ä»¶
  > #define POLLPRI    0x002  // ç´§æ€¥æ•°æ®äº‹ä»¶
  > #define POLLOUT    0x004  // å¯å†™äº‹ä»¶
  > #define POLLERR    0x008  // é”™è¯¯äº‹ä»¶
  > #define POLLHUP    0x010  // æŒ‚èµ·äº‹ä»¶
  > #define POLLNVAL   0x020  // æ— æ•ˆè¯·æ±‚
  > // GNU ç‰¹æœ‰
  > #define POLLMSG    0x400  // æ¶ˆæ¯äº‹ä»¶
  > #define POLLREMOVE 0x1000 // ç§»é™¤äº‹ä»¶
  > #define POLLRDHUP  0x2000 // è¯»æŒ‚èµ·äº‹ä»¶
  > ```

- `nfds` æ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ï¼›
- `timeout` æ˜¯ç­‰å¾…äº‹ä»¶å‘ç”Ÿçš„æœ€é•¿æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œå¯ä»¥è®¾ç½®ä¸º `-1` è¡¨ç¤ºæ— é™ç­‰å¾…ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªå…¸å‹çš„ `poll` ä½¿ç”¨ç¤ºä¾‹[^4]ã€‚

[^4]: [poll(2) - Linux Manual Page](https://man7.org/linux/man-pages/man2/poll.2.html)

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ä»£ç </summary>
<div markdown="1">

```c
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)

int
main(int argc, char *argv[])
{
    int            ready;
    char           buf[10];
    nfds_t         num_open_fds, nfds;
    ssize_t        s;
    struct pollfd  *pfds;

    if (argc < 2) {
      fprintf(stderr, "Usage: %s file...\n", argv[0]);
      exit(EXIT_FAILURE);
    }

    num_open_fds = nfds = argc - 1;
    pfds = calloc(nfds, sizeof(struct pollfd));
    if (pfds == NULL)
        errExit("malloc");

    /* Open each file on command line, and add it to 'pfds' array. */

    for (nfds_t j = 0; j < nfds; j++) {
        pfds[j].fd = open(argv[j + 1], O_RDONLY);
        if (pfds[j].fd == -1)
            errExit("open");

        printf("Opened \"%s\" on fd %d\n", argv[j + 1], pfds[j].fd);

        pfds[j].events = POLLIN;
    }

    /* Keep calling poll() as long as at least one file descriptor is
      open. */

    while (num_open_fds > 0) {
        printf("About to poll()\n");
        ready = poll(pfds, nfds, -1);
        if (ready == -1)
            errExit("poll");

        printf("Ready: %d\n", ready);

        /* Deal with array returned by poll(). */

        for (nfds_t j = 0; j < nfds; j++) {
            if (pfds[j].revents != 0) {
                printf("  fd=%d; events: %s%s%s\n", pfds[j].fd,
                       (pfds[j].revents & POLLIN)  ? "POLLIN "  : "",
                       (pfds[j].revents & POLLHUP) ? "POLLHUP " : "",
                       (pfds[j].revents & POLLERR) ? "POLLERR " : "");

                if (pfds[j].revents & POLLIN) {
                    s = read(pfds[j].fd, buf, sizeof(buf));
                    if (s == -1)
                        errExit("read");
                    printf("    read %zd bytes: %.*s\n",
                          s, (int) s, buf);
                } else {                /* POLLERR | POLLHUP */
                    printf("    closing fd %d\n", pfds[j].fd);
                    if (close(pfds[j].fd) == -1)
                        errExit("close");
                    num_open_fds--;
                }
            }
        }
    }

    printf("All file descriptors closed; bye\n");
    exit(EXIT_SUCCESS);
}
```

</div>
</details>

### æºç è§£è¯»

`poll` çš„å·¥ä½œåŸç†ä¸ `select` ç±»ä¼¼ï¼Œéƒ½æ˜¯é€šè¿‡é˜»å¡ç­‰å¾… fd çš„çŠ¶æ€å˜åŒ–æ¥å®ç° I/O å¤šè·¯å¤ç”¨ã€‚ä¸åŒä¹‹å¤„åœ¨äºï¼Œ`poll` ä¸å†ä½¿ç”¨ä½å›¾æ¥è¡¨ç¤º fdï¼Œè€Œæ˜¯ä½¿ç”¨æ•°ç»„ï¼Œè¿™æ ·å°±å¯ä»¥æ”¯æŒæ›´å¤šçš„ fdã€‚

æ›´ç¡®åˆ‡åœ°è®²ï¼Œç”¨æˆ·è®¾ç½®çš„ `pollfd` æ•°ç»„è¿›å…¥å†…æ ¸æ€å¤„ç†åä¼šè¢«è½¬æ¢ä¸º `poll_list` èŠ‚ç‚¹ç»„æˆçš„é“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«å¤šä¸ª `pollfd` ç»“æ„ä½“ã€‚fd çš„å¤„ç†ä»¥ `poll_list` èŠ‚ç‚¹ä¸ºå•ä½ï¼Œè¿™æ ·å¯ä»¥å‡å°‘å†…å­˜æ‹·è´çš„å¼€é”€ã€‚

`poll_list` èŠ‚ç‚¹å¦‚ä¸‹æ‰€ç¤ºï¼š

```c
struct poll_list {
    struct poll_list *next;
    unsigned int len;
    struct pollfd entries[] __counted_by(len);
};
```

ä»¥ç›®å‰æœ€æ–°çš„ Linux 6.16 ä¸ºä¾‹ï¼Œ`poll` çš„å®ç°åŒæ ·ä¹Ÿåœ¨ `fs/select.c` ä¸­[^2]ã€‚

[^2]: [Linux Kernel Source - fs/select.c](https://elixir.bootlin.com/linux/v6.16/source/fs/select.c#L483-L726)

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹æºç è§£æ</summary>
<div markdown="1">

ç³»ç»Ÿè°ƒç”¨çš„å…¥å£ï¼š

```c
SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,
                int, timeout_msecs)
{
    struct timespec64 end_time, *to = NULL;
    int ret;

    // è®¾ç½®è¶…æ—¶æ—¶é—´
    if (timeout_msecs >= 0) {
        to = &end_time;
        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,
                                NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));
    }

    // è°ƒç”¨æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼ˆè§ä¸‹æ–‡ï¼‰
    ret = do_sys_poll(ufds, nfds, to);

    // å¦‚æœè¢«ä¿¡å·ä¸­æ–­ï¼Œè®¾ç½®é‡å¯å—
    if (ret == -ERESTARTNOHAND) {
        struct restart_block *restart_block;

        restart_block = &current->restart_block;
        restart_block->poll.ufds = ufds;
        restart_block->poll.nfds = nfds;

        if (timeout_msecs >= 0) {
            restart_block->poll.tv_sec = end_time.tv_sec;
            restart_block->poll.tv_nsec = end_time.tv_nsec;
            restart_block->poll.has_timeout = 1;
        } else
            restart_block->poll.has_timeout = 0;

        ret = set_restart_fn(restart_block, do_restart_poll);
    }
    return ret;
}
```

æ ¸å¿ƒå¤„ç†å‡½æ•°ï¼š

```c
static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,
                       struct timespec64 *end_time)
{
    struct poll_wqueues table;
    int err = -EFAULT, fdcount;
    // ä½¿ç”¨æ ˆç©ºé—´å­˜å‚¨æœ€å¼€å§‹çš„ä¸€æ®µ poll_listï¼Œä»¥å‡å°‘å†…å­˜åˆ†é…
    long stack_pps[POLL_STACK_ALLOC/sizeof(long)];
    struct poll_list *const head = (struct poll_list *)stack_pps;
    struct poll_list *walk = head;
    unsigned int todo = nfds;
    unsigned int len;

    // æ£€æŸ¥æ–‡ä»¶æè¿°ç¬¦æ•°é‡é™åˆ¶
    if (nfds > rlimit(RLIMIT_NOFILE))
        return -EINVAL;

    // æ ¹æ®æ ˆç©ºé—´å¤§å°ï¼Œè®¡ç®—é¦–æ¬¡èƒ½å¤Ÿå¤„ç†çš„ pollfd æœ€å¤§æ•°é‡
    len = min_t(unsigned int, nfds, N_STACK_PPS);
    // å°†ç”¨æˆ·ä¼ å…¥çš„ pollfd æ•°ç»„æ„å»ºä¸º poll_list é“¾è¡¨
    for (;;) {
        walk->next = NULL;
        walk->len = len;
        if (!len)
            break;

        // ä»ç”¨æˆ·æ€æ‹·è´æ•°æ®åˆ°å†…æ ¸æ€
        if (copy_from_user(walk->entries, ufds + nfds-todo,
                           sizeof(struct pollfd) * walk->len))
            goto out_fds;

        if (walk->len >= todo)
            break;
        todo -= walk->len;

        // å¦‚æœæ ˆç©ºé—´ä¸è¶³ï¼Œåˆ™åŠ¨æ€åˆ†é…å†…å­˜
        len = min(todo, POLLFD_PER_PAGE);
        walk = walk->next = kmalloc(struct_size(walk, entries, len),
                                    GFP_KERNEL);
        if (!walk) {
            err = -ENOMEM;
            goto out_fds;
        }
    }

    // åˆå§‹åŒ–ç­‰å¾…é˜Ÿåˆ—
    poll_initwait(&table);
    // æ ¸å¿ƒå¤„ç†é€»è¾‘ï¼ˆè§ä¸‹æ–‡ï¼‰
    fdcount = do_poll(head, &table, end_time);
    poll_freewait(&table);

    if (!user_write_access_begin(ufds, nfds * sizeof(*ufds)))
        goto out_fds;

    for (walk = head; walk; walk = walk->next) {
        struct pollfd *fds = walk->entries;
        unsigned int j;

        // å°†å†…æ ¸æ€çš„ç»“æœæ‹·è´å›ç”¨æˆ·æ€
        for (j = walk->len; j; fds++, ufds++, j--)
            unsafe_put_user(fds->revents, &ufds->revents, Efault);
      }
    user_write_access_end();

    err = fdcount;
out_fds:
    walk = head->next;
    while (walk) {
        struct poll_list *pos = walk;
        walk = walk->next;
        kfree(pos);
    }
    return err;

Efault:
    user_write_access_end();
    err = -EFAULT;
    goto out_fds;
}
```

æ ¸å¿ƒå¤„ç†é€»è¾‘ï¼š

```c
static int do_poll(struct poll_list *list, struct poll_wqueues *wait,
                   struct timespec64 *end_time)
{
    poll_table* pt = &wait->pt;
    ktime_t expire, *to = NULL;
    int timed_out = 0, count = 0;
    u64 slack = 0;
    __poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;
    unsigned long busy_start = 0;

    // å¤„ç†å·²ç»è¶…æ—¶çš„æƒ…å†µ
    if (end_time && !end_time->tv_sec && !end_time->tv_nsec) {
        pt->_qproc = NULL;
        timed_out = 1;
    }

    if (end_time && !timed_out)
        slack = select_estimate_accuracy(end_time);

    // ä¸»å¾ªç¯
    for (;;) {
        struct poll_list *walk;
        bool can_busy_loop = false;

        // éå†æ‰€æœ‰çš„ poll_list èŠ‚ç‚¹
        for (walk = list; walk != NULL; walk = walk->next) {
            struct pollfd * pfd, * pfd_end;

            pfd = walk->entries;
            pfd_end = pfd + walk->len;
            // éå† poll_list èŠ‚ç‚¹ä¸­çš„æ¯ä¸ª pollfd
            for (; pfd != pfd_end; pfd++) {
                __poll_t mask;
                // å…³é”®ç›‘æ§é€»è¾‘ï¼ˆè§ä¸‹æ–‡ï¼‰
                mask = do_pollfd(pfd, pt, &can_busy_loop, busy_flag);
                // å¤„ç†å°±ç»ªçš„äº‹ä»¶
                pfd->revents = mangle_poll(mask);
                if (mask) {
                    count++;
                    pt->_qproc = NULL;
                    busy_flag = 0;
                    can_busy_loop = false;
                }
            }
        }

        pt->_qproc = NULL;
        if (!count) {
            count = wait->error;
            if (signal_pending(current))
                count = -ERESTARTNOHAND;
        }

        // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
        if (count || timed_out)
            break;

        // æ£€æŸ¥æ˜¯å¦éœ€è¦è¿›å…¥å¿™ç­‰å¾…
        if (can_busy_loop && !need_resched()) {
            if (!busy_start) {
                busy_start = busy_loop_current_time();
                continue;
            }
            if (!busy_loop_timeout(busy_start))
                continue;
        }
        busy_flag = 0;

        if (end_time && !to) {
            expire = timespec64_to_ktime(*end_time);
            to = &expire;
        }

        // è¿›å…¥ç­‰å¾…
        if (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))
            timed_out = 1;
    }
    return count;
}
```

å…³é”®ç›‘æ§é€»è¾‘ï¼š

```c
static inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,
                                 bool *can_busy_poll,
                                 __poll_t busy_flag)
{
    int fd = pollfd->fd;
    __poll_t mask, filter;

    if (unlikely(fd < 0))
        return 0;

    CLASS(fd, f)(fd);
    if (fd_empty(f))
        return EPOLLNVAL;

    filter = demangle_poll(pollfd->events) | EPOLLERR | EPOLLHUP;
    pwait->_key = filter | busy_flag;
    mask = vfs_poll(fd_file(f), pwait);
    if (mask & busy_flag)
        *can_busy_poll = true;
    return mask & filter;
}
```

</div>
</details>

### è®¨è®º

å¯ä»¥çœ‹åˆ°ï¼Œ`poll` çš„ä½¿ç”¨æ–¹å¼ä¸ `select` ç±»ä¼¼ï¼Œä½†å®ƒç›¸æ¯”ä¹‹ä¸‹åšäº†å¾ˆå¤šä¼˜åŒ–ï¼š

- fd çš„æ•°é‡ä¸å†æœ‰é™åˆ¶ï¼Œä»…éœ€æ§åˆ¶åœ¨æœ€å¤§å†…å­˜èŒƒå›´å†…ï¼›
- ä¸éœ€è¦æ¯æ¬¡è®¾ç½®é›†åˆï¼›
- æ”¯æŒæ›´å¤šçš„äº‹ä»¶ç±»å‹ã€‚

ç„¶è€Œï¼Œå®ƒä»ç„¶å­˜åœ¨ä¸€äº›ä¸è¶³ä¹‹å¤„ï¼š

- ä»ç„¶éœ€è¦éå†æ•´ä¸ªæ•°ç»„æ¥æ£€æŸ¥å°±ç»ªçš„ fdï¼Œæ•ˆç‡è¾ƒä½ï¼›
- æ°´å¹³è§¦å‘æ¨¡å¼ï¼ˆå³åªè¦ fd å°±ç»ªä½†æ²¡æœ‰å¤„ç†ï¼Œ`poll` å°±ä¼šä¸€ç›´è¿”å›å®ƒï¼‰å¯èƒ½å¯¼è‡´åº”ç”¨ç¨‹åºé¢‘ç¹è¢«å”¤é†’ï¼Œæµªè´¹ CPU èµ„æºã€‚

Linux 2.5.44 å†…æ ¸ä¸­é¦–æ¬¡å¼•å…¥çš„ `epoll`ï¼Œæ”¹è¿›äº†ä¸Šè¿°é—®é¢˜ã€‚

## `epoll`

### åŸºæœ¬ä½¿ç”¨

`epoll` æ˜¯ Linux ç‰¹æœ‰çš„ I/O å¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œå®ƒåœ¨ `sys/epoll.h` ä¸­æ€»å…±æœ‰ 3 ä¸ªç³»ç»Ÿè°ƒç”¨ï¼š

```c
// åˆ›å»º epoll å®ä¾‹
int epoll_create(int size);   // æ—§ç‰ˆæœ¬
int epoll_create1(int flags); // æ–°ç‰ˆæœ¬

// æ§åˆ¶ epoll å®ä¾‹
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

// ç­‰å¾…äº‹ä»¶
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

å…¶ä¸­ï¼Œ

- `epoll_create`
  - `size`ï¼šæŒ‡å®šè¦ç›‘è§†çš„ fd çš„æ•°é‡ï¼Œé€šå¸¸è®¾ç½®ä¸º `1`ã€‚
- `epoll_create1`
  - `flags`ï¼šå½“è®¾ç½®ä¸º `0` æ—¶ï¼Œè¡¨ç°å’Œ `epoll_create` ç›¸åŒï¼›å¦‚æœè®¾ç½®ä¸º `EPOLL_CLOEXEC`ï¼Œåˆ™åœ¨æ‰§è¡Œ `exec` æ—¶è‡ªåŠ¨å…³é—­è¯¥ fd ï¼Œé˜²æ­¢ fd æ³„æ¼ã€‚
- `epoll_ctl`
  - `epfd`ï¼š`epoll` å®ä¾‹çš„ fd ï¼›
  - `op`ï¼šæ“ä½œç±»å‹ï¼ˆADD / DEL / MODï¼‰ï¼›
  - `fd`ï¼šè¦ç›‘è§†çš„ fd ï¼›
  - `event`ï¼šæ„Ÿå…´è¶£çš„äº‹ä»¶ç±»å‹ã€‚
- `epoll_wait`
  - `epfd`ï¼š`epoll` å®ä¾‹çš„ fd ï¼›
  - `events`ï¼šå°±ç»ªäº‹ä»¶çš„æ•°ç»„ï¼›
  - `maxevents`ï¼šæ•°ç»„çš„æœ€å¤§å®¹é‡ï¼›
  - `timeout`ï¼šè¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ã€‚

> **`epoll_create` v.s. `epoll_create1`**
>
> `epoll_create` æ˜¯è¾ƒæ—©çš„ç‰ˆæœ¬ï¼Œå‚æ•° `size` åœ¨ç°ä»£ Linux ç³»ç»Ÿä¸­å·²ç»è¢«å¿½ç•¥ï¼Œå¯ä»¥éšæ„è®¾ç½®ï¼›è€Œ `epoll_create1` æ˜¯è¾ƒæ–°çš„ç‰ˆæœ¬ï¼Œå¢åŠ äº† `flags` å‚æ•°ï¼Œå…è®¸è®¾ç½® fd çš„å…³é—­è¡Œä¸ºï¼Œæ›´åŠ çµæ´»å’Œå®‰å…¨ã€‚

`epoll` çš„å·¥ä½œåŸç†ä¸ `select` å’Œ `poll` ç±»ä¼¼ï¼Œä½†å®ƒä½¿ç”¨äº†äº‹ä»¶é©±åŠ¨çš„æ–¹å¼ï¼Œé¿å…äº†éå†æ‰€æœ‰ fd çš„å¼€é”€ã€‚

`epoll` ä¸ºäº†è§£å†³ `poll` çš„æ°´å¹³è§¦å‘é—®é¢˜ï¼Œæä¾›äº†ä¸¤ç§è§¦å‘æ¨¡å¼ï¼š

- ****æ°´å¹³è§¦å‘ (Level-Triggered)****ï¼šå½“ fd å°±ç»ªæ—¶ï¼Œ`epoll_wait` ä¼šä¸€ç›´è¿”å›å®ƒï¼Œç›´åˆ°åº”ç”¨ç¨‹åºå¤„ç†å®Œæ¯•ã€‚
- ****è¾¹ç¼˜è§¦å‘ (Edge-Triggered)****ï¼šå½“ fd çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œ`epoll_wait` åªä¼šåœ¨çŠ¶æ€å˜åŒ–çš„ç¬é—´è¿”å›ä¸€æ¬¡ï¼Œä¹‹åéœ€è¦å†æ¬¡æ³¨å†Œæ‰èƒ½ç»§ç»­æ¥æ”¶äº‹ä»¶ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªå…¸å‹çš„ `epoll` ä½¿ç”¨ç¤ºä¾‹[^5]ã€‚

[^5]: [epoll(7) - Linux Manual Page](https://man7.org/linux/man-pages/man7/epoll.7.html)

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ä»£ç </summary>
<div markdown="1">

```c
#define MAX_EVENTS 10
struct epoll_event ev, events[MAX_EVENTS];
int listen_sock, conn_sock, nfds, epollfd;

// åˆ›å»º epoll å®ä¾‹
epollfd = epoll_create1(0);
if (epollfd == -1) {
    perror("epoll_create1");
    exit(EXIT_FAILURE);
}

// æ·»åŠ ç›‘å¬ socket
ev.events = EPOLLIN;
ev.data.fd = listen_sock;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {
    perror("epoll_ctl: listen_sock");
    exit(EXIT_FAILURE);
}

for (;;) {
    // ç­‰å¾…äº‹ä»¶å‘ç”Ÿ
    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
    if (nfds == -1) {
        perror("epoll_wait");
        exit(EXIT_FAILURE);
    }

    // å¤„ç†å°±ç»ªçš„äº‹ä»¶
    for (int n = 0; n < nfds; ++n) {
        if (events[n].data.fd == listen_sock) {
            // æ¥å—æ–°è¿æ¥
            conn_sock = accept(listen_sock,
                             (struct sockaddr *) &addr, &addrlen);
            if (conn_sock == -1) {
                perror("accept");
                exit(EXIT_FAILURE);
            }
            setnonblocking(conn_sock);
            // æ·»åŠ æ–°è¿æ¥åˆ° epoll
            ev.events = EPOLLIN | EPOLLET;
            ev.data.fd = conn_sock;
            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                        &ev) == -1) {
                perror("epoll_ctl: conn_sock");
                exit(EXIT_FAILURE);
            }
        } else {
            // å¤„ç†æ•°æ®
            do_use_fd(events[n].data.fd);
        }
    }
}
```

</div>
</details>

### æºç è§£è¯»

`epoll` çš„æ ¸å¿ƒæ•°æ®ç»“æ„æ˜¯ä¸€ä¸ªçº¢é»‘æ ‘ï¼ˆç”¨äºç®¡ç†æ‰€æœ‰ç›‘è§†çš„ fdï¼‰å’Œä¸€ä¸ªå°±ç»ªé˜Ÿåˆ—ï¼ˆç”¨äºå­˜å‚¨å°±ç»ªçš„ fdï¼‰ã€‚

ä¸»è¦æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š

```c
struct eventpoll {
    spinlock_t lock;
    struct mutex mtx;
    wait_queue_head_t wq;       // ç­‰å¾…é˜Ÿåˆ—
    wait_queue_head_t poll_wait; // poll ç­‰å¾…é˜Ÿåˆ—
    struct list_head rdllist;   // å°±ç»ªé˜Ÿåˆ—
    struct rb_root_cached rbr;  // çº¢é»‘æ ‘æ ¹èŠ‚ç‚¹
    struct epitem *ovflist;     // æº¢å‡ºåˆ—è¡¨
    // ...
};

struct epitem {
    union {
        struct rb_node rbn;     // çº¢é»‘æ ‘èŠ‚ç‚¹
        struct rcu_head rcu;
    };
    struct list_head rdllink;   // å°±ç»ªé˜Ÿåˆ—é“¾æ¥
    struct epitem *next;
    struct epoll_filefd ffd;    // æ–‡ä»¶æè¿°ç¬¦ä¿¡æ¯
    struct eventpoll *ep;       // æ‰€å±çš„ eventpoll
    struct epoll_event event;   // ç”¨æˆ·è®¾ç½®çš„äº‹ä»¶
    // ...
};
```

ä»¥ç›®å‰æœ€æ–°çš„ Linux 6.16 ä¸ºä¾‹ï¼Œ`epoll` çš„å®ç°åœ¨ `fs/eventpoll.c` ä¸­[^6]ã€‚

[^6]: [Linux Kernel Source - fs/eventpoll.c](https://elixir.bootlin.com/linux/v6.16/source/fs/eventpoll.c)

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹æºç è§£æ</summary>
<div markdown="1">

åˆ›å»º epoll å®ä¾‹ï¼š

```c
SYSCALL_DEFINE1(epoll_create1, int, flags)
{
    return do_epoll_create(flags);
}

static int do_epoll_create(int flags)
{
    int error, fd;
    struct eventpoll *ep = NULL;
    struct file *file;

    // æ£€æŸ¥ flags å‚æ•°
    if (flags & ~EPOLL_CLOEXEC)
        return -EINVAL;

    // åˆ†é… eventpoll ç»“æ„
    error = ep_alloc(&ep);
    if (error < 0)
        return error;

    // è·å–æœªä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦
    fd = get_unused_fd_flags(O_RDWR | (flags & O_CLOEXEC));
    if (fd < 0) {
        error = fd;
        goto out_free_ep;
    }

    // åˆ›å»ºåŒ¿å inode æ–‡ä»¶
    file = anon_inode_getfile("[eventpoll]", &eventpoll_fops, ep,
                             O_RDWR | (flags & O_CLOEXEC));
    if (IS_ERR(file)) {
        error = PTR_ERR(file);
        goto out_free_fd;
    }
    ep->file = file;
    fd_install(fd, file);
    return fd;

out_free_fd:
    put_unused_fd(fd);
out_free_ep:
    ep_free(ep);
    return error;
}
```

æ§åˆ¶ epoll å®ä¾‹ï¼š

```c
SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
                struct epoll_event __user *, event)
{
    struct epoll_event epds;

    if (ep_op_has_event(op) &&
        copy_from_user(&epds, event, sizeof(struct epoll_event)))
        return -EFAULT;

    return do_epoll_ctl(epfd, op, fd, &epds, false);
}

int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds,
                bool nonblock)
{
    int error;
    struct fd f, tf;
    struct eventpoll *ep;
    struct epitem *epi;
    struct eventpoll *tep = NULL;

    // è·å– epoll æ–‡ä»¶æè¿°ç¬¦
    f = fdget(epfd);
    if (!f.file)
        return -EBADF;

    // è·å–ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦
    tf = fdget(fd);
    if (!tf.file) {
        error = -EBADF;
        goto error_fput;
    }

    // éªŒè¯æ˜¯å¦ä¸º epoll å®ä¾‹
    if (!is_file_epoll(f.file)) {
        error = -EINVAL;
        goto error_tgt_fput;
    }

    ep = f.file->private_data;

    mutex_lock_nested(&ep->mtx, 0);
    // åœ¨çº¢é»‘æ ‘ä¸­æŸ¥æ‰¾å¯¹åº”çš„ epitem
    epi = ep_find(ep, tf.file, fd);

    error = -EINVAL;
    switch (op) {
    case EPOLL_CTL_ADD:
        if (!epi) {
            epds->events |= EPOLLERR | EPOLLHUP;
            error = ep_insert(ep, epds, tf.file, fd, full_check);
        }
        break;
    case EPOLL_CTL_DEL:
        if (epi)
            error = ep_remove(ep, epi);
        break;
    case EPOLL_CTL_MOD:
        if (epi) {
            epds->events |= EPOLLERR | EPOLLHUP;
            error = ep_modify(ep, epi, epds);
        }
        break;
    }
    mutex_unlock(&ep->mtx);

error_tgt_fput:
    fdput(tf);
error_fput:
    fdput(f);
    return error;
}
```

ç­‰å¾…äº‹ä»¶ï¼š

```c
SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,
                int, maxevents, int, timeout)
{
    return do_epoll_wait(epfd, events, maxevents, timeout);
}

static int do_epoll_wait(int epfd, struct epoll_event __user *events,
                        int maxevents, int timeout)
{
    int error;
    struct fd f;
    struct eventpoll *ep;

    // å‚æ•°æ£€æŸ¥
    if (maxevents <= 0 || maxevents > EP_MAX_EVENTS)
        return -EINVAL;

    if (!access_ok(events, maxevents * sizeof(struct epoll_event)))
        return -EFAULT;

    // è·å– epoll æ–‡ä»¶æè¿°ç¬¦
    f = fdget(epfd);
    if (!f.file)
        return -EBADF;

    if (!is_file_epoll(f.file)) {
        error = -EINVAL;
        goto error_fput;
    }

    ep = f.file->private_data;

    // æ ¸å¿ƒç­‰å¾…é€»è¾‘
    error = ep_poll(ep, events, maxevents, timeout);

error_fput:
    fdput(f);
    return error;
}

static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
                  int maxevents, long timeout)
{
    int res = 0, eavail, timed_out = 0;
    u64 slack = 0;
    wait_queue_entry_t wait;
    ktime_t expires, *to = NULL;

    // è®¾ç½®è¶…æ—¶æ—¶é—´
    if (timeout > 0) {
        struct timespec64 end_time = ep_set_mstimeout(timeout);
        slack = select_estimate_accuracy(&end_time);
        to = &expires;
        *to = timespec64_to_ktime(end_time);
    } else if (timeout == 0) {
        timed_out = 1;
        write_lock_irq(&ep->lock);
        eavail = ep_events_available(ep);
        write_unlock_irq(&ep->lock);
        goto send_events;
    }

fetch_events:
    // æ£€æŸ¥æ˜¯å¦æœ‰å°±ç»ªäº‹ä»¶
    if (!ep_events_available(ep))
        ep_busy_loop(ep, timed_out);

    eavail = ep_events_available(ep);
    if (eavail)
        goto send_events;

    // è¿›å…¥ç­‰å¾…
    if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))
        timed_out = 1;

    eavail = ep_events_available(ep);
    if (!eavail)
        goto fetch_events;

send_events:
    // æ‰«æå°±ç»ªé˜Ÿåˆ—å¹¶å‘é€äº‹ä»¶
    res = ep_send_events(ep, events, maxevents);

    return res;
}
```

</div>
</details>

### è®¨è®º

`epoll` ç›¸æ¯” `select` å’Œ `poll` æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

- ***æ—  fd æ•°é‡é™åˆ¶***ï¼šå¯ä»¥ç›‘è§†ä»»æ„æ•°é‡çš„ fdï¼ˆå—ç³»ç»Ÿèµ„æºé™åˆ¶ï¼‰ï¼›
- ***é«˜æ•ˆçš„äº‹ä»¶é€šçŸ¥***ï¼šä½¿ç”¨çº¢é»‘æ ‘ç®¡ç† fdï¼Œä½¿ç”¨å°±ç»ªé˜Ÿåˆ—å­˜å‚¨å°±ç»ªçš„ fdï¼Œæ— éœ€éå†æ‰€æœ‰ fdï¼›
- ***æ”¯æŒè¾¹ç¼˜è§¦å‘***ï¼šé¿å…æ°´å¹³è§¦å‘æ¨¡å¼ä¸‹çš„é¢‘ç¹å”¤é†’ï¼›
- ***å‡å°‘æ•°æ®æ‹·è´***ï¼šä½¿ç”¨å†…å­˜æ˜ å°„ï¼ˆmmapï¼‰å¯ä»¥å‡å°‘ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´çš„æ•°æ®æ‹·è´ã€‚

ç„¶è€Œï¼Œ`epoll` ä»ç„¶å­˜åœ¨ä¸€äº›ä¸è¶³ï¼š

- ***ä»…é€‚ç”¨äº Linux***ï¼šä¸å…·æœ‰è·¨å¹³å°æ€§ï¼›
- ***ä»éœ€ç³»ç»Ÿè°ƒç”¨***ï¼šæ¯æ¬¡æ“ä½œéƒ½éœ€è¦é™·å…¥å†…æ ¸ï¼›
- ***åŒæ­¥ I/O***ï¼šå¿…é¡»ç­‰å¾…äº‹ä»¶å‘ç”Ÿåæ‰èƒ½å¤„ç†ã€‚

ä¸ºäº†è¿›ä¸€æ­¥æå‡æ€§èƒ½ï¼ŒLinux 5.1 å¼•å…¥äº†å…¨æ–°çš„å¼‚æ­¥ I/O æ¡†æ¶â€”â€”`io_uring`ã€‚

## `io_uring`

`io_uring` æ˜¯ Linux åœ¨ 2019 å¹´å¼•å…¥çš„å…¨æ–°å¼‚æ­¥ I/O æ¥å£ï¼Œç”± Jens Axboe è®¾è®¡å¼€å‘[^7]ã€‚å®ƒçš„è®¾è®¡ç›®æ ‡æ˜¯æä¾›ä¸€ä¸ªé«˜æ€§èƒ½ã€ä½å»¶è¿Ÿçš„å¼‚æ­¥ I/O æ¡†æ¶ï¼Œè§£å†³ä¼ ç»Ÿ I/O æ¨¡å‹çš„æ€§èƒ½ç“¶é¢ˆã€‚

[^7]: Axboe, Jens. "Efficient IO with io_uring." 2019. [Link](https://kernel.dk/io_uring.pdf)

`io_uring` çš„æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡***ä¸¤ä¸ªæ— é”ç¯å½¢é˜Ÿåˆ—***ï¼ˆSubmission Queue å’Œ Completion Queueï¼‰åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´ä¼ é€’ I/O è¯·æ±‚å’Œå®Œæˆäº‹ä»¶ï¼Œä»è€Œå¤§å¹…å‡å°‘ç³»ç»Ÿè°ƒç”¨å¼€é”€ã€‚

```mermaid
graph LR
    A[ç”¨æˆ·ç©ºé—´] -->|æäº¤ I/O è¯·æ±‚| B[SQ<br/>Submission Queue]
    B --> C[å†…æ ¸ç©ºé—´<br/>io_uring]
    C -->|å®Œæˆäº‹ä»¶| D[CQ<br/>Completion Queue]
    D --> A
```

ä¸»è¦ç‰¹ç‚¹ï¼š

- ***é›¶æ‹·è´***ï¼šä½¿ç”¨å…±äº«å†…å­˜æ˜ å°„ï¼Œé¿å…æ•°æ®åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´æ‹·è´ï¼›
- ***æ‰¹é‡æ“ä½œ***ï¼šå¯ä»¥ä¸€æ¬¡æ€§æäº¤å¤šä¸ª I/O è¯·æ±‚ï¼Œå‡å°‘ç³»ç»Ÿè°ƒç”¨æ¬¡æ•°ï¼›
- ***çœŸæ­£çš„å¼‚æ­¥***ï¼šæ”¯æŒçœŸæ­£çš„å¼‚æ­¥ I/Oï¼Œæ— éœ€è½®è¯¢æˆ–é˜»å¡ç­‰å¾…ï¼›
- ***é«˜æ€§èƒ½***ï¼šé€šè¿‡æ— é”é˜Ÿåˆ—å’Œè½®è¯¢æ¨¡å¼ï¼Œå®ç°æä½çš„å»¶è¿Ÿã€‚

### åŸºæœ¬ä½¿ç”¨

`io_uring` çš„ä½¿ç”¨éœ€è¦é€šè¿‡ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨ï¼š

```c
// è®¾ç½® io_uring å®ä¾‹
int io_uring_setup(unsigned entries, struct io_uring_params *p);

// æ³¨å†Œæ–‡ä»¶æè¿°ç¬¦æˆ–ç¼“å†²åŒº
int io_uring_register(unsigned int fd, unsigned int opcode,
                     void *arg, unsigned int nr_args);

// æäº¤ I/O è¯·æ±‚å’Œè·å–å®Œæˆäº‹ä»¶
int io_uring_enter(unsigned int fd, unsigned int to_submit,
                  unsigned int min_complete, unsigned int flags,
                  sigset_t *sig);
```

ä¸è¿‡åœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œé€šå¸¸ä¼šä½¿ç”¨ `liburing` åº“æ¥ç®€åŒ–æ“ä½œ[^8]ã€‚

[^8]: [liburing - io_uring library](https://github.com/axboe/liburing)

ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ `liburing` çš„ç®€å•ç¤ºä¾‹ï¼š

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ä»£ç </summary>
<div markdown="1">

```c
#include <liburing.h>
#include <stdio.h>
#include <string.h>

#define QUEUE_DEPTH 1
#define BLOCK_SIZE  4096

int main(int argc, char *argv[]) {
    struct io_uring ring;
    struct io_uring_sqe *sqe;
    struct io_uring_cqe *cqe;
    char buffer[BLOCK_SIZE];
    int fd;

    // åˆå§‹åŒ– io_uring
    if (io_uring_queue_init(QUEUE_DEPTH, &ring, 0) < 0) {
        perror("io_uring_queue_init");
        return 1;
    }

    // æ‰“å¼€æ–‡ä»¶
    fd = open(argv[1], O_RDONLY);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    // è·å–ä¸€ä¸ª SQEï¼ˆæäº¤é˜Ÿåˆ—æ¡ç›®ï¼‰
    sqe = io_uring_get_sqe(&ring);
    if (!sqe) {
        fprintf(stderr, "Could not get SQE.\n");
        return 1;
    }

    // å‡†å¤‡è¯»å–æ“ä½œ
    io_uring_prep_read(sqe, fd, buffer, BLOCK_SIZE, 0);

    // æäº¤è¯·æ±‚
    io_uring_submit(&ring);

    // ç­‰å¾…å®Œæˆ
    io_uring_wait_cqe(&ring, &cqe);

    // æ£€æŸ¥ç»“æœ
    if (cqe->res < 0) {
        fprintf(stderr, "Async read failed: %s\n", strerror(-cqe->res));
        return 1;
    }

    printf("Read %d bytes\n", cqe->res);

    // æ ‡è®°å®Œæˆ
    io_uring_cqe_seen(&ring, cqe);

    // æ¸…ç†
    close(fd);
    io_uring_queue_exit(&ring);

    return 0;
}
```

</div>
</details>

### æºç è§£è¯»

`io_uring` çš„æ ¸å¿ƒæ•°æ®ç»“æ„åŒ…æ‹¬ï¼š

```c
struct io_ring_ctx {
    struct {
        struct io_rings *rings;           // å…±äº«å†…å­˜åŒºåŸŸ
        struct io_ring_sq sq;             // æäº¤é˜Ÿåˆ—
        struct io_ring_cq cq;             // å®Œæˆé˜Ÿåˆ—
    } ____cacheline_aligned_in_smp;
    
    struct io_wq *io_wq;                  // å·¥ä½œé˜Ÿåˆ—
    struct io_sq_data *sq_data;           // SQ çº¿ç¨‹æ•°æ®
    // ...
};

struct io_rings {
    struct io_uring_sq sq;                // SQ ç¯å½¢ç¼“å†²åŒº
    struct io_uring_cq cq;                // CQ ç¯å½¢ç¼“å†²åŒº
};
```

`io_uring` çš„å®ç°åœ¨ `io_uring/` ç›®å½•ä¸‹[^9]ã€‚

[^9]: [Linux Kernel Source - io_uring](https://elixir.bootlin.com/linux/v6.16/source/io_uring)

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹å…³é”®æµç¨‹</summary>
<div markdown="1">

åˆå§‹åŒ–æµç¨‹ï¼š

```c
SYSCALL_DEFINE2(io_uring_setup, u32, entries,
                struct io_uring_params __user *, params)
{
    return io_uring_setup(entries, params);
}

static long io_uring_setup(u32 entries, struct io_uring_params __user *params)
{
    struct io_uring_params p;
    int ret;

    if (copy_from_user(&p, params, sizeof(p)))
        return -EFAULT;

    // åˆ›å»º io_uring å®ä¾‹
    ret = io_uring_create(entries, &p, params);
    if (ret < 0)
        return ret;

    return ret;
}
```

æäº¤å’Œå®Œæˆæµç¨‹ï¼š

```c
SYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,
                u32, min_complete, u32, flags, const void __user *, argp,
                size_t, argsz)
{
    struct io_ring_ctx *ctx;
    struct file *file;
    long ret;

    // è·å– io_uring å®ä¾‹
    file = fget(fd);
    if (unlikely(!file))
        return -EBADF;

    ctx = file->private_data;

    // æäº¤ I/O è¯·æ±‚
    if (to_submit) {
        ret = io_submit_sqes(ctx, to_submit);
        if (ret < 0)
            goto out;
    }

    // ç­‰å¾…å®Œæˆäº‹ä»¶
    if (min_complete) {
        ret = io_cqring_wait(ctx, min_complete, argp, argsz, flags);
    }

out:
    fput(file);
    return ret;
}
```

</div>
</details>

### è®¨è®º

`io_uring` ä»£è¡¨äº† I/O å¤šè·¯å¤ç”¨çš„æœ€æ–°å‘å±•æ–¹å‘ï¼š

- ä¼˜åŠ¿ï¼š

  - ***æé«˜çš„æ€§èƒ½***ï¼šé€šè¿‡å‡å°‘ç³»ç»Ÿè°ƒç”¨å’Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå®ç°äº†æ¯” `epoll` æ›´é«˜çš„ååé‡ï¼›
  - ***çœŸæ­£çš„å¼‚æ­¥***ï¼šæ”¯æŒå®Œå…¨å¼‚æ­¥çš„ I/O æ“ä½œï¼ŒåŒ…æ‹¬æ–‡ä»¶ I/Oã€ç½‘ç»œ I/O ç­‰ï¼›
  - ***çµæ´»æ€§å¼º***ï¼šæ”¯æŒå¤šç§ I/O æ“ä½œç±»å‹ï¼ˆ`read`ã€`write`ã€`accept`ã€`connect`ã€`fsync` ç­‰ï¼‰ï¼›
  - ***å¯æ‰©å±•æ€§å¥½***ï¼šæŒç»­æ·»åŠ æ–°ç‰¹æ€§ï¼Œå¦‚é“¾å¼æ“ä½œã€ç¼“å†²åŒºé€‰æ‹©ç­‰ã€‚

- æŒ‘æˆ˜ï¼š

  - ***å¤æ‚æ€§é«˜***ï¼šAPI ç›¸å¯¹å¤æ‚ï¼Œå­¦ä¹ æ›²çº¿é™¡å³­ï¼›
  - ***å…¼å®¹æ€§***ï¼šä»…åœ¨è¾ƒæ–°çš„ Linux å†…æ ¸ï¼ˆ5.1+ï¼‰ä¸­å¯ç”¨ï¼›
  - ***å®‰å…¨é—®é¢˜***ï¼šæ—©æœŸç‰ˆæœ¬å­˜åœ¨ä¸€äº›å®‰å…¨æ¼æ´ï¼Œéœ€è¦è°¨æ…ä½¿ç”¨ã€‚

## æ€»ç»“

ä» `select` åˆ° `io_uring`ï¼Œæˆ‘ä»¬è§è¯äº† I/O å¤šè·¯å¤ç”¨æŠ€æœ¯çš„æ¼”è¿›ï¼š

```mermaid
timeline
    title I/O å¤šè·¯å¤ç”¨æŠ€æœ¯æ¼”è¿›
    1983 : select
    1997 : poll
    2002 : epoll
    2019 : io_uring
```

| ç‰¹æ€§ | `select` | `poll` | `epoll` | `io_uring` |
|------|--------|------|-------|----------|
| fd æ•°é‡é™åˆ¶ | $$1024$$ | æ— é™åˆ¶ | æ— é™åˆ¶ | æ— é™åˆ¶ |
| æ•°æ®æ‹·è´ | æ¯æ¬¡è°ƒç”¨ | æ¯æ¬¡è°ƒç”¨ | ä»…æ³¨å†Œæ—¶ | é›¶æ‹·è´ |
| éå†å¼€é”€ | $$O(n)$$ | $$O(n)$$ | $$O(1)$$ | $$O(1)$$ |
| è§¦å‘æ¨¡å¼ | æ°´å¹³è§¦å‘ | æ°´å¹³è§¦å‘ | æ°´å¹³/è¾¹ç¼˜ | å¼‚æ­¥ |
| è·¨å¹³å° | ğŸŸ¢ | ğŸŸ¢ | ğŸ”´ | ğŸ”´ |
| ç³»ç»Ÿè°ƒç”¨ | æ¯æ¬¡è½®è¯¢ | æ¯æ¬¡è½®è¯¢ | æ¯æ¬¡è½®è¯¢ | æ‰¹é‡æäº¤ |

é€‰æ‹©åˆé€‚çš„ I/O æ¨¡å‹éœ€è¦æ ¹æ®å…·ä½“åœºæ™¯ï¼š

- ***å…¼å®¹æ€§ä¼˜å…ˆ***ï¼šä½¿ç”¨ `select` æˆ– `poll`
- ***é«˜å¹¶å‘åœºæ™¯***ï¼šä½¿ç”¨ `epoll`
- ***æè‡´æ€§èƒ½***ï¼šä½¿ç”¨ `io_uring`

éšç€ç¡¬ä»¶æ€§èƒ½çš„æå‡å’Œåº”ç”¨éœ€æ±‚çš„å¢é•¿ï¼ŒI/O å¤šè·¯å¤ç”¨æŠ€æœ¯ä»åœ¨ä¸æ–­å‘å±•ã€‚ä» C10K åˆ° C10Mï¼Œå†åˆ°æœªæ¥å¯èƒ½çš„ C100Mï¼Œè¿™åœºæŠ€æœ¯æ¼”è¿›çš„æ•…äº‹è¿˜å°†ç»§ç»­ã€‚
