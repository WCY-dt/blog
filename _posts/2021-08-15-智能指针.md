---
layout: post
title:  "【C++】智能指针"
date:   2021-08-15 00:00:00 +0800
categories: toturial
tags: C++ 智能指针
comments: 1
mathjax: true
copyrights: 原创
---

本文主要介绍C++智能指针。

# 为什么要智能指针

在 C++11 之前，动态分配内存是依靠 `new` 和 `delete` 完成的。这两个运算符有着一定的风险：

- 如果 `new` 完没有 `delete`，则会产生内存泄漏
- 如果 `delete` 了后再次引用这个指针，则会引用非法内存

因此，C++11 使用智能指针，共有三种：

- `shared_ptr` ：允许多个指针指向同一对象
- `unique_ptr` ：独占所指向的对象
- `weak_ptr` ：指向 `shared_ptr` 所管理的对象

智能指针定义在头文件 `<memory>` 中。

# 动态内存与智能指针

## shared_ptr

`shared_ptr` 是一种模板，我们采用类似 STL 模板的方法定义其指向的类型。例如：

```cpp
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
```

未赋值的指针中保存着一个空指针。

与普通指针类似，`shared_ptr` 和 `unique_ptr` 有如下操作

| 操作                                       | 含义                              |
| ------------------------------------------ | --------------------------------- |
| `shared_ptr<T> sp`<br/> `unique_ptr<T> up` | 空智能指针，指向类型为 `T` 的对象 |
| `p`                                        | 返回 `p` 是否为空                 |
| `*p`                                       | 获得 `p` 指向的对象               |
| `p->mem`                                   | `(*p).mem`                        |
| `p.get()`                                  | 返回 `p` 中保存的指针             |
| `swap(p, q)`<br/> `p.swap(q)`              | 交换 `p` 和 `q`                   |

`shared_ptr` 还有一些独占操作

| 操作                   | 含义                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `make_shared<T>(args)` | 返回一个智能指针，指向初始化为 `args`、类型为 `T` 的对象     |
| `shared_ptr<T>p(q)`    | `p` 是 `q` 的拷贝，`q` 的引用计数递增<br/> `q` 中的指针需要可以转换为 `T*` |
| `p = q`                | `p` 原来的引用计数递减，`q` 的引用计数递增<br/>若 `p` 引用计数为 0，则将其释放 |
| `p.unique()`           | 返回 `p.use_count()` 是否为 1                                |
| `p.use_count()`        | 返回与 `p` 共享对象的智能指针数量，速度较慢                  |

出于安全性考虑，我们通常使用 `make_shared` 分配并初始化智能指针。例如：

```cpp
auto p3 = make_shared<int>(42);
auto p4 = make_shared<string>(10, '9');
auto p5 = make_shared<int>();
```

智能指针的安全性通过引用计数予以保证。引用计数记录有多少个智能指针和它指向同样的对象。例如：

```cpp
auto p = make_shared<int>(42);
auto q(p);
```

此时，引用计数为 2，因为 `p` 和 `q` 都指向了同一个对象。

赋值时，原来的引用对象会递减，新的引用对象会递增。当某个引用对象递减到 0 时，会自动释放。例如：

```cpp
auto r = make_shared<int>(42);
r = q;
```

在赋值后，`r` 原来指向的对象引用对象为 0，自动释放，新引用对象 +1。
