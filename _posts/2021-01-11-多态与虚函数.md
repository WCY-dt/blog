---
layout: post
title:  "【C++】多态与虚函数"
date:   2021-01-11 00:00:00 +0800
categories: toturial
tags: C++ 面向对象
comments: 1
mathjax: true
---

本文是C++类和对象系列第三篇：多态与虚函数。

# 多态&虚函数

基类的指针也可以指向派生类对象，请看下面的例子：

```cpp
#include <iostream>
using namespace std;

//基类People
class People{
public:
    People(char *name, int age);
    void display();
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age): m_name(name), m_age(age){}
void People::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是个无业游民。"<<endl;
}

//派生类Teacher
class Teacher: public People{
public:
    Teacher(char *name, int age, int salary);
    void display();
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary){}
void Teacher::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是一名教师，每月有"<<m_salary<<"元的收入。"<<endl;
}

int main(){
    People *p = new People("王志刚", 23);
    p -> display();

    p = new Teacher("赵宏佳", 45, 8200);
    p -> display();

    return 0;
}
```

运行结果：

```
王志刚今年23岁了，是个无业游民。
赵宏佳今年45岁了，是个无业游民。
```

我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯。但是本例的运行结果却告诉我们，当基类指针 `p `指向派生类 `Teacher `的对象时，虽然使用了 `Teacher `的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类（赵宏佳本来是一名老师，输出结果却显示人家是个无业游民），不符合我们的预期。

换句话说，通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。

为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了<mark>虚函数</mark>（Virtual Function）。使用虚函数非常简单，只需要在函数声明前面增加 `virtual `关键字。

更改上面的代码，将 `display() `声明为虚函数：

```cpp
#include <iostream>
using namespace std;

//基类People
class People{
public:
    People(char *name, int age);
    virtual void display();  //声明为虚函数
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age): m_name(name), m_age(age){}
void People::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是个无业游民。"<<endl;
}

//派生类Teacher
class Teacher: public People{
public:
    Teacher(char *name, int age, int salary);
    virtual void display();  //声明为虚函数
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary){}
void Teacher::display(){
    cout<<m_name<<"今年"<<m_age<<"岁了，是一名教师，每月有"<<m_salary<<"元的收入。"<<endl;
}

int main(){
    People *p = new People("王志刚", 23);
    p -> display();

    p = new Teacher("赵宏佳", 45, 8200);
    p -> display();

    return 0;
}
```

运行结果：

```
王志刚今年23岁了，是个无业游民。
赵宏佳今年45岁了，是一名教师，每月有8200元的收入。
```

和前面的例子相比，本例仅仅是在` display()` 函数声明前加了一个`virtual`关键字，将成员函数声明为了虚函数，这样就可以通过` p` 指针调用` Teacher `类的成员函数了，运行结果也证明了这一点（赵宏佳已经是一名老师了，不再是无业游民了）。

有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<mark>多态</mark>（Polymorphism）。

上面的代码中，同样是`p->display();`这条语句，当` p `指向不同的对象时，它执行的操作是不一样的。同一条语句可以执行不同的操作，看起来有不同表现方式，这就是多态。

多态是面向对象编程的主要特征之一，C++中虚函数的唯一用处就是构成多态。

C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。

前面我们说过，通过指针调用普通的成员函数时会根据指针的类型（通过哪个类定义的指针）来判断调用哪个类的成员函数，但是通过本节的分析可以发现，这种说法并不适用于虚函数，虚函数是根据指针的指向来调用的，指针指向哪个类的对象就调用哪个类的虚函数。

## 借助引用也可以实现多态

引用在本质上是通过指针的方式实现的，既然借助指针可以实现多态，那么我们就有理由推断：借助引用也可以实现多态。

修改上例中 `main() `函数内部的代码，用引用取代指针：

```cpp
int main(){
    People p("王志刚", 23);
    Teacher t("赵宏佳", 45, 8200);
   
    People &rp = p;
    People &rt = t;
   
    rp.display();
    rt.display();

    return 0;
}
```

运行结果：

```
王志刚今年23岁了，是个无业游民。
赵宏佳今年45岁了，是一名教师，每月有8200元的收入。
```

由于引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。从运行结果可以看出，当基类的引用指代基类对象时，调用的是基类的成员，而指代派生类对象时，调用的是派生类的成员。

不过引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力，所以以后我们再谈及多态时一般是说指针。本例的主要目的是让读者知道，除了指针，引用也可以实现多态。

## 多态的用途

通过上面的例子读者可能还未发现多态的用途，不过确实也是，多态在小项目中鲜有有用武之地。

接下来的例子中，我们假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。具体的代码如下所示：

```cpp
#include <iostream>
using namespace std;

//军队
class Troops{
public:
    virtual void fight(){ cout<<"Strike back!"<<endl; }
};

//陆军
class Army: public Troops{
public:
    void fight(){ cout<<"--Army is fighting!"<<endl; }
};
//99A主战坦克
class _99A: public Army{
public:
    void fight(){ cout<<"----99A(Tank) is fighting!"<<endl; }
};
//武直10武装直升机
class WZ_10: public Army{
public:
    void fight(){ cout<<"----WZ-10(Helicopter) is fighting!"<<endl; }
};
//长剑10巡航导弹
class CJ_10: public Army{
public:
    void fight(){ cout<<"----CJ-10(Missile) is fighting!"<<endl; }
};

//空军
class AirForce: public Troops{
public:
    void fight(){ cout<<"--AirForce is fighting!"<<endl; }
};
//J-20隐形歼击机
class J_20: public AirForce{
public:
    void fight(){ cout<<"----J-20(Fighter Plane) is fighting!"<<endl; }
};
//CH5无人机
class CH_5: public AirForce{
public:
    void fight(){ cout<<"----CH-5(UAV) is fighting!"<<endl; }
};
//轰6K轰炸机
class H_6K: public AirForce{
public:
    void fight(){ cout<<"----H-6K(Bomber) is fighting!"<<endl; }
};

int main(){
    Troops *p = new Troops;
    p ->fight();
    //陆军
    p = new Army;
    p ->fight();
    p = new _99A;
    p -> fight();
    p = new WZ_10;
    p -> fight();
    p = new CJ_10;
    p -> fight();
    //空军
    p = new AirForce;
    p -> fight();
    p = new J_20;
    p -> fight();
    p = new CH_5;
    p -> fight();
    p = new H_6K;
    p -> fight();

    return 0;
}
```

运行结果：

```
Strike back!
--Army is fighting!
----99A(Tank) is fighting!
----WZ-10(Helicopter) is fighting!
----CJ-10(Missile) is fighting!
--AirForce is fighting!
----J-20(Fighter Plane) is fighting!
----CH-5(UAV) is fighting!
----H-6K(Bomber) is fighting!
```

这个例子中的派生类比较多，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量` p `就可以调用所有派生类的虚函数。

从这个例子中也可以发现，对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。

# 构成多态的条件

[C++](http://c.biancheng.net/cplus/) 虚函数对于多态具有决定性的作用，有虚函数才能构成多态。这节我们来重点说一下虚函数的注意事项。

1. 只需要在虚函数的声明处加上`virtual `关键字，函数定义处可以加也可以不加。

2. 为了方便，你可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽关系的同名函数都将自动成为虚函数。

3. 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。

4. 只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为`virtual void func();`，派生类虚函数的原型为`virtual void func(int);`，那么当基类指针 `p` 指向派生类对象时，语句`p -> func(100);`将会出错，而语句`p -> func();`将调用基类的函数。

5. 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。

6. 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数，这点我们将在下节中讲解。

## 构成多态的条件

站在“学院派”的角度讲，封装、继承和多态是面向对象的三大特征，多态是指通过基类的指针既可以访问基类的成员，也可以访问派生类的成员。

下面是构成多态的条件：

- 必须存在继承关系；
- 继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）。
- 存在基类的指针，通过该指针调用虚函数。

下面的例子对各种混乱情形进行了演示：

```cpp
#include <iostream>
using namespace std;

//基类Base
class Base{
public:
    virtual void func();
    virtual void func(int);
};
void Base::func(){
    cout<<"void Base::func()"<<endl;
}
void Base::func(int n){
    cout<<"void Base::func(int)"<<endl;
}

//派生类Derived
class Derived: public Base{
public:
    void func();
    void func(char *);
};
void Derived::func(){
    cout<<"void Derived::func()"<<endl;
}
void Derived::func(char *str){
    cout<<"void Derived::func(char *)"<<endl;
}

int main(){
    Base *p = new Derived();
    p -> func();  //输出void Derived::func()
    p -> func(10);  //输出void Base::func(int)
    p -> func("http://c.biancheng.net");  //compile error

    return 0;
}
```

在基类 `Base` 中我们将`void func()`声明为虚函数，这样派生类 `Derived` 中的`void func()`就会自动成为虚函数。`p `是基类 `Base `的指针，但是指向了派生类 `Derived` 的对象。

语句`p -> func();`调用的是派生类的虚函数，构成了多态。

语句`p -> func(10);`调用的是基类的虚函数，因为派生类中没有函数覆盖它。

语句`p -> func("http://c.biancheng.net");`出现编译错误，因为通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。

## 什么时候声明虚函数

首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。

# 虚析构函数的必要性

构造函数不能是虚函数，主要有两个原因：

1. 派生类不能继承基类的构造函数，因此把基类的构造函数声明为虚函数没有意义，无法实现多态；

2. C++中的构造函数用来的在创建对象的时候进行初始化工作，在执行构造函数的时候，对象尚未创建完成，虚函数表这个时候还不存在，也没有指向虚函数表的指针，所以此时还无法查询虚函数表。也就不知道调用哪一个构造函数。

析构函数用来在销毁对象的时候进行清理工作，可以声明为虚函数，有时必须声明为虚函数。

```cpp
#include<iostream>
using namespace std;

class Base{
public:
        Base();
        ~Base();
protected:
        char *str;
};
Base::Base(){
        str=new char[100];
        cout<<"Base constractor"<<endl;
}
Base::~Base(){
        delete[] str;
        cout<<"Base deconstractor"<<endl;
}

class Derived:public Base{
public:
        Derived();
        ~Derived();
private:
        char *name;
};
Derived::Derived(){
        name=new char[100];
        cout<<"Dervied constractor"<<endl;
}
Derived::~Derived(){
        delete[] name;
        cout<<"Derived deconstractor"<<endl;
}

int main()
{
        Base *pb = new Derived();
        delete pb;
        cout<<"-----------------------"<<endl;
        Derived *pd = new Derived();
        delete pd;
}
```

执行结果：

```
Base constractor
Dervied constractor
Base deconstractor
-----------------------
Base constractor
Dervied constractor
Derived deconstractor
Base deconstractor
```

从运行结果可以看出，语句`delete pb;`只调用了基类的析构函数，没有调用派生类的析构函数；而语句`delete pd;`同时调用了派生类和基类的析构函数。

在本例中，不调用派生类的析构函数会导致` name `指向的 100 个 `char` 类型的内存空间得不到释放；除非程序运行结束由操作系统回收，否则就再也没有机会释放这些内存。这是典型的内存泄露。

为什么`delete pb`不会调用派生类的析构函数呢？

因为这里的析构函数是非虚函数，通过指针访问非虚函数时候，编译器会根据指针是类型来调用析构函数。也就是说，指针是什么类型，就调用哪个类的析构函数。如这里`pb`是基类指针，就调用基类的析构函数。

为什么`delete pd`会同时调用基类和派生类的析构函数?

`pd` 是派生类的指针，编译器会根据它的类型匹配到派生类的析构函数，在执行派生类的析构函数的过程中，又会调用基类的析构函数。派生类析构函数始终会调用基类的析构函数。

更改上面的代码，把析构函数更改虚函数：

```cpp
#include<iostream>
using namespace std;

class Base{
public:
        Base();
        virtual ~Base();
protected:
        char *str;
};
Base::Base(){
        str=new char[100];
        cout<<"Base constractor"<<endl;
}
Base::~Base(){
        delete[] str;
        cout<<"Base deconstractor"<<endl;
}

class Derived:public Base{
public:
        Derived();
        ~Derived();
private:
        char *name;
};
Derived::Derived(){
        name=new char[100];
        cout<<"Dervied constractor"<<endl;
}
Derived::~Derived(){
        delete[] name;
        cout<<"Derived deconstractor"<<endl;
}

int main()
{
        Base *pb = new Derived();
        delete pb;
        cout<<"-----------------------"<<endl;
        Derived *pd = new Derived();
        delete pd;
}
```

执行结果：

```
Base constractor
Dervied constractor
Derived deconstractor
Base deconstractor
-----------------------
Base constractor
Dervied constractor
Derived deconstractor
Base deconstractor
```

将基类的析构函数声明为虚函数后，派生类也会自动称为虚函数，这个时候，编译器会忽略指针类型，而是根据指针的指向来调用函数，也就是说，指针指向那个对象就调用那个对象的函数。

`pb`、`pd` 都指向了派生类的对象，所以会调用派生类的析构函数，继而再调用基类的析构函数。如此一来也就解决了内存泄露的问题。

 实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。也就是说，大部分情况下都应该将基类的析构函数声明为虚函数。

注意，这里强调的是基类，如果一个类是最终的类，那就没必要再声明为虚函数了。

# 纯虚函数&抽象类

在C++中，可以将虚函数声明为<mark>纯虚函数</mark>，语法格式为：

```cpp
virtual 返回值类型 函数名 (函数参数) = 0;
```

纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上`=0`，表明此函数为纯虚函数。

> 最后的`=0`并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是纯虚函数”。

包含纯虚函数的类称为<mark>抽象类</mark>（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。

抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。

纯虚函数使用举例：

```cpp
#include <iostream>
using namespace std;

//线
class Line{
public:
    Line(float len);
    virtual float area() = 0;
    virtual float volume() = 0;
protected:
    float m_len;
};
Line::Line(float len): m_len(len){ }

//矩形
class Rec: public Line{
public:
    Rec(float len, float width);
    float area();
protected:
    float m_width;
};
Rec::Rec(float len, float width): Line(len), m_width(width){ }
float Rec::area(){ return m_len * m_width; }

//长方体
class Cuboid: public Rec{
public:
    Cuboid(float len, float width, float height);
    float area();
    float volume();
protected:
    float m_height;
};
Cuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height){ }
float Cuboid::area(){ return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); }
float Cuboid::volume(){ return m_len * m_width * m_height; }

//正方体
class Cube: public Cuboid{
public:
    Cube(float len);
    float area();
    float volume();
};
Cube::Cube(float len): Cuboid(len, len, len){ }
float Cube::area(){ return 6 * m_len * m_len; }
float Cube::volume(){ return m_len * m_len * m_len; }

int main(){
    Line *p = new Cuboid(10, 20, 30);
    cout<<"The area of Cuboid is "<<p->area()<<endl;
    cout<<"The volume of Cuboid is "<<p->volume()<<endl;
  
    p = new Cube(15);
    cout<<"The area of Cube is "<<p->area()<<endl;
    cout<<"The volume of Cube is "<<p->volume()<<endl;

    return 0;
}
```

运行结果：

```
The area of Cuboid is 2200
The volume of Cuboid is 6000
The area of Cube is 1350
The volume of Cube is 3375
```

本例中定义了四个类，它们的继承关系为：`Line `--> `Rec `--> `Cuboid `--> `Cube`。

`Line `是一个抽象类，也是最顶层的基类，在 `Line `类中定义了两个纯虚函数 `area() `和` volume()`。

在 `Rec `类中，实现了 `area()` 函数；所谓实现，就是定义了纯虚函数的函数体。但这时 `Rec `仍不能被实例化，因为它没有实现继承来的 `volume()` 函数，`volume() `仍然是纯虚函数，所以 `Rec `也仍然是抽象类。

直到 `Cuboid` 类，才实现了 `volume() `函数，才是一个完整的类，才可以被实例化。

可以发现，`Line` 类表示“线”，没有面积和体积，但它仍然定义了 `area()` 和 `volume()` 两个纯虚函数。这样的用意很明显：`Line `类不需要被实例化，但是它为派生类提供了“约束条件”，派生类必须要实现这两个函数，完成计算面积和体积的功能，否则就不能实例化。

在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。

抽象基类除了约束派生类的功能，还可以实现多态。请注意第 51 行代码，指针` p `的类型是 `Line`，但是它却可以访问派生类中的 `area() `和 `volume() `函数，正是由于在` Line `类中将这两个函数定义为纯虚函数；如果不这样做，51 行后面的代码都是错误的。我想，这或许才是C++提供纯虚函数的主要目的。

## 关于纯虚函数的几点说明

1. 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。

2. 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。如下例所示：

```cpp
//顶层函数不能被声明为纯虚函数
void fun() = 0;   //compile error

class base{
public :
    //普通成员函数不能被声明为纯虚函数
    void display() = 0;  //compile error
};
```

# 虚函数表

“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定。这是如何实现的呢？

请看下面的程序，该程序演示了多态类对象存储空间的大小。

```cpp
#include <iostream>
using namespace std;
class A
{
public:
    int i;
    virtual void func() {}
    virtual void func2() {}
};
class B : public A
{
    int j;
    void func() {}
};
int main()
{
    cout << sizeof(A) << ", " << sizeof(B);  //输出 8,12
    return 0;
}
```

在 32 位编译模式下，程序的运行结果是：

```
8, 12
```

如果将程序中的 `virtual `关键字去掉，输出结果变为：

```
4, 8
```

对比发现，有了虚函数以后，对象所占用的存储空间比没有虚函数时多了 4 个字节。实际上，任何有虚函数的类及其派生类的对象都包含这多出来的 4 个字节，这 4 个字节就是实现多态的关键——它位于对象存储空间的最前端，其中存放的是虚函数表的地址。

每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着该虚函数表的指针（可以认为这是由编译器自动添加到构造函数中的指令完成的）。

虚函数表是编译器生成的，程序运行时被载入内存。一个类的虚函数表中列出了该类的全部虚函数地址。例如，在上面的程序中，类 `A `对象的存储空间以及虚函数表（假定类 `A `还有其他虚函数）如图所示。

<img src="http://c.biancheng.net/uploads/allimg/180831/1-1PS1111S0Q6.jpg" alt="img" style="zoom:67%;" />

类` B` 对象的存储空间以及虚函数表（假定类 `B` 还有其他虚函数）如图所示。

<img src="http://c.biancheng.net/uploads/allimg/180831/1-1PS1111SQ58.jpg" alt="img" style="zoom:67%;" />

多态的函数调用语句被编译成根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的一系列指令。

假设 `pa` 的类型是 `A*`，则 `pa->func() `这条语句的执行过程如下：

1. 取出 `pa `指针所指位置的前 4 个字节，即对象所属的类的虚函数表的地址（在 64 位编译模式下，由于指针占 8 个字节，所以要取出 8 个字节）。如果 `pa `指向的是类` A` 的对象，则这个地址就是类` A` 的虚函数表的地址；如果 `pa` 指向的是类` B` 的对象，则这个地址就是类` B `的虚函数表的地址。

2. 根据虚函数表的地址找到虚函数表，在其中查找要调用的虚函数的地址。不妨认为虚函数表是以函数名作为索引来查找的，虽然还有更高效的查找方法。

   如果 `pa` 指向的是类 `A` 的对象，自然就会在类 `A` 的虚函数表中查出 `A::func` 的地址；如果 `pa` 指向的是类` B` 的对象，就会在类` B `的虚函数表中查出 `B::func `的地址。

   类 `B `没有自己的` func2` 函数，因此在类 B 的虚函数表中保存的是 `A::func2 `的地址，这样，即便` pa` 指向类 `B` 的对象，`pa->func2();`这条语句在执行过程中也能在类 `B` 的虚函数表中找到` A::func2` 的地址。

3. 根据找到的虚函数的地址调用虚函数。

由以上过程可以看出，只要是通过基类指针或基类引用调用虚函数的语句，就一定是多态的，也一定会执行上面的查表过程，哪怕这个虚函数仅在基类中有，在派生类中没有。

多态机制能够提高程序的开发效率，但是也增加了程序运行时的开销。虚函数表、各个对象中包含的 4 个字节的虚函数表的地址都是空间上的额外开销；而查虚函数表的过程则是时间上的额外开销。

在计算机发展的早期，计算机非常昂贵稀有，运行速度慢，计算机的运算时间和内存是宝贵的，因此人们不惜多花人力编写运行速度更快、更节省内存的程序；如今，计算机的运算时间和内存往往没有人的时间宝贵，运算速度也很快，因此，在用户可以接受的前提下，降低程序运行的效率以提升人员的开发效率就是值得的了。“多态”的应用就是典型例子。

