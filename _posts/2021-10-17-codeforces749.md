---
layout: post
title:  "【Codeforces】#749"
date:   2021-10-17 00:00:00 +0800
categories: 算法
tags: codeforces
comments: 1
mathjax: true
copyrights: 原创
---

[Codeforces Round #749](https://codeforces.com/contest/1586)

cf 的这一轮是我有史以来做得最差的一轮……一个寒假没怎么写，已经完全生疏了。

这一轮题量特大，由于是 div 1 和 div 2 混合，难度也不小，不像正常的 div 2 前三题都是送分题。

# A. Windblume Ode

这题给出一个序列，求最大的子序列，使得子序列的和为合数。

首先，我们把所有数相加，若和为合数，则答案就是该序列本身。

如果不是呢？

这里有个很重要的条件是序列至少有三个数。显然，若序列不是合数，那么它的和必然为奇数。我们只需要去掉序列中的一个奇数，便可以使得序列的和为偶数，也就成了合数。

算法时间复杂度 O(n)。

# B. Omkar and Heavenly Tree

本题的关键在于 m<n。这说明了在 m 组关系中，至少有一个点没有出现在 b 的位置。我们把剩余的所有点都和这个点连接上即可。

算法时间复杂度 O(n+m)。

# C. Omkar and Determination

首先本题数据量较大，二维数组会直接爆空间，所以要用一位数组存储每个格子的状态。

这题的难点在于发现：答案为 no 的充要条件为至少存在一个格子，这个格子向上和向左都走不通，且这个格子不在第 l 列。

因为

```
EN
NN
```

的时候会产生

```
.X  &  .X
X.     XX
```

这两种可能。

而剩下的情况，容易证明，都是可以唯一确定的。

算法时间复杂度 O(nm)。

# D. Omkar and the Meaning of Life

首先我们思考如何才能得出至少一个数。

答案很简单，我们可以固定其他的数为 n，然后逐个尝试最后一个数，直到返回的结果不是 0。例如尝试 i 的时候某次返回了 t，那么 p~n~ 就是 n-i+1。这里，我们最多会使用 n 次查询。

现在我们已经有了一个数，如何找出其他数呢？很简单，把其他数固定为 p~n~，然后逐个尝试最后一个数。例如尝试 i 的时候某次返回了 t，那么 p~t~ 就是 i。这里，我们会使用 n-1 次查询。

你会发现，题目给了 2n 次查询机会，我们还多出来了 1 次！不如开头先瞎查一个，万一蒙对了呢？（bushi

# E. Moment of Bloom

显然，如果涉及到同一个点的查询有奇数个，那么这个点所连接的边一定不可能都是偶数权值。

如果上面的条件满足了就够了吗？

答案是肯定的，并且很容易证明。我们可以构造一棵生成树，所有的路径都沿着生成树即可。

这个证明很难想到，但我们要遵循“大胆猜想，不去证明”的理念做题（？）

算法时间复杂度 O(n+q)。

# F. Defender of Childhood Dreams

首先，根据题目的第一句话，我们可以骂出题者一句：原p！

接下来开始做题。直接输出 log~k~n 向上取整即可。什么？你说要证明？这不是一眼看出来的吗？（？？？）

证明依然是通过构造。首先我们把所有的点分成 k 个子部分，编号连续的点要分在同一个子部分。然后跨子部分的边我们染成同一种颜色，比如红色。

接下来，对于每一个子部分，我们再分为 k 个子子部分。在同一个子部分中，跨子子部分的边染成同一种颜色，比如蓝色。

以此类推，我们就可以染完所有的边。

算法时间复杂度 O(1)。



剩下的题 13000 个人做出来的都不足 50 个，咱就先不看了（其实是我答案还没看懂）。

总之，ABC 都是非常容易的，D 也不难想，E 和 F 如果能猜出答案就非常妙了，但构造出证明还是比较困难的。至于 GHI 那不是我应该去做的题目（指不屑一顾）
