---
layout: post
title:  "【C】指针"
date:   2021-02-07 00:00:00 +0800
categories: toturial
tags: C 指针
comments: 1
mathjax: true
copyrights: 转载
---

本文主要介绍C指针操作。

# 什么是指针？

## 给字节编号！

**计算机中所有的数据都必须放在内存中**，不同类型的数据占用的字节数不一样，例如 `int` 占用 4 个字节，`char` 占用 1 个字节。为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号、身份证号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。

下图是 4G 内存中每个字节的编号（以十六进制表示）：

![4G 内存中每个字节的编号](http://c.biancheng.net/uploads/allimg/190114/1I3043925-0.png)

**我们将内存中字节的编号称为<mark>地址（Address）</mark>或<mark>指针（Pointer）</mark>。**地址从` 0 `开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 `0`，最大的地址为 `0XFFFFFFFF`。

下面的代码演示了如何输出一个地址：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{   
    int a = 100;
    char str[20] = "c!biancheng!ok!";  
    printf("%#X, %#X\n", &a, str); 
    return 0;
}
```

<u>运行结果</u>：

```
0X28FF3C, 0X28FF10
```

`%#X`表示以十六进制形式输出，并附带前缀`0X`。`a` 是一个变量，用来存放整数，需要在前面加`&`来获得它的地址；`str` 本身就表示字符串的首地址，不需要加`&`。

> C语言中有一个控制符`%p`，专门用来以十六进制形式输出地址，不过 `%p` 的输出格式并不统一，有的编译器带`0x`前缀，有的不带，所以此处我们并没有采用。

## 万物皆为地址

C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。

> 数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。

CPU 访问内存时需要的是地址，而不是变量名和函数名！**变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。**<mark>编译</mark>和<mark>链接</mark>过程的一项重要任务就是找到这些名称所对应的地址。

如果希望从根本上了解这些内容，最好的办法是系统学习计算机组成原理和编译原理。

需要注意的是，虽然变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符，但在编写代码的过程中，我们认为**变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址**。

# 定义一个指针！

## 指针变量

数据在内存中的地址也称为<mark>指针</mark>，如果用一个变量来存放指针，我们就称它为<mark>指针变量</mark>。**指针变量的值就是某份数据的地址**，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。

现在假设有一个 `char `类型的变量`c`，它存储了字符`K`（ASCII码为十进制数 75），并占用了地址为 `0X11A `的内存（地址通常用十六进制表示）。**另外有一个指针变量 `p`，它的值为 `0X11A`，正好等于变量 `c `的地址，这种情况我们就称 `p `指向了 `c`，或者说 `p `是指向变量 `c `的指针。**

![img](http://c.biancheng.net/uploads/allimg/190114/1IG34354-0.png)

## 定义指针变量

定义指针变量与定义普通变量非常类似，不过要**在变量名前面加星号`*`**，格式为：

```cpp
datatype *name;
```

或者

```cpp
datatype *name = value;
```

`*`表示这是一个指针变量，`datatype`表示该指针变量所指向的数据的类型 。例如：

```cpp
int *p1;
```

`p1` 是一个指向` int` 类型数据的指针变量，至于` p1 `究竟指向哪一份数据，应该由赋予它的值决定。再如：

```cpp
int a = 100;
int *p_a = &a;
```

在定义指针变量 `p_a `的同时对它进行初始化，并将变量` a` 的地址赋予它，此时 `p_a `就指向了 `a`。值得注意的是，**`p_a `需要的一个地址，`a` 前面必须要加取地址符`&`**，否则是不对的。

和普通变量一样，指针变量也可以被多次写入，只要你想，随时都能够改变指针变量的值，请看下面的代码：

```cpp
//定义普通变量
float a = 99.5, b = 10.6;
char c = '@', d = '#';
//定义指针变量
float *p1 = &a;
char *p2 = &c;
//修改指针变量的值
p1 = &b;
p2 = &d;
```

`*`是一个特殊符号，表明一个变量是指针变量，定义 `p1`、`p2 `时必须带`*`。而给` p1`、`p2` 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上`*`，后边可以像使用普通变量一样来使用指针变量。也就是说，**定义指针变量时必须带`*`，给指针变量赋值时不能带`*`**。

假设变量` a`、`b`、`c`、`d` 的地址分别为 `0X1000`、`0X1004`、`0X2000`、`0X2004`，下面的示意图很好地反映了 `p1`、`p2` 指向的变化：

![img](http://c.biancheng.net/uploads/allimg/190114/1IG3J50-1.jpg)

需要强调的是，**`p1`、`p2` 的类型分别是`float*`和`char*`，而不是`float`和`char`**，它们是完全不同的数据类型，读者要引起注意。

指针变量也可以连续定义，例如：

```cpp
int *a, *b, *c;  //a、b、c 的类型都是 int*
```

注意**每个变量前面都要带`*`**。如果写成下面的形式，那么只有 `a` 是指针变量，`b`、`c` 都是类型为 `int` 的普通变量：

```cpp
int *a, b, c;
```

## 用指针变量取得数据

指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：

```cpp
*pointer;
```

这里的`*`称为<mark>指针运算符</mark>，用来取得某个地址上的数据，请看下面的例子：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{   
    int a = 15;   
    int *p = &a;   
    printf("%d, %d\n", a, *p);  //两种方式都可以输出a的值 
    return 0;
}
```

<u>运行结果</u>

```
15, 15
```

假设` a `的地址是` 0X1000`，`p` 指向 `a` 后，`p `本身的值也会变为 `0X1000`，`*p` 表示获取地址 `0X1000` 上的数据，也即变量` a` 的值。**从运行结果看，`*p` 和 `a `是等价的。**

> 上节我们说过，CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过 `*p` 和 `a` 获取到的数据一样，但它们的运行过程稍有不同：`a` 只需要一次运算就能够取得数据，而 `*p` 要经过两次运算，多了一层“间接”。
> 也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。

假设变量 `a`、`p` 的地址分别为 `0X1000`、`0XF0A0`，它们的指向关系如下图所示：

![img](http://c.biancheng.net/uploads/allimg/190114/1IG3MJ-2.jpg)

指针除了可以获取内存上的数据，也可以修改内存上的数据，例如：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{   
    int a = 15, b = 99, c = 222; 
    int *p = &a;  //定义指针变量   
    *p = b;  //通过指针变量修改内存上的数据 
    c = *p;  //通过指针变量获取内存上的数据 
    printf("%d, %d, %d, %d\n", a, b, c, *p); 
    return 0;
}
```
<u>运行结果</u>

```
99, 99, 99, 99
```

`*p` 代表的是 `a `中的数据，它等价于` a`，可以将另外的一份数据赋值给它，也可以将它赋值给另外的一个变量。

`*`在不同的场景下有不同的作用：**`*`可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；使用指针变量时在前面加`*`表示获取指针指向的数据，或者说表示的是指针指向的数据本身。**

也就是说，定义指针变量时的`*`和使用指针变量时的`*`意义完全不同。以下面的语句为例：

```cpp
int *p = &a;
*p = 100;
```

第1行代码中`*`用来指明 `p` 是一个指针变量，第2行代码中`*`用来获取指针指向的数据。

需要注意的是，给指针变量本身赋值时不能加`*`。修改上面的语句：

```cpp
int *p;
p = &a;
*p = 100;
```

Line2中的 `p` 前面就不能加`*`。

指针变量也可以出现在普通变量能出现的任何表达式中，例如：

```cpp
int x, y, *px = &x, *py = &y;
y = *px + 5;  //表示把x的内容加5并赋给y，*px+5相当于(*px)
+5y = ++*px; //px的内容加上1之后赋给y，++*px相当于++(*px)
y = *px++;  //相当于y=*(px++)
py = px;  //把一个指针的值赋给另一个指针
```

为了更好的理解，我们举一个例子：通过指针交换两个变量的值。

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{   
    int a = 100, b = 999, temp;  
    int *pa = &a, *pb = &b;  
    printf("a=%d, b=%d\n", a, b);   
    /*****开始交换*****/ 
    temp = *pa;
    *pa = *pb;
    *pb = temp; 
    /*****结束交换*****/ 
    printf("a=%d, b=%d\n", a, b);   
    return 0;
}
```
<u>运行结果</u>

```
a=100, b=999
a=999, b=100
```

## MYSTERY: `*&`和`&*`

假设有一个 `int` 类型的变量 `a`，`pa` 是指向它的指针，那么`*&a`和`&*pa`分别是什么意思呢？

- `*&a`可以理解为`*(&a)`，`&a`表示取变量 `a` 的地址（等价于 `pa`），`*(&a)`表示取这个地址上的数据（等价于 `*pa`），绕来绕去，又回到了原点，`*&a`仍然等价于 `a`。

- `&*pa`可以理解为`&(*pa)`，`*pa`表示取得 `pa` 指向的数据（等价于 `a`），`&(*pa)`表示数据的地址（等价于` &a`），所以`&*pa`等价于 `pa`。

# 指针也可以运算！

## 怎么算？

指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如**加法、减法、比较**等，请看下面的代码：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{    
    int a = 10, *pa = &a, *paa = &a;  
    double b = 99.9, *pb = &b;    
    char c = '@', *pc = &c;    //最初的值 
    printf("&a=%#X, &b=%#X, &c=%#X\n", &a, &b, &c); 
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc); 
    //加法运算  
    pa++; pb++; pc++;  
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);  
    //减法运算   
    pa -= 2; pb -= 2; pc -= 2;  
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);  
    //比较运算   
    if(pa == paa){     
        printf("%d\n", *paa);  
    }
    else
    {   
        printf("%d\n", *pa);   
    }   
    return 0;
}
```

<u>运行结果</u>

```
&a=0X28FF44, &b=0X28FF30, &c=0X28FF2B
pa=0X28FF44, pb=0X28FF30, pc=0X28FF2B
pa=0X28FF48, pb=0X28FF38, pc=0X28FF2C
pa=0X28FF40, pb=0X28FF28, pc=0X28FF2A
2686784
```

从运算结果可以看出：`pa`、`pb`、`pc` 每次加 1，它们的地址分别增加 4、8、1，**正好是 `int`、`double`、`char` 类型的长度**；减 2 时，地址分别减少 8、16、2，正好是 `int`、`double`、`char` 类型长度的 2 倍。

> 这很奇怪，指针变量加减运算的结果跟数据类型的长度有关，而不是简单地加 1 或减 1，这是为什么呢？
> 以` a `和 `pa `为例，`a `的类型为` int`，占用 4 个字节，`pa` 是指向 `a `的指针，如下图所示：
> ![img](http://c.biancheng.net/uploads/allimg/190114/1J0563E7-0.jpg)
> 刚开始的时候，`pa `指向 `a `的开头，通过 `*pa `读取数据时，从 `pa` 指向的位置向后移动 4 个字节，把这 4 个字节的内容作为要获取的数据，这 4 个字节也正好是变量` a `占用的内存。
> 如果`pa++;`使得地址加 4 的话，正好能够完全跳过整数 a，指向它后面的内存，如下图所示：
> ![img](http://c.biancheng.net/uploads/allimg/190114/1J05622E-2.jpg)
> 我们知道，数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，这样指针的加减运算就具有了现实的意义。

下面的例子是一个反面教材，警告读者不要尝试通过指针获取下一个变量的地址，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{  
    int a = 1, b = 2, c = 3;   
    int *p = &c;   
    int i;   
    for(i=0; i<8; i++)
    {       
        printf("%d, ", *(p+i) );  
    }  
    return 0;
}
```

<u>运行结果</u>

```
3, -858993460, -858993460, 2, -858993460, -858993460, 1, -858993460,
```

可以发现，变量 `a`、`b`、`c` 并不挨着，它们中间还参杂了别的辅助数据。

指针变量除了可以参与加减运算，还可以参与比较运算。当对指针变量进行比较运算时，**比较的是指针变量本身的值，也就是数据的地址**。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。

上面的代码（第一个例子）在比较 `pa` 和 `paa `的值时，`pa` 已经指向了 `a` 的上一份数据，所以它们不相等。而` a `的上一份数据又不知道是什么，所以会导致 `printf() `输出一个没有意义的数，这正好印证了上面的观点，不要对指向普通变量的指针进行加减运算。

> 另外需要说明的是，**不能对指针变量进行乘法、除法、取余等其他运算**，除了会发生语法错误，也没有实际的含义。

# 指针数组

## 指针指向数组？

<mark>数组（Array）</mark>是一系列具有相同类型的数据的集合，每一份数据叫做一个<mark>数组元素（Element）</mark>。**数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。**以`int arr[] = { 99, 15, 100, 888, 252 };`为例，该数组在内存中的分布如下图所示：

![img](http://c.biancheng.net/uploads/allimg/190114/1J35014B-0.jpg)

定义数组时，要给出数组名和数组长度，**数组名可以认为是一个指针，它指向数组的第 0 个元素**。在C语言中，我们将第 0 个元素的地址称为数组的<mark>首地址</mark>。以上面的数组为例，下图是 `arr` 的指向：

![img](http://c.biancheng.net/uploads/allimg/190114/1J3506331-1.jpg)

> 数组名的本意是表示整个数组，也就是表示多份数据的集合，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“*认为*”一词，表示数组名和数组首地址并不总是等价。初学者可以暂时忽略这个细节，把数组名当做指向第 0 个元素的指针使用即可。

下面的例子演示了如何以指针的方式遍历数组元素：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{  
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度 
    int i;  
    for(i=0; i<len; i++)
    {      
        printf("%d  ", *(arr+i) );  //*(arr+i)等价于arr[i] 
    }   
    printf("\n");  
    return 0;
}
```

<u>运行结果</u>

```
99 15 100 888 252
```

第 5 行代码用来求数组的长度，`sizeof(arr)` 会获得整个数组所占用的字节数，`sizeof(int) `会获得一个数组元素所占用的字节数，它们相除的结果就是数组包含的元素个数，也即数组长度。

第 8 行代码中我们使用了`*(arr+i)`这个表达式，`arr` 是数组名，指向数组的第 0 个元素，表示数组首地址， `arr+i `指向数组的第` i` 个元素，`*(arr+i)` 表示取第 `i `个元素的数据，它等价于` arr[i]`。

> `arr` 是`int*`类型的指针，每次加 1 时它自身的值会增加 `sizeof(int)`，加` i `时自身的值会增加` sizeof(int) * i`

我们也可以定义一个指向数组的指针，例如：

```cpp
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

`arr` 本身就是一个指针，可以直接赋值给指针变量 `p`。`arr` 是数组第 0 个元素的地址，所以`int *p = arr;`也可以写作`int *p = &arr[0];`。也就是说，`arr`、`p`、`&arr[0]` 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。

如果一个指针指向了数组，我们就称它为<mark>数组指针（Array Pointer）</mark>。

**数组指针指向的是数组中的一个具体元素，而不是整个数组**，所以数组指针的类型和数组元素的类型有关，上面的例子中，`p `指向的数组元素是 `int` 类型，所以 `p` 的类型必须也是`int *`。

反过来想，`p `并不知道它指向的是一个数组，`p `只知道它指向的是一个整数，究竟如何使用` p` 取决于程序员的编码。

更改上面的代码，使用数组指针来遍历数组元素：

```cpp
#include <stdio.h>
int main()
{   
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);  
    for(i=0; i<len; i++)
    {      
        printf("%d  ", *(p+i) );   
    }   
    printf("\n");  
    return 0;
}
```

> 数组在内存中只是数组元素的简单排列，没有开始和结束标志，在求数组的长度时不能使用`sizeof(p) / sizeof(int)`，因为` p `只是一个指向` int `类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 `sizeof(p)` 求得的是` p `这个指针变量本身所占用的字节数，而不是整个数组占用的字节数。
> 也就是说，根据数组指针不能逆推出整个数组元素的个数，以及数组从哪里开始、到哪里结束等信息。不像字符串，数组本身也没有特定的结束标志，如果不知道数组的长度，那么就无法遍历整个数组。

上节我们讲到，对指针变量进行加法和减法运算时，是根据数据类型的长度来计算的。如果一个指针变量 `p `指向了数组的开头，那么` p+i `就指向数组的第` i `个元素；如果` p` 指向了数组的第 `n `个元素，那么` p+i` 就是指向第` n+i `个元素；而不管` p `指向了数组的第几个元素，`p+1` 总是指向下一个元素，`p-1` 也总是指向上一个元素。

更改上面的代码，让 `p `指向数组中的第二个元素：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{   
    int arr[] = { 99, 15, 100, 888, 252 };   
    int *p = &arr[2];  //也可以写作 int *p = arr + 2;   
    printf("%d, %d, %d, %d, %d\n", *(p-2), *(p-1), *p, *(p+1), *(p+2) );  
    return 0;
}
```

<u>运行结果</u>

```
99, 15, 100, 888, 252
```

引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针。

- 使用下标
  也就是采用 `arr[i] `的形式访问数组元素。如果` p` 是指向数组 `arr` 的指针，那么也可以使用 `p[i]` 来访问数组元素，它等价于` arr[i]`。
- 使用指针
  也就是使用 `*(p+i) `的形式访问数组元素。另外数组名本身也是指针，也可以使用` *(arr+i) `来访问数组元素，它等价于` *(p+i)`。

不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，**数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变**。也就是说，**数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素**。

更改上面的代码，借助自增运算符来遍历数组元素：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{   
    int arr[] = { 99, 15, 100, 888, 252 };  
    int i, *p = arr, len = sizeof(arr) / sizeof(int);  
    for(i=0; i<len; i++)
    {       
        printf("%d  ", *p++ );   
    }   
    printf("\n");  
    return 0;
}
```

<u>运行结果</u>

```
99 15 100 888 252
```

第 8 行代码中，`*p++ `应该理解为 `*(p++)`，每次循环都会改变` p` 的值，以使`p `指向下一个数组元素。该语句不能写为 `*arr++`，因为 `arr` 是常量，而 `arr++` 会改变它的值，这显然是错误的。

## MYSTERY: `*p++`、`*++p`和`(*p)++ `

假设 `p` 是指向数组 `arr` 中第 `n` 个元素的指针，那么 `*p++`、`*++p`、`(*p)++` 分别是什么意思呢？

- `*p++ `等价于 `*(p++)`，表示先取得第` n `个元素的值，再将` p` 指向下一个元素，上面已经进行了详细讲解。

- `*++p` 等价于 `*(++p)`，会先进行` ++p `运算，使得` p `的值增加，指向下一个元素，整体上相当于` *(p+1)`，所以会获得第` n+1 `个数组元素的值。

- `(*p)++ `就非常简单了，会先取得第 `n `个元素的值，再对该元素的值加 1。假设` p` 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。

# 字符串指针

## 和数组指针相似！

C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中这里不妨再来演示一下：

<u>程序</u>

```cpp
#include <stdio.h>
#include <string.h>
int main()
{    
    char str[] = "hi"; 
    int len = strlen(str), i;  
    //直接输出字符串  
    printf("%s\n", str);   
    //每次输出一个字符    
    for(i=0; i<len; i++)
    {     
        printf("%c", str[i]);  
    }  
    printf("\n");  
    return 0;
}
```

<u>运行结果</u>

```
hi
hi
```

**字符数组归根结底还是一个数组**，上节讲到的关于指针和数组的规则同样也适用于字符数组。更改上面的代码，使用指针的方式来输出字符串：

<u>程序</u>

```cpp
#include <stdio.h>
#include <string.h>
int main()
{   
    char str[] = "hi";  
    char *pstr = str;  
    int len = strlen(str), i;    
    //使用*(pstr+i)  
    for(i=0; i<len; i++)
    {       
        printf("%c", *(pstr+i)); 
    }   
    printf("\n");   
    //使用pstr[i]   
    for(i=0; i<len; i++)
    {      
        printf("%c", pstr[i]);  
    }  
    printf("\n"); 
    //使用*(str+i) 
    for(i=0; i<len; i++)
    {     
        printf("%c", *(str+i)); 
    }  
    printf("\n"); 
    return 0;
}
```

<u>运行结果</u>

```
hi
hi
hi
```

除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：

```cpp
char *str = "hi";
```

或者：

```cpp
char *str;str = "hi";
```

字符串中的所有字符在内存中是连续排列的，`str` 指向的是字符串的第 0 个字符；我们通常将第 0  个字符的地址称为<mark>字符串的首地址</mark>。字符串中每个字符的类型都是`char`，所以 str 的类型也必须是`char *`。

下面的例子演示了如何输出这种字符串：

<u>程序</u>

```cpp
#include <stdio.h>
#include <string.h>
int main()
{   
    char *str = "hi";  
    int len = strlen(str), i;   
    //直接输出字符串  
    printf("%s\n", str);   
    //使用*(str+i)  
    for(i=0; i<len; i++)
    {       
        printf("%c", *(str+i)); 
    }   
    printf("\n");  
    //使用str[i]  
    for(i=0; i<len; i++)
    {      
        printf("%c", str[i]);  
    }   
    printf("\n");  
    return 0;
}
```

<u>运行结果</u>

```
hi
hi
hi
```

这一切看起来和字符数组是多么地相似，它们都可以使用`%s`输出整个字符串，都可以使用`*`或`[ ]`获取单个字符，这两种表示字符串的方式是不是就没有区别了呢？

有！它们最根本的区别是在内存中的存储区域不一样，**字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限**。

内存权限的不同导致的一个明显结果就是，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的。

我们将第二种形式的字符串称为<mark>字符串常量</mark>，意思很明显，常量只能读取不能写入。请看下面的演示：

```cpp
#include <stdio.h>
int main()
{    
    char *str = "Hello World!";  
    str = "I love C!";  //正确  
    str[3] = 'P';  //错误   
    return 0;
}
```

这段代码能够正常编译和链接，但在运行时会出现<mark>段错误（Segment Fault）</mark>或者<mark>写入位置错误</mark>。

第4行代码是正确的，可以更改指针变量本身的指向；第5行代码是错误的，不能修改字符串中的字符。

## 字符数组or字符串常量？

在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；**如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量**。

获取用户输入的字符串就是一个典型的写入操作，只能使用字符数组，不能使用字符串常量，请看下面的代码：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{  
    char str[30]; 
    gets(str);    
    printf("%s\n", str);   
    return 0;
}
```

<u>运行结果</u>

```
C C++ Java Python JavaScript
C C++ Java Python JavaScript
```

# 指针与函数交互

## 让指针成为函数参数！

在C语言中，函数的参数不仅可以是整数、小数、字符等具体的数据，还可以是指向它们的指针。**用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。**

**像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，在函数内部通过指针来影响这些数据集合**。

有的时候，对于整数、小数、字符等基本类型数据的操作也必须要借助指针，一个典型的例子就是交换两个变量的值。用指针变量作参数来交换两个变量的值：

<u>程序</u>

```cpp
#include <stdio.h>
void swap(int *p1, int *p2)
{    
    int temp;  //临时变量 
    temp = *p1;   
    *p1 = *p2;   
    *p2 = temp;
}
int main()
{   
    int a = 66, b = 99;  
    swap(&a, &b);  
    printf("a = %d, b = %d\n", a, b);  
    return 0;
}
```

<u>运行结果</u>

```
a = 99, b = 66
```

调用` swap() `函数时，将变量` a`、`b` 的地址分别赋值给` p1`、`p2`，这样 `*p1`、`*p2 `代表的就是变量 `a`、`b `本身，交换` *p1`、`*p2` 的值也就是交换 `a`、`b` 的值。函数运行结束后虽然会将 `p1`、`p2` 销毁，但它对外部 `a`、`b` 造成的影响是“持久化”的，不会随着函数的结束而“恢复原样”。

## 让数组成为函数参数！

数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，如果希望在函数内部操作数组，必须传递数组指针。下面的例子定义了一个函数 `max()`，用来查找数组中值最大的元素：

<u>程序</u>

```cpp
#include <stdio.h>
int max(int *intArr, int len)
{  
    int i, maxValue = intArr[0];  //假设第0个元素是最大值  
    for(i=1; i<len; i++)
    {      
        if(maxValue < intArr[i])
        {           
            maxValue = intArr[i];     
        }   
    }     
    return maxValue;
}
int main()
{  
    int nums[6], i; 
    int len = sizeof(nums)/sizeof(int);   
    //读取用户输入的数据并赋值给数组元素  
    for(i=0; i<len; i++)
    {   
        scanf("%d", nums+i);   
    }  
    printf("Max value is %d!\n", max(nums, len));  
    return 0;
}
```

<u>运行结果</u>

```
12 55 30 8 93 27
Max value is 93!
```

参数 `intArr` 仅仅是一个数组指针，在函数内部无法通过这个指针获得数组长度，必须将数组长度作为函数参数传递到函数内部。数组` nums` 的每个元素都是整数，`scanf()` 在读取用户输入的整数时，要求给出存储它的内存的地址，`nums+i`就是第` i `个数组元素的地址。

用数组做函数参数时，参数也能够以“真正”的数组形式给出。例如对于上面的 `max() `函数，它的参数可以写成下面的形式：

```cpp
int max(int intArr[6], int len)
{   
    int i, maxValue = intArr[0];  //假设第0个元素是最大值 
    for(i=1; i<len; i++)
    {      
        if(maxValue < intArr[i])
        {      
            maxValue = intArr[i];    
        }  
    } 
    return maxValue;
}
```

`int intArr[6]`好像定义了一个拥有 6 个元素的数组，调用 `max() `时可以将数组的所有元素“一股脑”传递进来。

读者也可以省略数组长度，把形参简写为下面的形式：

```cpp
int max(int intArr[], int len)
{   
    int i, maxValue = intArr[0];  //假设第0个元素是最大值  
    for(i=1; i<len; i++)
    {      
        if(maxValue < intArr[i])
        {      
            maxValue = intArr[i];  
        }   
    } 
    return maxValue;
}
```

`int intArr[]`虽然定义了一个数组，但没有指定数组长度，好像可以接受任意长度的数组。

实际上这两种形式的数组定义都是假象，**不管是`int intArr[6]`还是`int intArr[]`都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为`int *intArr`这样的指针**。这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针。

`int intArr[6]`这种形式只能说明函数期望用户传递的数组有 6 个元素，并不意味着数组只能有 6 个元素，真正传递的数组可以有少于或多于 6 个的元素。

需要强调的是，不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度。

> C语言为什么不允许直接传递数组的所有元素，而必须传递数组指针呢？
> 参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。
> 对于像 `int`、`float`、`char` 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，为了防止技艺不佳的程序员写出低效的代码，C语言没有从语法上支持数据集合的直接赋值。
> 除了C语言，C++、Java、Python 等其它语言也禁止对大块内存进行拷贝，在底层都使用类似指针的方式来实现。

## 让指针成为函数返回值！

C语言允许函数的返回值是一个指针（地址），我们将这样的函数称为<mark>指针函数</mark>。下面的例子定义了一个函数 `strlong()`，用来返回两个字符串中较长的一个：

<u>程序</u>

```cpp
#include <stdio.h>
#include <string.h>
char *strlong(char *str1, char *str2)
{  
    if(strlen(str1) >= strlen(str2))
    {    
        return str1; 
    }
    else
    {    
        return str2;   
    }
}
int main()
{   
    char str1[30], str2[30], *str; 
    gets(str1);
    gets(str2); 
    str = strlong(str1, str2); 
    printf("Longer string: %s\n", str); 
    return 0;
}
```

<u>运行结果</u>

```
C Language
CPP Language
Longer string: CPP Language
```

用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，**函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误**。请看下面的例子：

<u>程序</u>

```cpp
#include <stdio.h>
int *func()
{  
    int n = 100; 
    return &n;
}
int main()
{   
    int *p = func(), n;  
    n = *p;  
    printf("value = %d\n", n);  
    return 0;
}
```

<u>运行结果</u>

```
value = 100
```

`n` 是 `func()` 内部的局部变量，`func() `返回了指向 `n` 的指针，根据上面的观点，`func()` 运行结束后 `n `将被销毁，使用` *p `应该获取不到 `n `的值。但是从运行结果来看，我们的推理好像是错误的，`func() `运行结束后 `*p `依然可以获取局部变量 `n` 的值，这个上面的观点不是相悖吗？

为了进一步看清问题的本质，不妨将上面的代码稍作修改，在第9~10行之间增加一个函数调用，看看会有什么效果：

<u>程序</u>

```cpp
#include <stdio.h>
int *func()
{ 
    int n = 100; 
    return &n;
}
int main()
{  
    int *p = func(), n;  
    printf("hi\n"); 
    n = *p; 
    printf("value = %d\n", n); 
    return 0;
}
```

<u>运行结果</u>

```
hi
value = -2
```

可以看到，现在` p` 指向的数据已经不是原来 `n` 的值了，它变成了一个毫无意义的甚至有些怪异的值。与前面的代码相比，该段代码仅仅是在 `*p `之前增加了一个函数调用，这一细节的不同却导致运行结果有天壤之别，究竟是为什么呢？

前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，**这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限**，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，`func() `运行结束后 `n` 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。

第一个例子在调用其他函数之前使用 `*p `抢先获得了` n` 的值并将它保存起来，第二个例子显然没有抓住机会，有其他函数被调用后才使用 `*p `获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。

# 二级指针

指针可以指向一份普通类型的数据，例如 `int`、`double`、`char `等，也可以指向一份指针类型的数据，例如 `int *`、`double *`、`char * `等。

如果一个指针指向的是另外一个指针，我们就称它为<mark>二级指针</mark>，或者<mark>指向指针的指针</mark>。

假设有一个 `int `类型的变量`a`，`p1`是指向 `a` 的指针变量，`p2 `又是指向 `p1 `的指针变量，它们的关系如下图所示：
![C语言二级指针演示图](http://c.biancheng.net/uploads/allimg/190117/1544314910-0.jpg)

将这种关系转换为C语言代码：

```cpp
int a =100;
int *p1 = &a;
int **p2 = &p1;
```

指针变量也是一种变量，也会占用存储空间，也可以使用`&`获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号`*`。`p1` 是一级指针，指向普通类型的数据，定义时有一个`*`；`p2` 是二级指针，指向一级指针 `p1`，定义时有两个`*`。

如果我们希望再定义一个三级指针 `p3`，让它指向 `p2`，那么可以这样写：

```cpp
int ***p3 = &p2;
```

四级指针也是类似的道理：

```cpp
int ****p4 = &p3;
```

> 实际开发中会经常使用一级指针和二级指针，几乎用不到高级指针。

想要获取指针指向的数据时，一级指针加一个`*`，二级指针加两个`*`，三级指针加三个`*`，以此类推，请看代码：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{   
    int a =100;   
    int *p1 = &a; 
    int **p2 = &p1; 
    int ***p3 = &p2; 
    printf("%d, %d, %d, %d\n", a, *p1, **p2, ***p3); 
    printf("&p2 = %#X, p3 = %#X\n", &p2, p3); 
    printf("&p1 = %#X, p2 = %#X, *p3 = %#X\n", &p1, p2, *p3); 
    printf(" &a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n", &a, p1, *p2, **p3);
    return 0;
}
```

<u>运行结果</u>

```
100, 100, 100, 100
&p2 = 0X28FF3C, p3 = 0X28FF3C
&p1 = 0X28FF40, p2 = 0X28FF40, *p3 = 0X28FF40
 &a = 0X28FF44, p1 = 0X28FF44, *p2 = 0X28FF44, **p3 = 0X28FF44
```

以三级指针 `p3` 为例来分析上面的代码。`***p3`等价于`*(*(*p3))`。`*p3 `得到的是 `p2` 的值，也即 `p1` 的地址；`*(*p3) `得到的是 `p1` 的值，也即 `a `的地址；经过三次“取值”操作后，`*(*(*p3)) `得到的才是` a`的值。

假设` a`、`p1`、`p2`、`p3 `的地址分别是 `0X00A0`、`0X1000`、`0X2000`、`0X3000`，它们之间的关系可以用下图来描述：
![C语言多级指针演示图](http://c.biancheng.net/uploads/allimg/190117/15443163P-1.jpg)

方框里面是变量本身的值，方框下面是变量的地址。

# `NULL`及`void`指针

## `NULL`空指针

 一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向，C语言没有一种机制来保证指向的内存的正确性，程序员必须自己提高警惕。

 很多初学者会在无意间**对没有初始化的指针进行操作，这是非常危险的**，请看下面的例子：

```cpp
#include <stdio.h>
int main()
{
    char *str;
    gets(str);
    printf("%s\n", str);
    return 0;
}
```

 这段程序没有语法错误，能够通过编译和链接，但当用户输入完字符串并按下回车键时就会发生错误，在 Linux 下表现为<mark>段错误（Segment Fault）</mark>，在 Windows 下程序直接崩溃。如果你足够幸运，或者输入的字符串少，也可能不报错，这都是未知的。

 **未初始化的局部变量的值是不确定的，C语言并没有对此作出规定，不同的编译器有不同的实现，因此不要直接使用未初始化的局部变量。** 上面的代码中，`str` 就是一个未初始化的局部变量，它的值是不确定的，究竟指向哪块内存也是未知的，大多数情况下这块内存没有被分配或者没有读写权限，使用 `gets()` 函数向它里面写入数据显然是错误的。

 建议对没有初始化的指针赋值为 NULL，例如：

```cpp
char *str = NULL;
```

NULL 是“零值、等于零”的意思，在C语言中表示<mark>空指针</mark>。从表面上理解，空指针是不指向任何数据的指针，是无效指针，程序使用它不会产生效果。**注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。**
 很多库函数都对传入的指针做了判断，如果是空指针就不做任何操作，或者给出提示信息。更改上面的代码，给 `str` 赋值 `NULL`，看看会有什么效果：

```cpp
#include <stdio.h>
int main()
{
    char *str = NULL;
    gets(str);
    printf("%s\n", str);
    return 0;
}
```

 运行程序后发现，还未等用户输入任何字符，`printf()` 就直接输出了 `(null)` 。我们有理由据此推断，`gets() `和 `printf()` 都对空指针做了特殊处理：

> 其实，`NULL` 是在`stdio.h`中定义的一个宏，它的具体内容为：
> ```cpp
#define NULL ((void *)0)
> ```
> `(void \*)0`表示把数值 0 强制转换为`void \*`类型，最外层的`( )`把宏定义的内容括起来，防止发生歧义。从整体上来看，**`NULL` 指向了地址为 0 的内存，而不是前面说的不指向任何数据**。
> 在进程的虚拟地址空间中，最低地址处有一段内存区域被称为保留区，这个区域不存储有效数据，也不能被用户程序访问，将` NULL` 指向这块区域很容易检测到违规指针。
> 在大多数操作系统中，极小的地址通常不保存数据，也不允许程序访问，`NULL `可以指向这段地址区间中的任何一个地址。
> 注意，C语言没有规定 `NULL` 的指向，只是大部分标准库约定成俗地将 `NULL` 指向 0，所以不要将` NULL` 和 0 等同起来，例如下面的写法是不专业的：
> ```cpp
int *p = 0;
> ```
> 坚持写为：
> ```cpp
int *p = NULL;
> ```

注意 `NULL` 和 `NUL `的区别：`NULL `表示空指针，是一个宏定义，可以在代码中直接使用。而 `NUL `表示字符串的结束标志 `\0`，它是ASCII码表中的第 0 个字符。`NUL` 没有在C语言中定义，仅仅是对 `\0` 的称呼，不能在代码中直接使用。

## `void*`指针

 对于空指针 `NULL` 的宏定义内容，上面只是对 `((void *)0)` 作了粗略的介绍，这里重点说一下 `void *` 的含义。**void 用在函数定义中可以表示函数没有返回值或者没有形式参数，用在这里表示指针指向的数据的类型是未知的。** 

 也就是说， **void \*表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换** 。

 C语言动态内存分配函数 `malloc()` 的返回值就是 `void *` 类型，在使用时要进行强制类型转换，请看下面的例子：

<u>程序</u>

```cpp
#include <stdio.h>

int main()
{
    //分配可以保存30个字符的内存，并把返回的指针转换为 char *
    char *str = (char *)malloc(sizeof(char) * 30);
    gets(str);
    printf("%s\n", str);
    return 0;
}
```

<u>运行结果</u>

```csharp
hi
hi
```

# 指针数组

如果一个数组中的所有元素保存的都是指针，那么我们就称它为<mark>指针数组</mark>。指针数组的定义形式一般为：

```cpp
dataType *arrayName[length];
```

`[ ]`的优先级高于`*`，该定义形式应该理解为：

```cpp
dataType *(arrayName[length]);
```

括号里面说明`arrayName`是一个数组，包含了`length`个元素，括号外面说明每个元素的类型为`dataType *`。

除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的例子：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{  
    int a = 16, b = 932, c = 100;  
    //定义一个指针数组 
    int *arr[3] = {&a, &b, &c};//也可以不指定长度，直接写作 int *arr[] 
    //定义一个指向指针数组的指针 
    int **parr = arr; 
    printf("%d, %d, %d\n", *arr[0], *arr[1], *arr[2]);  
    printf("%d, %d, %d\n", **(parr+0), **(parr+1), **(parr+2)); 
    return 0;
}
```

<u>运行结果</u>

```
16, 932, 100
16, 932, 100
```

`arr` 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 `arr` 的同时，我们使用变量 `a`、`b`、`c` 的地址对它进行了初始化，这和普通数组是多么地类似。

`parr` 是指向数组 `arr` 的指针，确切地说是指向 `arr` 第 0 个元素的指针，它的定义形式应该理解为`int *(*parr)`，括号中的`*`表示 `parr` 是一个指针，括号外面的`int *`表示 `parr `指向的数据的类型。`arr` 第 0 个元素的类型为` int *`，所以在定义 `parr` 时要加两个` *`。

第一个 `printf() `语句中，`arr[i]` 表示获取第 `i` 个元素的值，该元素是一个指针，还需要在前面增加一个` *` 才能取得它指向的数据，也即 `*arr[i]` 的形式。

第二个 `printf()` 语句中，`parr+i` 表示第 `i `个元素的地址，`*(parr+i)` 表示获取第 `i` 个元素的值（该元素是一个指针），`**(parr+i)` 表示获取第 `i `个元素指向的数据。

指针数组还可以和字符串数组结合使用，请看下面的例子：

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{    
    char *str[3]={"cpp",    
                  "C语言",      
                  "C Language"  
                  }; 
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]); 
    return 0;
}
```

<u>运行结果</u>

```
cpp
C语言
C Language
```

需要注意的是，字符数组` str `中存放的是字符串的首地址，不是字符串本身，字符串本身位于其他的内存区域，和字符数组是分开的。

也只有当指针数组中每个元素的类型都是`char *`时，才能像上面那样给指针数组赋值，其他类型不行。

为了便于理解，可以将上面的字符串数组改成下面的形式，它们都是等价的。

```cpp
#include <stdio.h>
int main()
{  
    char *str0 = "c.biancheng.net";   
    char *str1 = "C语言中文网";   
    char *str2 = "C Language";    
    char *str[3] = {str0, str1, str2}; 
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
}
```

# 二维数组指针

二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：

```cpp
int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
```

从概念上理解，a 的分布像一个矩阵：

```
0   1   2   3
4   5   6   7
8   9  10  11
```

但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：
![二维数组在内存中的存储](http://c.biancheng.net/uploads/allimg/190117/16011C417-0.jpg)

C语言中的二维数组是按行排列的，也就是先存放 `a[0] `行，再存放 `a[1] `行，最后存放` a[2] `行；每行中的 4 个元素也是依次存放。数组` a `为 `int `类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。

C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 `a`，它可以分解成三个一维数组，即` a[0]`、`a[1]`、`a[2]`。每一个一维数组又包含了 4 个元素，例如 `a[0] `包含 `a[0][0]`、`a[0][1]`、`a[0][2]`、`a[0][3]`。

假设数组 `a `中第 0 个元素的地址为 `1000`，那么每个一维数组的首地址如下图所示：
![把二维数组拆解成一维数组](http://c.biancheng.net/uploads/allimg/190117/1601164D5-1.png)

为了更好的理解指针和二维数组的关系，我们先来定义一个指向 `a `的指针变量 `p`：

```cpp
int (*p)[4] = a;
```

括号中的`*`表明 `p` 是一个指针，它指向一个数组，数组的类型为`int [4]`，这正是 `a `所包含的每个一维数组的类型。

**`[ ]`的优先级高于`*`，`( )`是必须要加的，如果赤裸裸地写作`int *p[4]`，那么应该理解为`int *(p[4])`，p 就成了一个指针数组，而不是二维数组指针。**

对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，`p` 指向的数据类型是`int [4]`，那么`p+1`就前进 4×4 = 16 个字节，`p-1`就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，`p+1`会使得指针指向二维数组的下一行，`p-1`会使得指针指向数组的上一行。

数组名 `a` 在表达式中也会被转换为和 `p` 等价的指针！

下面我们就来探索一下如何使用指针 `p` 来访问二维数组中的每个元素。按照上面的定义：

- `p`指向数组 a 的开头，也即第 0 行；`p+1`前进一行，指向第 1 行。

- `*(p+1)`表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素。

> 下面的运行结果有力地证明了这一点：
> <u>程序</u>
> ```cpp
> #include <stdio.h>
> int main()
> {   
> int a[3][4] = \{\{0, 1, 2, 3\},\{4, 5, 6, 7\},\{8, 9, 10, 11\}\};
> int (*p)[4] = a;  
> printf("%d\n", sizeof(*(p+1)));   
> return 0;
> }
> ```
> <u>运行结果</u>
> ```
> 16
> ```

-  `*(p+1)+1`表示第 1 行第 1 个元素的地址。如何理解呢？
  `*(p+1)`单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为**使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针**；就像一维数组的名字，在定义时或者和 `sizeof`、`&` 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。

- `*(*(p+1)+1)`表示第 1 行第 1 个元素的值。很明显，增加一个` * `表示取地址上的数据。

根据上面的结论，可以很容易推出以下的等价关系：

```cpp
a+i == p+i
a[i] == p[i] == *(a+i) == *(p+i)
a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)
```

实例：使用指针遍历二维数组

<u>程序</u>

```cpp
#include <stdio.h>
int main()
{    
    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11}; 
    int(*p)[4];   
    int i,j;   
    p=a;   
    for(i=0; i<3; i++)
    {     
        for(j=0; j<4; j++) 
            printf("%2d  ",*(*(p+i)+j));  
        printf("\n");  
    }   
    return 0;
}
```

<u>运行结果</u>

```
 0   1   2   3
 4   5   6   7
 8   9  10  11
```

# 函数指针

一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是<mark>函数指针</mark>。

函数指针的定义形式为：

```cpp
returnType (*pointerName)(param list);
```

`returnType` 为函数返回值类型，`pointerName `为指针名称，`param list `为函数参数列表。**参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称**，这一点和函数原型非常类似。

注意`( )`的优先级高于`*`，**第一个括号不能省略**，如果写作`returnType *pointerName(param list);`就成了函数原型，它表明函数的返回值类型为`returnType *`。

实例：用指针来实现对函数的调用

<u>程序</u>

```cpp
#include <stdio.h>
//返回两个数中较大的一个
int max(int a, int b)
{   
    return a>b ? a : b;
}
int main()
{  
    int x, y, maxval;   
    //定义函数指针 
    int (*pmax)(int, int) = max;  //也可以写作int (*pmax)(int a, int b) 
    printf("Input two numbers:");  
    scanf("%d %d", &x, &y); 
    maxval = (*pmax)(x, y);  
    printf("Max value: %d\n", maxval);  
    return 0;
}
```

<u>运行结果</u>

```
Input two numbers:10 50
Max value: 50
```

第 14 行代码对函数进行了调用。`pmax` 是一个函数指针，在前面加` * `就表示对它指向的函数进行调用。注意`( )`的优先级高于`*`，第一个括号不能省略。

# `main()`函数高级应用

Ｃ语言规定`main`函数的参数只能有两个，习惯上这两个参数写为`argc`和`argv`。因此，`main`函数的函数头可写为 `main (argc,argv)`。

Ｃ语言还规定`argc`(第一个形参)必须是整型变量,`argv`( 第二个形参)必须是指向字符串的指针数组。加上形参说明后，`main`函数的函数头应写为：

```cpp
int main (int argc,char *argv[]){}
int main (int argc,char **argv){}
```

其中**`argc`表示参数的个数；`argv[0]`为自身运行目录路径和程序名，`argv[1]`指向第一个参数、`argv[2]`指向第二个参数**……
完整程序如下：

```cpp
#include <iostream>
#include <string>
using namespace std;
int main(int argc, char **argv)
{
    string str;
    cout<<"argc:"<<argc<<endl;
    for (int i = 0; i != argc; ++i)
    {
        cout << "arg[" << i << "]" << argv[i] << endl;
    }
    return 0;
}
```

由于`main`函数不能被其它函数调用， 因此不可能在程序内部取得实际值。那么，在何处把实参值赋予`main`函数的形参呢? 实际上,`main`函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在Linux运行时，后面跟上参数即可把这些实参传送到`main`的形参中去。

在Linux下运行上面的程序结果为：

```cmd
[chenyang@localhost Program]$ ./test
argc:1
arg[0]./test
[chenyang@localhost Program]$ ./test -a
argc:2
arg[0]./test
arg[1]-a
[chenyang@localhost Program]$ ./test 100 200 aaa bbb ccc
argc:6
arg[0]./test
arg[1]100
arg[2]200
arg[3]aaa
arg[4]bbb
arg[5]ccc
```

可以看出：`arg[0]`是程序的名称，后面的参数，从`arg[1]`开始都按顺序存放在字符数组中，`argc`数至少是1个。

# SUMMARY

<mark>指针（Pointer）</mark>就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为<mark>指针变量</mark>。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。

**程序在运行过程中需要的是数据和指令的地址，变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符：在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址；程序被编译和链接后，这些名字都会消失，取而代之的是它们对应的地址。**

| 定  义         | 含  义                                                       |
| -------------- | ------------------------------------------------------------ |
| `int *p;`      | `p `可以指向 int 类型的<mark>数据</mark>，也可以指向类似` int arr[n]` 的数组。 |
| `int **p;`     | `p `为<mark>二级指针</mark>，指向` int * `类型的数据。       |
| `int *p[n];`   | `p `为<mark>指针数组</mark>。`[ ] `的优先级高于` *`，所以应该理解为` int *(p[n]);` |
| `int (*p)[n];` | `p`为<mark>二维数组指针</mark>。                             |
| `int *p();`    | `p `是一个<mark>函数</mark>，它的返回值类型为 `int *`。      |
| `int (*p)();`  | `p`是一个<mark>函数指针</mark>，指向原型为 `int func() `的函数。 |

- 指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。

- 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。

- **使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。**

- 两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。

- 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。