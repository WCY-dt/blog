---
layout: post
title:  "【C++】继承与派生"
date:   2021-01-09 00:00:00 +0800
categories: toturial
tags: C++ 面向对象
comments: 1
mathjax: true
copyrights: 转载
---

本文是C++类和对象系列第二篇：继承与派生。

# 继承&派生

C++中的继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承类似，例如儿子继承父亲的财产。

<mark>继承</mark>（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程。例如类 `B `继承于类 `A`，那么 `B `就拥有` A `的成员变量和成员函数。

在C++中，<mark>派生</mark>（Derive）和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。

被继承的类称为<mark>父类</mark>或<mark>基类</mark>，继承的类称为<mark>子类</mark>或<mark>派生类</mark>。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。

派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能。

以下是两种典型的使用继承的场景：

1. 当你创建的新类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承，这样不但会减少代码量，而且新类会拥有基类的所有功能。

2. 当你需要创建多个类，它们拥有很多相似的成员变量或成员函数时，也可以使用继承。可以将这些类的共同成员提取出来，定义为基类，然后从基类继承，既可以节省代码，也方便后续修改成员。

下面我们定义一个基类 `People`，然后由此派生出 `Student` 类：

```cpp
#include<iostream>
using namespace std;

//基类 Pelple
class People{
public:
    void setname(char *name);
    void setage(int age);
    char *getname();
    int getage();
private:
    char *m_name;
    int m_age;
};
void People::setname(char *name){ m_name = name; }
void People::setage(int age){ m_age = age; }
char* People::getname(){ return m_name; }
int People::getage(){ return m_age;}

//派生类 Student
class Student: public People{
public:
    void setscore(float score);
    float getscore();
private:
    float m_score;
};
void Student::setscore(float score){ m_score = score; }
float Student::getscore(){ return m_score; }

int main(){
    Student stu;
    stu.setname("小明");
    stu.setage(16);
    stu.setscore(95.5f);
    cout<<stu.getname()<<"的年龄是 "<<stu.getage()<<"，成绩是 "<<stu.getscore()<<endl;

    return 0;
}
```

运行结果：

```
小明的年龄是 16，成绩是 95.5
```

本例中，`People` 是基类，`Student` 是派生类。`Student` 类继承了 `People` 类的成员，同时还新增了自己的成员变量 `score` 和成员函数 `setscore()`、`getscore()`。这些继承过来的成员，可以通过子类对象访问，就像自己的一样。

请认真观察代码第21行：

```cpp
class Student: public People
```

这就是声明派生类的语法。`class` 后面的`Student`是新声明的派生类，冒号后面的`People`是已经存在的基类。在`People`之前有一关键宇 `public`，用来表示是公有继承。

由此总结出继承的一般语法为：

```cpp
class 派生类名:[继承方式] 基类名{
  派生类新增加的成员
};
```

继承方式包括 `public`（公有的）、`private`（私有的）和 `protected`（受保护的），此项是可选的，如果不写，那么默认为 `private`。

# 继承方式

## `public`、`protected`、`private` 修饰类的成员

类成员的访问权限由高到低依次为 `public` --> `protected` --> `private`，`public `成员可以通过对象来访问，`private` 成员不能通过对象访问。

现在再来补充一下 `protected`。`protected `成员和 `private` 成员类似，也不能通过对象访问。但是当存在继承关系时，`protected` 和 `private` 就不一样了：基类中的 `protected` 成员可以在派生类中使用，而基类中的 `private `成员不能在派生类中使用，下面是详细讲解。

## `public`、`protected`、`private `指定继承方式

不同的继承方式会影响基类成员在派生类中的访问权限。

1. **`public`继承方式**
  - 基类中所有 `public` 成员在派生类中为 `public` 属性；
  - 基类中所有 `protected` 成员在派生类中为 `protected` 属性；
  - 基类中所有 `private` 成员在派生类中不能使用。
2. **protected继承方式**
  - 基类中的所有 `public` 成员在派生类中为 `protected` 属性；
  - 基类中的所有 `protected` 成员在派生类中为 `protected` 属性；
  - 基类中的所有 `private` 成员在派生类中不能使用。
3. **private继承方式**
  - 基类中的所有 `public` 成员在派生类中均为 `private` 属性；
  - 基类中的所有 `protected` 成员在派生类中均为 `private` 属性；
  - 基类中的所有 `private` 成员在派生类中不能使用。

通过上面的分析可以发现：

1. 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 `protected` 时，那么基类成员在派生类中的访问权限最高也为 `protected`，高于 `protected` 的会降级为 `protected`，但低于 `protected` 不会升级。再如，当继承方式为 `public` 时，那么基类成员在派生类中的访问权限将保持不变。
    也就是说，继承方式中的 `public`、`protected`、`private` 是用来指明基类成员在派生类中的最高访问权限的。
2. 不管继承方式如何，基类中的 `private` 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。
3. 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为`public` 或 `protected`；只有那些不希望在派生类中使用的成员才声明为`private`。
4. 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 `protected`。

注意，我们这里说的是基类的`private `成员不能在派生类中使用，并没有说基类的` private` 成员不能被继承。实际上，基类的 `private` 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。`private` 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。

| 继承方式/基类成员 | `public`成员 | `protected`成员 | `private`成员 |
| ----------------- | ------------ | --------------- | ------------- |
| `public`继承      | `public`     | `protected`     | 不可见        |
| `protected`继承   | `protected`  | `protected`     | 不可见        |
| `private`继承     | `private`    | `private`       | 不可见        |


由于 `private` 和 `protected` 继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用 `public`。

例如演示类的继承关系：

```cpp
#include<iostream>
using namespace std;

//基类People
class People{
public:
    void setname(char *name);
    void setage(int age);
    void sethobby(char *hobby);
    char *gethobby();
protected:
    char *m_name;
    int m_age;
private:
    char *m_hobby;
};
void People::setname(char *name){ m_name = name; }
void People::setage(int age){ m_age = age; }
void People::sethobby(char *hobby){ m_hobby = hobby; }
char *People::gethobby(){ return m_hobby; }

//派生类Student
class Student: public People{
public:
    void setscore(float score);
protected:
    float m_score;
};
void Student::setscore(float score){ m_score = score; }

//派生类Pupil
class Pupil: public Student{
public:
    void setranking(int ranking);
    void display();
private:
    int m_ranking;
};
void Pupil::setranking(int ranking){ m_ranking = ranking; }
void Pupil::display(){
    cout<<m_name<<"的年龄是"<<m_age<<"，考试成绩为"<<m_score<<"分，班级排名第"<<m_ranking<<"，TA喜欢"<<gethobby()<<"。"<<endl;
}

int main(){
    Pupil pup;
    pup.setname("小明");
    pup.setage(15);
    pup.setscore(92.5f);
    pup.setranking(4);
    pup.sethobby("乒乓球");
    pup.display();

    return 0;
}
```

运行结果：

```
小明的年龄是15，考试成绩为92.5分，班级排名第4，TA喜欢乒乓球。
```

这是一个多级继承的例子，`Student` 继承自 `People`，`Pupil `又继承自 `Student`，它们的继承关系为 `People` --> `Student `--> `Pupil`。`Pupil` 是最终的派生类，它拥有基类的 `m_name`、`m_age`、`m_score`、`m_hobby `成员变量以及 `setname()`、`setage()`、`sethobby()`、`gethobby()`、`setscore()` 成员函数。

注意，在派生类 `Pupil `的成员函数 `display()` 中，我们借助基类的 `public` 成员函数 `gethobby()` 来访问基类的 `private` 成员变量 `m_hobby`，因为 `m_hobby` 是 `private` 属性的，在派生类中不可见，所以只能借助基类的 `public` 成员函数 `sethobby()`、`gethobby()` 来访问。

在派生类中访问基类 `private` 成员的唯一方法就是借助基类的非 `private` 成员函数，如果基类没有非 `private` 成员函数，那么该成员在派生类中将无法访问。

## 改变访问权限

使用` using `关键字可以改变基类成员在派生类中的访问权限，例如将 `public` 改为 `private`、将 `protected` 改为 `public`。

注意：`using` 只能改变基类中` public` 和` protected `成员的访问权限，不能改变 `private` 成员的访问权限，因为基类中` private` 成员在派生类中是不可见的，根本不能使用，所以基类中的 `private` 成员在派生类中无论如何都不能访问。

`using` 关键字使用示例：

```cpp
#include<iostream>
using namespace std;

//基类People
class People {
public:
    void show();
protected:
    char *m_name;
    int m_age;
};
void People::show() {
    cout << m_name << "的年龄是" << m_age << endl;
}

//派生类Student
class Student : public People {
public:
    void learning();
public:
    using People::m_name;  //将protected改为public
    using People::m_age;  //将protected改为public
    float m_score;
private:
    using People::show;  //将public改为private
};
void Student::learning() {
    cout << "我是" << m_name << "，今年" << m_age << "岁，这次考了" << m_score << "分！" << endl;
}

int main() {
    Student stu;
    stu.m_name = "小明";
    stu.m_age = 16;
    stu.m_score = 99.5f;
    stu.show();  //compile error
    stu.learning();

    return 0;
}
```

代码中首先定义了基类 `People`，它包含两个 `protected` 属性的成员变量和一个 `public` 属性的成员函数。定义 `Student `类时采用 `public `继承方式，`People `类中的成员在 `Student` 类中的访问权限默认是不变的。

不过，我们使用 `using` 改变了它们的默认访问权限，如代码第 21~25 行所示，将 `show() `函数修改为 `private` 属性的，是降低访问权限，将` name`、`age `变量修改为 `public` 属性的，是提高访问权限。

因为 `show()` 函数是 `private` 属性的，所以代码第 36 行会报错。把该行注释掉，程序输出结果为：

```
我是小明，今年16岁，这次考了99.5分！
```

# 名字遮蔽

如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。

下面是一个成员函数的名字遮蔽的例子：

```cpp
#include<iostream>
using namespace std;

//基类People
class People{
public:
    void show();
protected:
    char *m_name;
    int m_age;
};
void People::show(){
    cout<<"嗨，大家好，我叫"<<m_name<<"，今年"<<m_age<<"岁"<<endl;
}

//派生类Student
class Student: public People{
public:
    Student(char *name, int age, float score);
public:
    void show();  //遮蔽基类的show()
private:
    float m_score;
};
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    Student stu("小明", 16, 90.5);
    //使用的是派生类新增的成员函数，而不是从基类继承的
    stu.show();
    //使用的是从基类继承来的成员函数
    stu.People::show();

    return 0;
}
```

运行结果：

```
小明的年龄是16，成绩是90.5
嗨，大家好，我叫小明，今年16岁
```

本例中，基类` People` 和派生类 `Student `都定义了成员函数` show()`，它们的名字一样，会造成遮蔽。第 37 行代码中，`stu `是 `Student `类的对象，默认使用 `Student `类的 `show() `函数。

但是，基类 `People` 中的 `show()` 函数仍然可以访问，不过要加上类名和域解析符，如第 39 行代码所示。

## 基类成员函数和派生类成员函数不构成重载

基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。

下面的例子很好的说明了这一点：

```cpp
#include<iostream>
using namespace std;

//基类Base
class Base{
public:
    void func();
    void func(int);
};
void Base::func(){ cout<<"Base::func()"<<endl; }
void Base::func(int a){ cout<<"Base::func(int)"<<endl; }

//派生类Derived
class Derived: public Base{
public:
    void func(char *);
    void func(bool);
};
void Derived::func(char *str){ cout<<"Derived::func(char *)"<<endl; }
void Derived::func(bool is){ cout<<"Derived::func(bool)"<<endl; }

int main(){
    Derived d;
    d.func("c.biancheng.net");
    d.func(true);
    d.func();  //compile error
    d.func(10);  //compile error
    d.Base::func();
    d.Base::func(100);

    return 0;
}
```

本例中，`Base` 类的`func()`、`func(int)`和 `Derived` 类的`func(char *)`、`func(bool)`四个成员函数的名字相同，参数列表不同，它们看似构成了重载，能够通过对象` d `访问所有的函数，实则不然，`Derive` 类的 `func `遮蔽了 `Base` 类的 `func`，导致第 26、27 行代码没有匹配的函数，所以调用失败。

如果说有重载关系，那么也是 `Base` 类的两个` func `构成重载，而 `Derive` 类的两个 `func `构成另外的重载。

# 继承时的作用域嵌套

在继承情况下，派生类的作用域嵌套在基类作用域中：如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。

正是这种类作用域的层次嵌套使我们能够直接访问基类的成员,就好像这些成员是派生类成员一样：

```cpp
Bulk_item bulk;
cout << bulk.book() << endl;
```

名字`book`的使用将这样确定[先派生->后基类]：

1. `bulk`是`Bulk_item`类对象，在`Bulk_item`类中查找，找不到名字`book`。

2. 因为从`Item_base`派生`Bulk_item`，所以接着在`Item_base`类中查找，找到名字`book`，则引用成功的确定了。

## 名字查找在编译时发生

对象、引用或指针的静态类型决定了对象能够完成的行为。甚至当静态类型和动态类型可能不同的时候,就像使用基类类型的引用或指针时可能会发生的,静态类型仍然决定着可以使用什么成员：

```cpp
class Bulk_item : public Item_base
{
public:
    std::pair<size_t,double> discount_policy() const
    {
        return std::make_pair(quantity,discount);
    }
};
 
</size_t,double>
```

只能通过`Disc_item`类型或`Disc_item`派生类型的对象、指针或引用访问`discount_policy()`：

```cpp
Bulk_item bulk;
Bulk_item *bulkP = &bulk;
Item_base *itemP = &bulk;
 
bulkP -> discount_policy(); //OK
itemP -> discount_policy(); //Error
```

通过`itemP`访问是错误的，因为基类类型的指针（引用或对象）只能访问对象的基类部分，而不能访问派生类部分，而在基类中又没有定义`discount_policy()`成员。

## 名字冲突与继承

与基类成员同名的派生类成员将屏蔽对基类成员的直接访问：

```cpp
class Base
{
public:
    Base():mem(0){}
 
protected:
    int mem;
};
 
class Derived : public Base
{
public:
    Derived(int i):mem(i){}
    int get_mem() const
    {
        return mem; //Derived::mem
    }
 
private:
    int mem;    //将会屏蔽Base::mem
};
```

`get_mem`中对`mem`的引用被确定为`Derive`中的名字：

```cpp
Derived d(43);
cout << d.get_mem() << endl;    //output 43
```

可以使用作用域操作符访问被屏蔽的成员：

```cpp
class Derived : public Base
{
public:
    int get_mem() const
    {
        return Base::mem; //Derived::mem
    }
    //As before
};
 
 
//测试
    Derived d(43);
    cout << d.get_mem() << endl;    //output 0
```

作用域操作符指示编译器在`Base`中查找`mem`成员。

## 作用域与成员函数

在基类和派生类中使用同一名字的成员函数，其行为与数据成员一样：在派生类作用域中派生类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽：

```cpp
struct Base
{
    int memfuc();
};
 
struct Derived : Base
{
    int memfuc(int);
};
 
int main()
{
    Derived d;
    Base b;
    b.memfuc();         //调用Base::memfuc()
    d.memfuc(10);       //调用Derived::memfuc()
    d.memfuc();         //Error
    d.Base::memfuc();//调用Base::memfuc()
}
```

`Derived`中的`memfuc`声明隐藏了`Base`中的声明。在确定下面一条语句时：

```cpp
d.memfuc();
```

编译器查找名字`memfuc`，并在`Derived`类中找到。一旦找到了名字，编译器要就不再继续查找了。

局部作用域中声明的函数不会重载全局作用域中定义的函数，同样，派生类中定义的函数也不会重载基类中定义的成员。通过派生类对象调用函数时，实参必须与派生类中定义的版本相匹配，只有在派生类中根本没有定义该函数时，才考虑基类函数。如：

```cpp
struct Base
{
    int memfuc();
};
 
struct Derived : Base
{
    int memfuc(int);
};
 
Derived d;
d.memfuc(); //Error
```

如果将`Derived`中的`intmemfuc(int)`注释掉，则：

```cpp
d.memfuc(); //OK
```

### 重载函数

像其他任意函数一样,成员函数(无论虚还是非虚)也可以重载。派生类可以重定义所继承的0个或多个版本。

注意，如果派生类重定义了重载成员，则通过派生类型只能访问派生类中重定义的那些成员！

```cpp
struct Derived : Base
{
    int memfuc();
    int memfuc(int);
    double memfuc(double);
};
 
int main()
{
    Derived d;
    d.memfuc();     //Derived::memfuc()
    d.memfuc(10);   //Derived::memfuc(int)
}
```

如果派生类想通过自身类型使用所有的重载版本,则派生类必须要么重定义所有重载版本,要么一个也不重定义。

有时类需要仅仅重定义一个重载版本，并且想要继承其他版本的含义,在这种情况下，派生类不用重定义所继承的每一个基类版本,它可以为重载成员提供`using`声明。一个`using`声明只能指定一个名字,不能指定形参表,因此：`using`声明会将该函数的所有重载实例加到派生类的作用域。将所有名字加入作用域之后,派生类只需要重定义本类型确实必须定义的那些函数,对其他版本可以使用继承的定义。

```cpp
struct Base
{
    int memfuc();
    int memfuc(int);
    int memfuc(double);
};
 
struct Derived : Base
{
    using Base::memfuc;
    int memfuc();   //重定义
};
 
int main()
{
    Derived d;
    d.memfuc();     //Derived::memfuc()
    d.memfuc(10);   //Base::memfuc(int)
}
```

## 虚函数与作用域

虚函数：如果基类成员与派生类成员接受的实参不同，就没有办法通过基类类型的引用或指针调用派生类函数：

```cpp
class Base
{
public:
    virtual int fcn();
};
 
class D1 : public Base
{
public:
    //该fcn屏蔽了Base类中的虚函数fun
    int fcn(int);
    /**此时有两个名为 fcn 的函数:
    *类从 Base 继承的一个名为 fcn 的虚函数
    *类定义的名为 fcn 的非虚成员函数,该函数接受一个 int 形参
    */
};
 
class D2 : public D1
{
public:
    /**重定义了它继承的两个函数:
    *1.重定义了 Base 中定义的 fcn 的原始版本
    *2.重定义了 D1 中定义的非虚版本。
    */
    int fcn();
    int fcn(int);
};
```

### 通过基类调用被屏蔽的虚函数

通过基类类型的引用或指针调用函数时，编译器将在基类中查找该函数而忽略派生类：

```cpp
Base bobj;
D1 d1obj;
D2 d2obj;
Base *bp1 = &bobj,*bp2 = &d1obj,*bp3 = &d2obj;
bp1 -> fcn();    //调用Base::fcn()
bp2 -> fcn();    //调用Base::fcn()
bp3 -> fcn();    //调用D2::fcn()
```

理解 C++中继承层次的关键在于理解如何确定函数调用。确定函数调用遵循以下四个步骤：

1. 首先确定进行函数调用的对象、引用或指针的静态类型

2. 在该类中查找函数，如果找不到，就在直接基类中查找，如此循着类的继承链往上找，直到找到该函数或者查找完最后一个类。如果不能在类或其相关基类中找到该名字，则调用是错误的。

3. 一旦找到了该名字,就进行常规类型检查,查看如果给定找到的定义,该函数调用是否合法。

4. 假定函数调用合法,编译器就生成代码。如果函数是虚函数且通过引用或指针调用,则编译器生成代码以确定根据对象的动态类型运行哪个函数版本,否则,编译器生成代码直接调用函数。

# 基类和派生类构造函数

前面我们说基类的成员函数可以被继承，可以通过派生类的对象访问，但这仅仅指的是普通的成员函数，类的构造函数不能被继承。构造函数不能被继承是有道理的，因为即使继承了，它的名字和派生类的名字也不一样，不能成为派生类的构造函数，当然更不能成为普通的成员函数。

在设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有 `private` 属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。

这种矛盾在C++继承中是普遍存在的，解决这个问题的思路是：在派生类的构造函数中调用基类的构造函数。

下面的例子展示了如何在派生类的构造函数中调用基类的构造函数：

```cpp
#include<iostream>
using namespace std;

//基类People
class People{
protected:
    char *m_name;
    int m_age;
public:
    People(char*, int);
};
People::People(char *name, int age): m_name(name), m_age(age){}

//派生类Student
class Student: public People{
private:
    float m_score;
public:
    Student(char *name, int age, float score);
    void display();
};
//People(name, age)就是调用基类的构造函数
Student::Student(char *name, int age, float score): People(name, age), m_score(score){ }
void Student::display(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"。"<<endl;
}

int main(){
    Student stu("小明", 16, 90.5);
    stu.display();

    return 0;
}
```

运行结果为：

```
小明的年龄是16，成绩是90.5。
```

请注意第 23 行代码：

```cpp
Student::Student(char *name, int age, float score): People(name, age), m_score(score){ }
```

`People(name, age)`就是调用基类的构造函数，并将` name `和 `age `作为实参传递给它，`m_score(score)`是派生类的参数初始化表，它们之间以逗号`,`隔开。

也可以将基类构造函数的调用放在参数初始化表后面：

```cpp
Student::Student(char *name, int age, float score): m_score(score), People(name, age){ }
```

但是不管它们的顺序如何，派生类构造函数总是先调用基类构造函数再执行其他代码（包括参数初始化表以及函数体中的代码），总体上看和下面的形式类似：

```cpp
Student::Student(char *name, int age, float score){
    People(name, age);
    m_score = score;
}
```

当然这段代码只是为了方便大家理解，实际上这样写是错误的，因为基类构造函数不会被继承，不能当做普通的成员函数来调用。换句话说，只能将基类构造函数的调用放在函数头部，不能放在函数体中。

另外，函数头部是对基类构造函数的调用，而不是声明，所以括号里的参数是实参，它们不但可以是派生类构造函数参数列表中的参数，还可以是局部变量、常量等，例如：

```cpp
Student::Student(char *name, int age, float score): People("小明", 16), m_score(score){ }
```

## 构造函数的调用顺序

从上面的分析中可以看出，基类构造函数总是被优先调用，这说明创建派生类对象时，会先调用基类构造函数，再调用派生类构造函数，如果继承关系有好几层的话，例如：

A --> B --> C

那么创建 C 类对象时构造函数的执行顺序为：

A类构造函数 --> B类构造函数 --> C类构造函数

构造函数的调用顺序是按照继承的层次自顶向下、从基类再到派生类的。

还有一点要注意，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。以上面的 A、B、C 类为例，C 是最终的派生类，B 就是 C 的直接基类，A 就是 C 的间接基类。

C++ 这样规定是有道理的，因为我们在 C 中调用了 B 的构造函数，B 又调用了 A 的构造函数，相当于 C 间接地（或者说隐式地）调用了 A 的构造函数，如果再在 C 中显式地调用 A 的构造函数，那么 A 的构造函数就被调用了两次，相应地，初始化工作也做了两次，这不仅是多余的，还会浪费CPU时间以及内存，毫无益处，所以 C++ 禁止在 C 中显式地调用 A 的构造函数。 

## 基类构造函数调用规则

事实上，通过派生类创建对象时必须要调用基类的构造函数，这是语法规定。换句话说，定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么编译失败。请看下面的例子：

```cpp
#include <iostream>
using namespace std;

//基类People
class People{
public:
    People();  //基类默认构造函数
    People(char *name, int age);
protected:
    char *m_name;
    int m_age;
};
People::People(): m_name("xxx"), m_age(0){ }
People::People(char *name, int age): m_name(name), m_age(age){}

//派生类Student
class Student: public People{
public:
    Student();
    Student(char*, int, float);
public:
    void display();
private:
    float m_score;
};
Student::Student(): m_score(0.0){ }  //派生类默认构造函数
Student::Student(char *name, int age, float score): People(name, age), m_score(score){ }
void Student::display(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"。"<<endl;
}

int main(){
    Student stu1;
    stu1.display();

    Student stu2("小明", 16, 90.5);
    stu2.display();

    return 0;
}
```

运行结果：

```
xxx的年龄是0，成绩是0。
小明的年龄是16，成绩是90.5。
```

创建对象 `stu1` 时，执行派生类的构造函数`Student::Student()`，它并没有指明要调用基类的哪一个构造函数，从运行结果可以很明显地看出来，系统默认调用了不带参数的构造函数，也就是`People::People()`。

创建对象` stu2` 时，执行派生类的构造函数`Student::Student(char *name, int age, float score)`，它指明了基类的构造函数。

在第 27 行代码中，如果将`People(name, age)`去掉，也会调用默认构造函数，第 37 行的输出结果将变为：
xxx的年龄是0，成绩是90.5。

如果将基类` People` 中不带参数的构造函数删除，那么会发生编译错误，因为创建对象 `stu1` 时需要调用 `People `类的默认构造函数， 而` People` 类中已经显式定义了构造函数，编译器不会再生成默认的构造函数。

# 基类和派生类的析构函数

和构造函数类似，析构函数也不能被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。

另外析构函数的执行顺序和构造函数的执行顺序也刚好相反：

- 创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数。
- 而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。
  请看下面的例子：

```cpp
#include <iostream>
using namespace std;

class A{
public:
    A(){cout<<"A constructor"<<endl;}
    ~A(){cout<<"A destructor"<<endl;}
};

class B: public A{
public:
    B(){cout<<"B constructor"<<endl;}
    ~B(){cout<<"B destructor"<<endl;}
};

class C: public B{
public:
    C(){cout<<"C constructor"<<endl;}
    ~C(){cout<<"C destructor"<<endl;}
};

int main(){
    C test;
    return 0;
}
```

运行结果：

```
A constructor
B constructor
C constructor
C destructor
B destructor
A destructor
```

# 多继承

在前面的例子中，派生类都只有一个基类，称为<mark>单继承</mark>（Single Inheritance）。除此之外，C++也支持<mark>多继承</mark>（Multiple Inheritance），即一个派生类可以有两个或多个基类。

> 多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java, C#, PHP 等干脆取消了多继承。

多继承的语法也很简单，将多个基类用逗号隔开即可。例如已声明了类`A`、类`B`和类`C`，那么可以这样来声明派生类`D`：

```cpp
class D: public A, private B, protected C{
  //类D新增加的成员
}
```

`D` 是多继承形式的派生类，它以公有的方式继承 `A` 类，以私有的方式继承 `B `类，以保护的方式继承` C `类。`D` 根据不同的继承方式获取 `A`、`B`、`C` 中的成员，确定它们在派生类中的访问权限。

## 多继承下的构造函数

多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。以上面的 `A`、`B`、`C`、`D` 类为例，`D` 类构造函数的写法为：

```cpp
D(形参列表): A(实参列表), B(实参列表), C(实参列表){
  //其他操作
}
```

基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。仍然以上面的 `A`、`B`、`C`、`D` 类为例，即使将 `D` 类构造函数写作下面的形式：

```cpp
D(形参列表): B(实参列表), C(实参列表), A(实参列表){
  //其他操作
}
```

那么也是先调用 `A` 类的构造函数，再调用 `B` 类构造函数，最后调用 `C `类构造函数。

下面是一个多继承的实例：

```cpp
#include <iostream>
using namespace std;

//基类
class BaseA{
public:
    BaseA(int a, int b);
    ~BaseA();
protected:
    int m_a;
    int m_b;
};
BaseA::BaseA(int a, int b): m_a(a), m_b(b){
    cout<<"BaseA constructor"<<endl;
}
BaseA::~BaseA(){
    cout<<"BaseA destructor"<<endl;
}

//基类
class BaseB{
public:
    BaseB(int c, int d);
    ~BaseB();
protected:
    int m_c;
    int m_d;
};
BaseB::BaseB(int c, int d): m_c(c), m_d(d){
    cout<<"BaseB constructor"<<endl;
}
BaseB::~BaseB(){
    cout<<"BaseB destructor"<<endl;
}

//派生类
class Derived: public BaseA, public BaseB{
public:
    Derived(int a, int b, int c, int d, int e);
    ~Derived();
public:
    void show();
private:
    int m_e;
};
Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e){
    cout<<"Derived constructor"<<endl;
}
Derived::~Derived(){
    cout<<"Derived destructor"<<endl;
}
void Derived::show(){
    cout<<m_a<<", "<<m_b<<", "<<m_c<<", "<<m_d<<", "<<m_e<<endl;
}

int main(){
    Derived obj(1, 2, 3, 4, 5);
    obj.show();
    return 0;
}
```

运行结果：

```
BaseA constructor
BaseB constructor
Derived constructor
1, 2, 3, 4, 5
Derived destructor
BaseB destructor
BaseA destructor
```

从运行结果中还可以发现，多继承形式下析构函数的执行顺序和构造函数的执行顺序相反。

## 命名冲突

当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上类名和域解析符`::`，以显式地指明到底使用哪个类的成员，消除二义性。

修改上面的代码，为 `BaseA` 和 `BaseB` 类添加 `show()` 函数，并将 `Derived` 类的 `show()` 函数更名为 `display()`：

```cpp
#include <iostream>
using namespace std;

//基类
class BaseA{
public:
    BaseA(int a, int b);
    ~BaseA();
public:
    void show();
protected:
    int m_a;
    int m_b;
};
BaseA::BaseA(int a, int b): m_a(a), m_b(b){
    cout<<"BaseA constructor"<<endl;
}
BaseA::~BaseA(){
    cout<<"BaseA destructor"<<endl;
}
void BaseA::show(){
    cout<<"m_a = "<<m_a<<endl;
    cout<<"m_b = "<<m_b<<endl;
}

//基类
class BaseB{
public:
    BaseB(int c, int d);
    ~BaseB();
    void show();
protected:
    int m_c;
    int m_d;
};
BaseB::BaseB(int c, int d): m_c(c), m_d(d){
    cout<<"BaseB constructor"<<endl;
}
BaseB::~BaseB(){
    cout<<"BaseB destructor"<<endl;
}
void BaseB::show(){
    cout<<"m_c = "<<m_c<<endl;
    cout<<"m_d = "<<m_d<<endl;
}

//派生类
class Derived: public BaseA, public BaseB{
public:
    Derived(int a, int b, int c, int d, int e);
    ~Derived();
public:
    void display();
private:
    int m_e;
};
Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e){
    cout<<"Derived constructor"<<endl;
}
Derived::~Derived(){
    cout<<"Derived destructor"<<endl;
}
void Derived::display(){
    BaseA::show();  //调用BaseA类的show()函数
    BaseB::show();  //调用BaseB类的show()函数
    cout<<"m_e = "<<m_e<<endl;
}

int main(){
    Derived obj(1, 2, 3, 4, 5);
    obj.display();
    return 0;
}
```

请读者注意第 64、65 行代码，我们显式的指明了要调用哪个基类的 `show() `函数。

# 突破访问限制

C++面向对象中有一大特性就是封装，使用不同的访问控制符来控制外界对其的访问权限。

例如C++中类的`private`成员对外是不可见的，可以通过以下方法突破对private成员的访问权限

```cpp
#include<iostream>
using namespace std;
class A{
    private:
        int mPrivate;
        int nPrivate;
    public:
        A():mPrivate(1),nPrivate(2){};
        template<typename T> void func(const T &t){}
        const int GetValueN(){
            return nPrivate;
    }
};
```

## 操作指针修改内存数据

```cpp
int main(){
    A obj=A();
    int temp=3;
    int *ptr=(int*)(&obj);
    *(ptr+1)=temp;
    cout<<"nPrivate="<<obj.GetValueN()<<endl;
    return 0;
}
```

## 使用友元声明

在类中声明一个友元函数，在类外进行定义。

```cpp
int main(){
    A obj=A();
    Jack(obj);
    cout<<"nPrivate="<<obj.GetValueN()<<endl;
    return 0;
}
```

## 使用模板

类`A`中定义了一个模板函数`func()`，在类外加一个模板函数，导致模板推演的过程中多出一个自己写的并且加入了备选组中，相当于多了一个重载。

类外函数的参数是在匿名空间中定义的特定类型，所以避免扰乱原本该函数的功能。

```cpp
int main(){
    A obj;
    obj.func(B());
    cout<<"nPrivate="<<obj.GetValueN()<<endl;
    return 0;
}
```

## `#define private public`

使用`#define`把`private`定义为`public`，这样类中定义的`private`起始就是`public`。

## 利用指针修改私有成员

```cpp
int main(){
    A a;
    int* p=(int*)&a;   //突破编译器防线
    a.print();
    *p=30;            //修改a对象私有成员的值
    a.print();        
    return 0;
}
```

私有成员变量及时是 `const` 类型也是无济于事的，他们都无法阻挡指针的穿透力。

# 虚继承&虚基类

<mark>多继承</mark>（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。

多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：

![菱形继承](http://c.biancheng.net/uploads/allimg/200629/1-2006291I602320.png)

类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。下面是菱形继承的具体实现：

```cpp
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: public A{
protected:
    int m_b;
};

//直接基类C
class C: public A{
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //命名冲突
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 `m_a`，结果发生了错误，因为类 B 和类 C 中都有成员变量 `m_a`（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。

为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：

```cpp
void seta(int a){ B::m_a = a; }
```

这样表示使用 B 类的 `m_a`。当然也可以使用 C 类的：

```cpp
void seta(int a){ C::m_a = a; }
```

## 虚继承

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了<mark>虚继承</mark>（Virtual Inheritance），使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上` virtual` 关键字就是虚继承，请看下面的例子：

```cpp
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};

//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 `m_a`，直接访问就不会再有歧义了。

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为<mark>虚基类</mark>（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

现在让我们重新梳理一下本例的继承关系，如下图所示：

![菱形继承和虚继承](http://c.biancheng.net/uploads/allimg/200629/1-2006291J3551E.png)

观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。

在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。

C++标准库中的 `iostream `类就是一个虚继承的实际应用案例。`iostream `从` istream `和 `ostream `直接继承而来，而` istream `和` ostream `又都继承自一个共同的名为` base_ios `的类，是典型的菱形继承。此时` istream` 和 `ostream` 必须采用虚继承，否则将导致` iostream `类中保留两份 `base_ios `类的成员。

![虚继承在C++标准库中的实际应用](http://c.biancheng.net/uploads/allimg/200629/1-2006291K2591N.png)

## 虚基类成员的可见性

因为在虚继承的最终派生类中只保留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。

以图2中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：

- 如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。
- 如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。
- 如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。


可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，因此我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。

# 虚继承的构造函数

在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。

下面我们以菱形继承为例来演示构造函数的调用：

```cpp
#include <iostream>
using namespace std;

//虚基类A
class A{
public:
    A(int a);
protected:
    int m_a;
};
A::A(int a): m_a(a){ }

//直接派生类B
class B: virtual public A{
public:
    B(int a, int b);
public:
    void display();
protected:
    int m_b;
};
B::B(int a, int b): A(a), m_b(b){ }
void B::display(){
    cout<<"m_a="<<m_a<<", m_b="<<m_b<<endl;
}

//直接派生类C
class C: virtual public A{
public:
    C(int a, int c);
public:
    void display();
protected:
    int m_c;
};
C::C(int a, int c): A(a), m_c(c){ }
void C::display(){
    cout<<"m_a="<<m_a<<", m_c="<<m_c<<endl;
}

//间接派生类D
class D: public B, public C{
public:
    D(int a, int b, int c, int d);
public:
    void display();
private:
    int m_d;
};
D::D(int a, int b, int c, int d): A(a), B(90, b), C(100, c), m_d(d){ }
void D::display(){
    cout<<"m_a="<<m_a<<", m_b="<<m_b<<", m_c="<<m_c<<", m_d="<<m_d<<endl;
}

int main(){
    B b(10, 20);
    b.display();
   
    C c(30, 40);
    c.display();

    D d(50, 60, 70, 80);
    d.display();
    return 0;
}
```

运行结果：

```
m_a=10, m_b=20
m_a=30, m_c=40
m_a=50, m_b=60, m_c=70, m_d=80
```

请注意第 50 行代码，在最终派生类 D 的构造函数中，除了调用 B 和 C 的构造函数，还调用了 A 的构造函数，这说明 D 不但要负责初始化直接基类 B 和 C，还要负责初始化间接基类 A。而在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。

现在采用了虚继承，虚基类 A 在最终派生类 D 中只保留了一份成员变量 `m_a`，如果由 B 和 C 初始化 `m_a`，那么 B 和 C 在调用 A 的构造函数时很有可能给出不同的实参，这个时候编译器就会犯迷糊，不知道使用哪个实参初始化 `m_a`。

为了避免出现这种矛盾的情况，C++干脆规定必须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A 的构造函数的调用是无效的。在第 50 行代码中，调用 B 的构造函数时试图将 `m_a `初始化为 90，调用 C 的构造函数时试图将 `m_a` 初始化为 100，但是输出结果有力地证明了这些都是无效的，`m_a `最终被初始化为 50，这正是在 D 中直接调用 A 的构造函数的结果。

另外需要关注的是构造函数的执行顺序。虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。

修改本例中第 50 行代码，改变构造函数出现的顺序：

```cpp
D::D(int a, int b, int c, int d): B(90, b), C(100, c), A(a), m_d(d){ }
```

虽然我们将` A()` 放在了最后，但是编译器仍然会先调用 `A()`，然后再调用 `B()`、`C()`，因为` A()` 是虚基类的构造函数，比其他构造函数优先级高。如果没有使用虚继承的话，那么编译器将按照出现的顺序依次调用 `B()`、`C()`、`A()`。

# 向上转型

在 C/C++ 中经常会发生数据类型的转换，例如将 `int `类型的数据赋值给` float `类型的变量时，编译器会先把` int `类型的数据转换为` float `类型再赋值；反过来，`float `类型的数据在经过类型转换后也可以赋值给 `int `类型的变量。

数据类型转换的前提是，编译器知道如何对数据进行取舍。例如：

```cpp
int a = 10.9;
printf("%d\n", a);
```

输出结果为 10，编译器会将小数部分直接丢掉（不是四舍五入）。再如：

```cpp
float b = 10;
printf("%f\n", b);
```

输出结果为 10.000000，编译器会自动添加小数部分。

类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为<mark>向上转型</mark>（Upcasting）。相应地，将基类赋值给派生类称为<mark>向下转型</mark>（Downcasting）。

向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。本节只介绍向上转型，向下转型将在后续章节介绍。

> 向上转型和向下转型是面向对象编程的一种通用概念，它们也存在于 Java、C# 等编程语言中。

## 将派生类对象赋值给基类对象

下面的例子演示了如何将派生类对象赋值给基类对象：

```cpp
#include <iostream>
using namespace std;

//基类
class A{
public:
    A(int a);
public:
    void display();
public:
    int m_a;
};
A::A(int a): m_a(a){ }
void A::display(){
    cout<<"Class A: m_a="<<m_a<<endl;
}

//派生类
class B: public A{
public:
    B(int a, int b);
public:
    void display();
public:
    int m_b;
};
B::B(int a, int b): A(a), m_b(b){ }
void B::display(){
    cout<<"Class B: m_a="<<m_a<<", m_b="<<m_b<<endl;
}


int main(){
    A a(10);
    B b(66, 99);
    //赋值前
    a.display();
    b.display();
    cout<<"--------------"<<endl;
    //赋值后
    a = b;
    a.display();
    b.display();

    return 0;
}
```

运行结果：

```
Class A: m_a=10
Class B: m_a=66, m_b=99
\----------------------------
Class A: m_a=66
Class B: m_a=66, m_b=99
```

本例中 A 是基类， B 是派生类，a、b 分别是它们的对象，由于派生类 B 包含了从基类 A 继承来的成员，因此可以将派生类对象 b 赋值给基类对象 a。通过运行结果也可以发现，赋值后 a 所包含的成员变量的值已经发生了变化。

赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。运行结果也有力地证明了这一点，虽然有`a=b;`这样的赋值过程，但是 `a.display()` 始终调用的都是 A 类的 `display()` 函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响 `this` 指针。

将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示：

![img](http://c.biancheng.net/uploads/allimg/190214/1G45K0C-0.png)

可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员，所以依然不同通过基类对象来访问派生类的成员。对于上面的例子，`a.m_a` 是正确的，但 `a.m_b` 就是错误的，因为 a 不包含成员 `m_b`。

这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。

要理解这个问题，还得从赋值的本质入手。赋值实际上是向内存填充数据，当数据较多时很好处理，舍弃即可；本例中将 b 赋值给 a 时（执行`a=b;`语句），成员 m_b 是多余的，会被直接丢掉，所以不会发生赋值错误。但当数据较少时，问题就很棘手，编译器不知道如何填充剩下的内存；如果本例中有`b= a;`这样的语句，编译器就不知道该如何给变量 `m_b` 赋值，所以会发生错误。

## 将派生类指针赋值给基类指针

除了可以将派生类对象赋值给基类对象（对象变量之间的赋值），还可以将派生类指针赋值给基类指针（对象指针之间的赋值）。我们先来看一个多继承的例子，继承关系为：

![img](http://c.biancheng.net/uploads/allimg/190214/1G45IP6-1.jpg)


下面的代码实现了这种继承关系：

```cpp
#include <iostream>
using namespace std;

//基类A
class A{
public:
    A(int a);
public:
    void display();
protected:
    int m_a;
};
A::A(int a): m_a(a){ }
void A::display(){
    cout<<"Class A: m_a="<<m_a<<endl;
}

//中间派生类B
class B: public A{
public:
    B(int a, int b);
public:
    void display();
protected:
    int m_b;
};
B::B(int a, int b): A(a), m_b(b){ }
void B::display(){
    cout<<"Class B: m_a="<<m_a<<", m_b="<<m_b<<endl;
}

//基类C
class C{
public:
    C(int c);
public:
    void display();
protected:
    int m_c;
};
C::C(int c): m_c(c){ }
void C::display(){
    cout<<"Class C: m_c="<<m_c<<endl;
}

//最终派生类D
class D: public B, public C{
public:
    D(int a, int b, int c, int d);
public:
    void display();
private:
    int m_d;
};
D::D(int a, int b, int c, int d): B(a, b), C(c), m_d(d){ }
void D::display(){
    cout<<"Class D: m_a="<<m_a<<", m_b="<<m_b<<", m_c="<<m_c<<", m_d="<<m_d<<endl;
}


int main(){
    A *pa = new A(1);
    B *pb = new B(2, 20);
    C *pc = new C(3);
    D *pd = new D(4, 40, 400, 4000);

    pa = pd;
    pa -> display();

    pb = pd;
    pb -> display();

    pc = pd;
    pc -> display();

    cout<<"-----------------------"<<endl;
    cout<<"pa="<<pa<<endl;
    cout<<"pb="<<pb<<endl;
    cout<<"pc="<<pc<<endl;
    cout<<"pd="<<pd<<endl;

    return 0;
}
```

运行结果：

```
Class A: m_a=4
Class B: m_a=4, m_b=40
Class C: m_c=400
\-----------------------
pa=0x9b17f8
pb=0x9b17f8
pc=0x9b1800
pd=0x9b17f8
```

本例中定义了多个对象指针，并尝试将派生类指针赋值给基类指针。与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。

### 通过基类指针访问派生类的成员

请读者先关注第 68 行代码，我们将派生类指针 pd 赋值给了基类指针 pa，从运行结果可以看出，调用 `display()` 函数时虽然使用了派生类的成员变量，但是 `display()` 函数本身却是基类的。也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数，这看起来有点不伦不类，究竟是为什么呢？第 71、74 行代码也是类似的情况。

pa 本来是基类 A 的指针，现在指向了派生类 D 的对象，这使得隐式指针` this` 发生了变化，也指向了 D 类的对象，所以最终在 `display() `内部使用的是 D 类对象的成员变量，相信这一点不难理解。

编译器虽然通过指针的指向来访问成员变量，但是却不通过指针的指向来访问成员函数：编译器通过指针的类型来访问成员函数。对于 pa，它的类型是 A，不管它指向哪个对象，使用的都是 A 类的成员函数。

概括起来说就是：编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。

### 赋值后值不一致的情况

本例中我们将最终派生类的指针 pd 分别赋值给了基类指针 pa、pb、pc，按理说它们的值应该相等，都指向同一块内存，但是运行结果却有力地反驳了这种推论，只有 pa、pb、pd 三个指针的值相等，pc 的值比它们都大。也就是说，执行`pc = pd;`语句后，pc 和 pd 的值并不相等。

## 将派生类引用赋值给基类引用

引用在本质上是通过指针的方式实现的，既然基类的指针可以指向派生类的对象，那么我们就有理由推断：基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。

修改上例中`main() `函数内部的代码，用引用取代指针：

```cpp
int main(){
    D d(4, 40, 400, 4000);
   
    A &ra = d;
    B &rb = d;
    C &rc = d;
   
    ra.display();
    rb.display();
    rc.display();

    return 0;
}
```

运行结果：

```
Class A: m_a=4
Class B: m_a=4, m_b=40
Class C: m_c=400
```

ra、rb、rc 是基类的引用，它们都引用了派生类对象 d，并调用了 `display()` 函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。

引用和指针的表现之所以如此类似，是因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装。

最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。

# 继承的对象内存模型

## 类中的元素

成员变量、成员函数、静态成员变量、静态成员函数、虚函数、纯虚函数

## 影响对象大小的因素

成员变量：虚函数表指针（`_vftptr`）、虚基类表指针（`_vbtptr`）、内存对齐

`_vftptr`、`_vbtptr`的初始化由对象的构造函数, 赋值运算符自动完成；对象生命周期结束后，由对象的析构函数来销毁。
对象所关联的类型（type_info），通常放在`virtual table`的第一个`slot`中。

虚继承：在继承定义中包含了`virtual`关键字的继承关系；
虚基类：在虚继承体系中的通过`virtual`继承而来的基类，需要注意的是：

`class CDerive : public virtual CBase {}; `其中`CBase`称之为`CDerive`的虚基类，而不是说`CBase`就是个虚基类，因为`CBase`还可以为不是虚继承体系中的基类。

虚函数被派生后，仍然为虚函数，即使在派生类中省去`virtual`关键字。

虚基类的构造与析构是由最终子类负责调用的（而不是直接派生子类）

## 对象内存布局分类讨论

vc6变量查看器中（Locals，Watch1等），也可以看到部分对象布局的情况（不完整，且虚继承是错误的）。

vs2005及以后版本的编译器提供了`/d1reportSingleClassLayout[类名]`编译选项来查看对象完整的内存布局：

```md
cl classLayout.cpp /d1reportSingleClassLayoutCChildren
```

### 单一类

#### 空类

<img src="https://images0.cnblogs.com/blog/78946/201301/20161511-1866d713a7f0496780bc009bade8a9dd.png" alt="img" style="zoom:67%;" />

```cpp
sizeof(CNull)=1;//用于标识该对象
```

#### 只有成员变量的类

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20161852-eded6e6e00104d70a5006c8bdfabc8d5.png" alt="img" style="zoom:67%;" /></center>

```cpp
int nVarSize = sizeof(CVariable) = 12;
```

<center> <img src="https://images0.cnblogs.com/blog/78946/201301/20123116-50ef736604fe4a11b11c855988aa6aed.png" alt="img" style="zoom:80%;" /></center>

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20185827-e8d325e53dff40868260b0caa5d8f0e5.png" alt="img" style="zoom:80%;" />

#### 只有虚函数的类

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20162224-8dd974c9f2eb402fb4ee934f8f22e7fa.png" alt="img" style="zoom:67%;" />

```cpp
int nVFuntionSize = sizeof(CVFuction) = 4;//虚表指针
```

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20123423-5770117b4e5247a9ae7e0e32268fd65e.png" alt="img" style="zoom:80%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20190542-19448cec698840069f24334afa858213.png" alt="img" style="zoom:80%;" />

#### 有成员变量、虚函数的类

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20162737-04470e088b97430eb1a86207c0c344cd.png" alt="img" style="zoom:67%;" />

```cpp
int nParentSize = sizeof(CParent) = 8;
```

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20191121-010e66669acf456186803ff839dcd048.png" alt="img" style="zoom:80%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20191007-da15a78a8e4d48469ae59f3528cfba7d.png" alt="img" style="zoom:80%;" />

### 单一继承（含成员变量、虚函数、虚函数覆盖）

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20192826-ab5150ea811844f38f0392a1b85075a4.png" alt="img" style="zoom:67%;" />

```cpp
int nChildSize = sizeof(CChildren) = 12;
```

vc中显示的结果（注：还有1个虚函数`CChildren::g1`没有被显示出来）：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20192154-f2055b9755cb49788b0fa66f5c86a3bf.png" alt="img" style="zoom:80%;" />

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27120846-3f36962313604194be3afd4ce0435b48.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20195722-7b59876a02da4840be19807bb74ba374.png" alt="img" style="zoom:80%;" />

### 多继承 （含成员变量、虚函数、虚函数覆盖）

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20194809-ff8b1c34ca0f4516b2889f6077bb5065.png" alt="img" style="zoom:67%;" />

```cpp
int nChildSize = sizeof(CChildren) = 20;
```

vc中显示的结果（注：还有2个虚函数`CChildren::f2`，`CChildren::h2`没有被显示出来，`this`指针的`adjustor`[调整值]也没打印出）：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20193849-5dd1ed6546224f15b8b4f46597c70029.png" alt="img" style="zoom:80%;" />

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27121206-27a4eaedddc04228b8fcd2d673ccc5c5.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20195528-bc778d9884b9443586e326619e2afc18.png" alt="img" style="zoom:80%;" />

### 深度为2的继承（含成员变量、虚函数、虚函数覆盖）

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20201343-cd8b42e4891a45049f0bc51a7b9bcba1.png" alt="img" style="zoom:67%;" />

```cpp
int nGrandSize = sizeof(CGrandChildren) = 24;
```

vc中显示的结果（注：还有3个虚函数`CGrandChildren::f2`，`CChildren::h2`，`CGrandChildren::f3`没有显示出来，`this`指针的`adjustor`[调整值]也没打印出）：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20201638-d5ba2490b38d47d68fd66429bee4666d.png" alt="img" style="zoom:80%;" />

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27121733-1bb2ca5c65cc4324bd042b9c35bdfc43.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20202629-6c67cc62beec44299fcde9c24fc1bbd1.png" alt="img" style="zoom:80%;" />

### 重复继承（含成员变量、虚函数、虚函数覆盖）

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20233722-923833f1aabd410a9d7eaa10539bc05b.png" alt="img" style="zoom:67%;" />

```cpp
int nGrandSize = sizeof(CGrandChildren) = 28;
```

vc中显示的结果（注：还有大量的虚函数没有显示出来，`this`指针的`adjustor`[调整值]也没打印出）：

`thunk`函数：一种形实转换辅助函数；主要做`this`指针调整，函数调用重定向。

<center><img src="https://images0.cnblogs.com/blog/78946/201301/20233815-4c1f20af25a146c4a2eed8a5a7028aee.png" alt="img" style="zoom:80%;" />

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27133845-16bff4cf175b43c6b5e5efd1f7a0f48b.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27134649-f1af0fa22b534a5da0076f70746b3a57.png" alt="img" style="zoom:80%;" />

由于`m_nAge`在内容中存在两个拷贝，因此我们不能直接通过`pGrandChildrenA->m_nAge`来访问该变量，

这样会存在二义性，编译器无法知道应该访问`CChildren1`中的`m_nAge`，还是`CChildren2中的m_nAge`。

为了标识唯一的`m_nAge`，就需要带上其所在范围的类名了。如下：

```cpp
1 pGrandChildrenA->CChildren1::m_nAge = 1;
2 pGrandChildrenA->CChildren2::m_nAge = 2;
```

### 单一虚继承（含成员变量、虚函数、虚函数覆盖）

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27142533-002c68535a4a463da49c7f149ddbdcb7.png" alt="img" style="zoom:67%;" />

```cpp
int nChildSize = sizeof(CChildren) = 20;
```

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27143035-dfed0c325f6049e7a083339187d34eb0.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27154246-54ba3f1cc4cb4af995cad6a1d1c409f4.png" alt="img" style="zoom:80%;" />

### 多虚继承（含成员变量、虚函数、虚函数覆盖）

#### `virtual CParent1`, `CParent2`

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27160655-89c81bec9ff44976bd18ca3bb155c3c7.png" alt="img" style="zoom:67%;" />

```cpp
int nChildSize = sizeof(CChildren) = 24;
```

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27160246-6dbae00a46ac4e1bacb618790c8d97f4.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27161739-e36a050cd15f45bfab9102e3798f869e.png" alt="img" style="zoom:80%;" />

#### `CParent1`, `virtual CParent2`

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27160708-662f2ad380224a9ca23aa22e6ce14339.png" alt="img" style="zoom:67%;" />

```cpp
int nChildSize = sizeof(CChildren) = 24
```

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27160311-8bdcc85344a8489c8ef9cf31b68811a7.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27162255-80ac349691ed4d79bd85f080ea0b2374.png" alt="img" style="zoom:80%;" />

#### `virtual CParent1`, `virtual CParent2`

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27160722-f5a4b0bae44c4349a059c3896374fadf.png" alt="img" style="zoom:67%;" />

```cpp
int nChildSize = sizeof(CChildren) = 28;
```

d1reportSingleClass查看：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27160353-5fe2320ad5c548e5a612e9741e4ea223.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27163043-eda211cc4bb64d1da3774b1ba397bebc.png" alt="img" style="zoom: 80%;" />
### 钻石型的虚拟多重继承（含成员变量、虚函数、虚函数覆盖）

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27163844-d4287a5050cf4b2b9c0c32a21338ff2f.png" alt="img" style="zoom:67%;" />

```cpp
int nGrandChildSize = sizeof(CGrandChildren) = 36;
```

d1reportSingleClass查看：

`thunk`函数：一种形实转换辅助函数；主要做`this`指针调整，函数调用重定向。

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27164403-1bcf8354b3724e6aa19e67e781337e5f.png" alt="img" style="zoom:67%;" />

内存布局：

<center><img src="https://images0.cnblogs.com/blog/78946/201301/27165612-e0b8e91bc6b645e6a765aa6df4c856b4.png" alt="img" style="zoom:80%;" />

