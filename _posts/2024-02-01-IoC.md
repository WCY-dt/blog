---
layout: post
title:  "IoC"
date:   2024-02-01 00:00:00 +0800
categories: 编程
tags: java spring
series: 深入 Spring 源码
series_index: 1
comments: true
copyrights: 原创
---

Spring 是一个开源的轻量级 JavaEE 框架。它的核心是控制反转（IoC）和面向切面编程（AOP）。Spring 的 IoC 容器负责管理 JavaBean 的生命周期，而 AOP 容器负责管理切面。Spring 还提供了一系列的模块，如 Spring MVC、Spring JDBC、Spring Security 等。

## Spring

![Spring 架构图](/assets/post/images/spring3.webp)

这张图有点老旧了，还是 4.x 版本的，不过总体上还是没什么变化。

总体上来讲，Spring 分为以下几个部分：

- **核心技术（Core Technologies）**

  - IoC Container：负责管理 JavaBean 的生命周期
  - Resources：资源管理
  - Validation, Data binding, Type conversion：数据验证、数据绑定、类型转换
  - SpEL：Spring 表达式语言
  - AOP：面向切面编程

- **数据访问（Data Access）**

  - Transactions：事务管理
  - DAO support：数据访问支持
  - JDBC：JDBC 支持
  - ORM：对象关系映射支持

- **Web**

  - Servlet

    - Web MVC
    - REST
    - WebSocket

  - Web Reactive

    - WebFlux
    - WebClient
    - WebSocket

- **Testing**

- **Integration**

除此之外，Spring 拥有非常丰富的生态系统，例如：

- Spring Boot：简化 Spring 的配置和使用
- Spring Cloud：微服务架构
- Spring Security：安全框架

等等。  

## IoC

### 为什么需要 IoC

在实际开发中，常常会用到三层架构。

<details>
<summary>点击查看三层架构基础</summary>
<div markdown="1">

三层架构是一种软件开发的设计模式，它将应用程序分为三个主要层次：

- **控制器层（Controller）**：负责与用户进行交互，展示数据，并接收用户输入。例如网页前端、移动应用的用户界面等。
- **业务逻辑层（Service）**：处理应用程序的核心功能和业务规则。例如应用程序的中间层代码，包含处理用户请求、验证输入、执行算法等逻辑。
- **持久层（Dao）**：负责与数据库或其他数据存储系统进行交互。例如数据访问对象，负责执行数据库查询、插入、更新和删除操作的代码。

假设我们在开发一个网上书店系统，可以将系统划分为以下三个层次：

- 控制器层：负责显示商品列表、搜索结果、商品详情页等。

  ```java
  public class BookControllerImpl implements BookController {
      private BookService bookService = new BookServiceImpl();

      public void listBooks() {
          List<Book> books = bookService.listBooks();
          
          for (Book book : books) {
              System.out.println(book);
          }
      }
  }
  ```

- 业务逻辑层：处理用户搜索商品、添加商品到购物车、下单等操作。

  ```java
  public class BookServiceImpl implements BookService {
      private BookDao bookDao = new BookDaoImpl();

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

- 持久层：与数据库交互，查询商品信息、保存订单信息等。

  ```java
  public class BookDaoImpl implements BookDao {
      public List<Book> listBooks() {
          // 查询数据库，返回商品列表
          return new ArrayList<>();
      }
  }
  ```

在逻辑上，这三层应该是一个倒金字塔型：大量控制器层调用少量业务逻辑层，持久层最少：

![倒金字塔型](/assets/post/images/spring1.svg)

</div>
</details>

这样的简单写法有几个问题：

- **资源浪费**

  在实际实现中，由于每个 `BookControllerImpl` 都使用 `new` 创建了新的 `BookServiceImpl` 实例、每个 `BookServiceImpl` 都使用 `new` 创建了新的 `BookDaoImpl` 实例，导致了每个控制器层组件都挂了一个金字塔型的结构：

  <img src="/assets/post/images/spring2.svg" alt="金字塔型" style="max-width: calc(min(100%, 450px));">

  这造成了极大的浪费——因为我们知道，`BookDaoImpl` 很可能只需要一个实例就够用，而不是每个 `BookServiceImpl` 都创建一个实例。

- **耦合度高**

  由于每个层次都直接依赖于下一层次，导致了耦合度过高。假如 `BookDaoImpl` 需要更换为 `BookDaoAnotherImpl`，那么每一个原来依赖于 `BookDaoImpl` 的类都需要进行修改。

- **初始化和配置麻烦**

  由于每个层次都需要手动创建下一层次的实例，导致了初始化和配置的麻烦。例如配置一个 JDBC 需要：

  ```java
  dataSource = new DataSource();
  dataSource.setUrl("jdbc:mysql://localhost:3306/bookstore");
  dataSource.setUsername("root");
  dataSource.setPassword("password");
  dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
  ```

  目前的方法下，每个 `BookDaoImpl` 都需要写这么长一串，而且如果数据库地址、用户名、密码等信息发生变化，每个 `BookDaoImpl` 都需要修改。

- **测试困难**

  由于每个层次都直接依赖于下一层次，导致了测试困难。例如，如果要测试 `BookControllerImpl`，就需要让 `BookServiceImpl` 和 `BookDaoImpl` 也参与测试。

  这样的测试方式不仅耗时，而且会导致测试结果不稳定。因为 `BookServiceImpl` 和 `BookDaoImpl` 的实现可能会影响 `BookControllerImpl` 的测试结果。

至此，IoC 的想法已经呼之欲出了：将对象的创建、配置和管理交给容器，使其与对象的使用解耦。

- 对于资源浪费的问题，IoC 容器默认使用**单例模式**，保证只有一个实例
- 对于耦合度高的问题，当需要更换实现类时，名称可以保持不变，只需要修改配置文件中对应的实现类即可
- 对于初始化和配置麻烦的问题，只需要在配置文件中配置一次，容器会自动读取配置文件并创建对象
- 对于测试困难的问题，只需要将测试对象注入到容器中，容器会自动创建依赖的对象

> 这让我想到了前端常用的状态管理库，例如 Redux 和 Pinia 等。这些库的核心思想也是如此：将对象的创建、配置和管理交给库，使其与对象的使用解耦。

### IoC 容器

Spring 的 IoC 容器是一个对象工厂，负责创建、配置和管理对象。在 IoC 容器中，对象被称为 Bean。

> 我们回顾一下工厂模式。
>
> 工厂模式是一种创建对象的设计模式，它提供了一个创建对象的接口，而不需要指定具体的类。
>
> 在 IoC 中，产品就是具体的类（或者说是 Bean），工厂就是 IoC 容器。客户端只需要向 IoC 容器请求某个类型的 Bean，而不需要指定具体的类。Bean 的生产和管理都交给 IoC 容器负责，客户端只需要关心 Bean 的使用。

Spring 提供了两种 IoC 容器：`BeanFactory` 和 `ApplicationContext`。其中：

- `BeanFactory` 是 Spring 的基础容器，如果没有特殊需求一般不用
- `ApplicationContext` 是 `BeanFactory` 的子接口，提供了更多的功能，一般使用 `ApplicationContext`

例如，我们有一个 `Book` 类：

```java
package com.example;

public class Book {
    private String title;
    private String author;

    public Book() {
    }

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    @Override
    public String toString() {
        return "Book{" +
                "title='" + title + '\'' +
                ", author='" + author + '\'' +
                '}';
    }
}
```

在未使用 IoC 容器时，我们需要手动创建 `Book` 对象：

```java
package com.example;

public class TestBook {
    @Test
    public void testBook() {
        Book book = new Book("Spring", "Rod Johnson");
        System.out.println(book);
    }
}
```

使用 IoC 容器后，我们则需要完成以下步骤：

- 创建一个配置文件。例如叫 `Beans.xml`，配置 `Book` 类：

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  
      <bean id="book" class="com.example.Book">
          <property name="title" value="Spring"/>
          <property name="author" value="Rod Johnson"/>
      </bean>
  
  </beans>
  ```

  这会将类和对应的属性都配置在 XML 文件中，形成一个 Bean 定义。

- 创建一个 `ApplicationContext` 对象，并从配置文件中读取 `book` 对象：

  ```java
  package com.example;

  import org.springframework.context.ApplicationContext;
  import org.springframework.context.support.ClassPathXmlApplicationContext;

  public class TestBook {
      @Test
      public void testBook() {
          ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
          Book book = (Book) context.getBean("book");
          System.out.println(book);
      }
  }
  ```

  > 我们在 JVM 中讨论过类加载器的概念。
  >
  > 这里，我们相当于使用了当前线程的上下文类加载器，它会从 `classpath` 中加载 `Beans.xml` 文件。
  >
  > 在加载后，会完成 IoC 容器的完整初始化过程。

这样，我们就使用 IoC 容器创建了 `Book` 对象。

### 依赖注入

依赖注入（Dependency Injection，DI）是一种设计模式，被用于实现**控制反转**。

它通过将对象的依赖关系从代码中移除，转而由外部容器（如 Spring）在运行时注入。它主要有三种方式：

- 构造器注入
- setter 方法注入
- 字段注入（不推荐，因为破坏了封装性）

具体来讲，在 XML 配置中，这样使用：

#### 构造器注入

构造器注入是通过构造器来注入依赖的。上面的例子中我们定义了有参构造函数 `Book(String title, String author)`，可以通过 `constructor-arg` 元素来注入依赖：

```xml
<bean id="book" class="com.example.Book">
    <constructor-arg name="title" value="Spring"/>
    <constructor-arg name="author" value="Rod Johnson"/>
</bean>
```

Spring 会自动调用 `Book` 类的有参构造函数，将 `title` 和 `author` 参数传入。

#### setter 方法注入

setter 方法注入是通过 setter 方法来注入依赖的。例如，在上一节的例子中，我们通过 `property` 元素来注入 `title` 和 `author` 字段：

```xml
<bean id="book" class="com.example.Book">
    <property name="title" value="Spring"/>
    <property name="author" value="Rod Johnson"/>
</bean>
```

Spring 会自动调用 `Book` 类的 `setTitle` 和 `setAuthor` 方法，将 `title` 和 `author` 字段注入到 `Book` 对象中。

#### 字段注入

字段注入是通过字段的 setter 方法来注入依赖的。例如，在上一节的例子中，我们通过 `property` 元素来注入 `title` 和 `author` vv：

```xml
<bean id="book" class="com.example.Book">
    <property name="title" value="Spring"/>
    <property name="author" value="Rod Johnson"/>
</bean>
```

Spring 会自动调用 `Book` 类的 `setTitle` 和 `setAuthor` 方法，将 `title` 和 `author` 属性注入到 `Book` 对象中。

#### 特殊值的注入

这当中有一些细节需要注意：

- **特殊值注入**

  - 如果需要注入 `null`，可以使用 `<null/>` 元素：

    ```xml
    <property name="title">
        <null/>
    </property>
    ```

  - 如果字符串中包含特殊字符，可以使用 `<![CDATA[]]>` 来包裹：

    ```xml
    <property name="title">
        <value><![CDATA[Spring & Hibernate]]></value>
    </property>
    ```

    也可以使用 HTML 转义字符：

    ```xml
    <property name="title">
        <value>Spring &amp; Hibernate</value>
    </property>
    ```

- **引用注入**

  如果需要注入另一个 Bean，可以使用 `ref` 属性：

  ```xml
  <bean id="author" class="com.example.Author">
      <property name="name" value="Rod Johnson"/>
  </bean>

  <bean id="book" class="com.example.Book">
      <property name="title" value="Spring"/>
      <property name="author" ref="author"/>
  </bean>  
  ```

  这也可以写成：

  ```xml
  <bean id="book" class="com.example.Book">
      <property name="title" value="Spring"/>
      <property name="author">
          <ref bean="author"/>
      </property>
  </bean>
  ```

  当然，也可以直接写在内部：

  ```xml
  <bean id="book" class="com.example.Book">
      <property name="title" value="Spring"/>
      <property name="author">
          <bean class="com.example.Author">
              <property name="name" value="Rod Johnson"/>
          </bean>
      </property>
  </bean>
  ```

- **集合注入**

  如果需要注入集合，可以使用 `list`、`set`、`map`、`props` 等元素：

  ```xml
  <bean id="book" class="com.example.Book">
      <property name="authors">
          <list>
              <value>Rod Johnson</value>
              <value>Juergen Hoeller</value>
              <value>Keith Donald</value>
          </list>
      </property>
  </bean>
  ```

  ```xml
  <bean id="book" class="com.example.Book">
      <property name="authors">
          <set>
              <value>Rod Johnson</value>
              <value>Juergen Hoeller</value>
              <value>Keith Donald</value>
          </set>
      </property>
  </bean>
  ```

  ```xml
  <bean id="book" class="com.example.Book">
      <property name="authors">
          <map>
              <entry key="Rod Johnson" value="Spring"/>
              <entry key="Juergen Hoeller" value="Spring Boot"/>
              <entry key="Keith Donald" value="Spring Cloud"/>
          </map>
      </property>
  </bean>
  ```

  ```xml
  <bean id="book" class="com.example.Book">
      <property name="authors">
          <props>
              <prop key="Rod Johnson">Spring</prop>
              <prop key="Juergen Hoeller">Spring Boot</prop>
              <prop key="Keith Donald">Spring Cloud</prop>
          </props>
      </property>
  </bean>
  ```

- **p 命名空间**

  Spring 提供了 `p` 命名空间，可以简化属性注入。

  首先需要在配置文件中引入 `p` 命名空间：

  ```xml
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:p="http://www.springframework.org/schema/p"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  ```

  然后可以使用 `p` 命名空间来注入属性：

  ```xml
  <bean id="book" class="com.example.Book" p:title="Spring" p:author="Rod Johnson"/>
  ```

  这等价于：

  ```xml
  <bean id="book" class="com.example.Book">
      <property name="title" value="Spring"/>
      <property name="author" value="Rod Johnson"/>
  </bean>
  ```

  对于使用 `ref` 属性的情况，也可以使用 `p` 命名空间：

  ```xml
  <bean id="book" class="com.example.Book" p:title="Spring" p:author-ref="author"/>
  ```

### 自动装配

自动装配（Autowiring）是 Spring 对 DI 的一种实现方式。它可以自动识别 Bean 之间的依赖关系，从而省去了手动配置 Bean 之间的依赖关系。

Spring 提供了以下几种自动装配的方式：

- **no**

  默认值，不自动装配。需要手动配置 Bean 之间的依赖关系。

- **byName**

  根据 Bean 的名称自动装配。Spring 会自动查找与属性名相同的 Bean，并将其注入。例如：

  ```xml
  <bean id="author" class="com.example.Author">
      <property name="name" value="Rod Johnson"/>
  </bean>

  <bean id="book" class="com.example.Book">
      <property name="author" ref="author"/>
      <property name="title" value="Spring"/>
  </bean>
  ```

  最后一条可以被写为：

  ```xml
  <bean id="book" class="com.example.Book" autowire="byName">
      <property name="title" value="Spring"/>
  </bean>
  ```

  可以看到，`author` 与 `Book` 的属性名相同，Spring 会自动查找 `author` Bean，并将其注入到 `Book` 对象中。

- **byType**

  根据 Bean 的类型自动装配。Spring 会自动查找与字段类型相同的 Bean，并将其注入。

  同样的，最后一条可以被写为：

  ```xml
  <bean id="book" class="com.example.Book" autowire="byType">
      <property name="title" value="Spring"/>
  </bean>
  ```

  如果有多个 Bean 的类型相同，Spring 会抛出异常。可以使用 `@Primary` 注解来指定首选 Bean。

- **constructor**

  根据构造器参数类型自动装配。Spring 会自动查找与构造器参数类型相同的 Bean，并将其注入。
  
  例如，`Book` 类有一个构造器 `Book(Author author, String title)`，可以写为：

  ```xml
  <bean id="book" class="com.example.Book" autowire="constructor">
      <constructor-arg value="Spring"/>
  </bean>
  ```

  Spring 会自动查找 `Author` 类型的 Bean，并将其注入到 `Book` 对象中。

### 基于注解的配置

以上我们都在使用 XML 文件来配置 Bean，Spring 也支持使用注解来配置 Bean。

假设我们有两个实现类 `BookServiceImpl` 和 `BookDaoImpl`：

```java
public class BookServiceImpl implements BookService {
    private BookDao bookDao = new BookDaoImpl();

    public List<Book> listBooks() {
        return bookDao.listBooks();
    }
}
```

```java
public class BookDaoImpl implements BookDao {
    public List<Book> listBooks() {
        // 查询数据库，返回商品列表
        return new ArrayList<>();
    }
}
```

其中，`BookServiceImpl` 依赖于 `BookDaoImpl`。

#### 启用注解扫描

为了实现 IoC，首先需要启用注解扫描。这有两种方法：

- **XML 文件**

  在 XML 文件中添加以下配置：

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    
        <context:component-scan base-package="com.example"/>

  </beans>
  ```

  其中 `base-package` 属性指定了要扫描的包。

- **Java 配置类**

  也可以使用 Java 配置类来启用注解扫描：

  以上我们依然用到了部分 XML 配置，Spring 也提供了完全基于注解的配置。例如，我们可以使用 `@Configuration` 注解来标记配置类：

  ```java
  @Configuration
  @ComponentScan(basePackages = "com.example")
  public class AppConfig {
  }
  ```

  其中，`@Configuration` 注解标记了一个配置类，`@ComponentScan` 注解启用了注解扫描。

  此时，使用时不再需要加载 XML 文件，而是直接加载配置类：

  ```java
  public class TestBook {
      @Test
      public void testBook() {
          ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
          Book book = context.getBean(Book.class);
          System.out.println(book);
      }
  }
  ```

  这样，我们就完全使用注解来配置 Bean 了。

#### 注册 Bean

然后可以使用注解，注册为 Bean：

```java
@Service
public class BookServiceImpl implements BookService {
    private BookDao bookDao = new BookDaoImpl();

    public List<Book> listBooks() {
        return bookDao.listBooks();
    }
}
```

```java
@Repository
public class BookDaoImpl implements BookDao {
    public List<Book> listBooks() {
        // 查询数据库，返回商品列表
        return new ArrayList<>();
    }
}
```

这里有两个需要说明的地方：

- `@Component` 注解是 Spring 的通用注解，可以用于任何类。Spring 还提供了一些更具体的注解，如
  - `@Repository`：持久层
  - `@Service`：业务逻辑层
  - `@Controller`：控制器层
- 生成的 Bean 的名称默认为类名的首字母小写，可以使用 `@Component(value = "book")` 来指定 Bean 的名称

当然，你也可以直接将 Bean 类写进配置类中：

```java
@Configuration
public class AppConfig {
    @Bean
    public BookService bookService() {
        return new BookServiceImpl();
    }

    @Bean
    public BookDao bookDao() {
        return new BookDaoImpl();
    }
}
```

它们需要使用 `@Bean` 注解来标记这是一个 Bean。

#### 属性注入

注册类为 Bean 后，就可以向其中注入属性了。

如果注入的是另一个 Bean，可以使用 `@Autowired` 注解。例如，要想将 `BookDaoImpl` 注入到 `BookServiceImpl` 中，有这样几种方法：

- **构造器注入**

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      private BookDao bookDao;

      @Autowired
      public BookServiceImpl(BookDao bookDao) {
          this.bookDao = bookDao;
      }

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

  如果写在形参上也是可以的：

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      private BookDao bookDao;

      public BookServiceImpl(@Autowired BookDao bookDao) {
          this.bookDao = bookDao;
      }

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

  如果只有一个构造器，`@Autowired` 可以省略。

  - **setter 方法注入**

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      private BookDao bookDao;

      @Autowired
      public void setBookDao(BookDao bookDao) {
          this.bookDao = bookDao;
      }

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

- **字段注入**

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      @Autowired
      private BookDao bookDao;

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

这里有两个比较特殊的：

- **`@Qualifier` 注解注入**

  `@Autowired` 默认按类型注入，如果有多个 Bean 的类型相同（例如 `BookDao` 接口有多个实现），可以使用 `@Qualifier` 注解来指定 Bean 的名称：

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      @Autowired
      @Qualifier("bookDaoImpl")
      private BookDao bookDao;

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

  这里的 `bookDaoImpl` 是 `BookDaoImpl` 类的 Bean 名称。

- **`@Resource` 注解注入**

  与 `@Autowired` 不同，`@Resource` 注解是 JDK 扩展包中的，它默认按名称注入，如果找不到名称则按照类型注入。它只能被用在字段或者 setter 方法上：

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      @Resource(name = "bookDaoImpl")
      private BookDao bookDao;

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

  这里的 `bookDaoImpl` 是 `BookDaoImpl` 类的 Bean 名称。

对于非 Bean 的字段（例如基本类型、String 类型等），可以使用 `@Value` 注解注入：

- **`@Value` 注解注入**

  `@Value` 注解可以用来注入基本类型、String 类型、数组、集合等。例如：

  ```java
  @Component
  public class Book {
      @Value("Spring")
      private String title;

      @Value("Rod Johnson")
      private String author;

      @Value("${book.price}")
      private double price;

      @Value("${book.authors}")
      private String[] authors;

      @Value("#{${book.authors}}")
      private List<String> authorsList;
  }
  ```

  这里有几个需要注意的地方：

  - 如果需要注入的是一个基本类型，可以直接写在 `@Value` 注解中
  - 如果需要注入的是一个 SpEL 表达式，可以使用 `#{}` 包裹，它会在运行时计算表达式的值，通常用于数组、集合等
  - 如果需要注入的是一个外部配置文件中的值，可以使用 `${}` 包裹，它会在运行时读取配置文件中的值

### 生命周期

Bean 的生命周期是指 Bean 从创建到销毁的过程。Spring 提供了多种方式来管理 Bean 的生命周期。

Spring 找到、创建、管理和销毁一个 Bean 的大致流程为：

1. 扫描包，获取所有资源
2. 解析资源，获取 BeanDefinition
3. 管理 Bean 的生命周期
    1. 实例化
    2. 填充属性
    3. 初始化
      - `@PostConstruct`
      - `InitializingBean.afterPropertiesSet()`
      - `@Bean(initMethod = "init")`
    4. 自由使用
    5. 销毁
      - `@PreDestroy`
      - `DisposableBean.destroy()`
      - `@Bean(destroyMethod = "destroy")`

之所以显得如此复杂，是因为它要考虑到很多问题，比如：

- BeanFactory 和 ApplicationContext 的区别
- XML 和注解两种配置方式
- Bean 的作用域
- 多种依赖注入方式
- BeanPostProcessor
- 父子容器

其中，很多东西（比如 BeanFactory）根本没什么人用，纯纯的历史包袱，目前已经被标记为弃用了。

#### 初始化方法

- 可以使用 `@PostConstruct` 注解来标记初始化方法：

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      @PostConstruct
      public void init() {
          System.out.println("BookServiceImpl initialized");
      }

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

- 如果是定义在配置类中的 Bean，可以使用 `@Bean(initMethod = "init")` 来指定初始化方法：

  ```java
  @Configuration
  public class AppConfig {
      @Bean(initMethod = "init")
      public BookService bookService() {
          return new BookServiceImpl();
      }
  }
  ```

- 实现 `InitializingBean.afterPropertiesSet()` 方法也可以用来标记初始化方法：

  ```java
  @Service
  public class BookServiceImpl implements BookService, InitializingBean {
      @Override
      public void afterPropertiesSet() throws Exception {
          System.out.println("BookServiceImpl initialized");
      }

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

#### 销毁方法

- 可以使用 `@PreDestroy` 注解来标记销毁方法：

  ```java
  @Service
  public class BookServiceImpl implements BookService {
      @PreDestroy
      public void destroy() {
          System.out.println("BookServiceImpl destroyed");
      }

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

- 如果是定义在配置类中的 Bean，可以使用 `@Bean(destroyMethod = "destroy")` 来指定销毁方法：

  ```java
  @Configuration
  public class AppConfig {
      @Bean(destroyMethod = "destroy")
      public BookService bookService() {
          return new BookServiceImpl();
      }
  }
  ```

- 实现 `DisposableBean.destroy()` 方法也可以用来标记销毁方法：

  ```java
  @Service
  public class BookServiceImpl implements BookService, DisposableBean {
      @Override
      public void destroy() throws Exception {
          System.out.println("BookServiceImpl destroyed");
      }

      public List<Book> listBooks() {
          return bookDao.listBooks();
      }
  }
  ```

#### PostProcessor

`BeanPostProcessor` 是 Spring 提供的一个接口，可以用来在 Bean 初始化前后执行一些操作。它有两个方法：

- `postProcessBeforeInitialization(Object bean, String beanName)`：在 Bean 初始化前执行
- `postProcessAfterInitialization(Object bean, String beanName)`：在 Bean 初始化后执行

例如，我们可以实现一个 `BeanPostProcessor`，在 Bean 初始化前后打印日志：

```java
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Before initialization: " + beanName);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("After initialization: " + beanName);
        return bean;
    }
}
```

这个东西会在下一篇 AOP 中用到，现在先不管。

### 其它问题

#### 循环依赖

此外，我们还看到了处理循环依赖的方法。Spring 解决了单例模式下，setter 注入的循环依赖问题。解决的方式是通过三级缓存：

- 创建 A
  - 实例化 A：调用 A 的构造方法，生成一个原始对象（未注入属性）
  - 将A的工厂放入三级缓存：将生成A原始对象的 `ObjectFactory` 存入三级缓存（`singletonFactories`）
  - 填充属性 B：发现 A 依赖 B，尝试从缓存获取 B，但 B 未创建，触发创建 B
- 创建 B
  - 实例化 B：生成 B 的原始对象
  - 将 B 的工厂放入三级缓存
  - 填充属性 A：发现 B 依赖 A，尝试从缓存获取 A：
    - 从三级缓存中找到 A 的 `ObjectFactory`，调用其 `getObject()` 方法获取 A 的早期引用（可能经过 AOP 代理）
    - 将 A 的早期引用放入二级缓存（`earlySingletonObjects`），并清理三级缓存中的 A 工厂
- 完成 B 的初始化
  - 属性填充完成：B 中的 A 属性已被注入（早期引用）
  - 执行初始化逻辑（如 `@PostConstruct`）
  - 将 B 放入一级缓存：B 成为完整 Bean，存入 `singletonObjects`
- 完成 `A` 的初始化
  - 注入 B 的完整实例：此时 B 已在一级缓存中，A 的 B 属性被注入
  - 执行初始化逻辑
  - 将 A 从二级缓存移除，存入一级缓存

可以看到，解决的前提是已经实例化。这就是为什么 Spring 只解决 setter 注入的循环依赖，而不解决构造函数注入的循环依赖。

#### 作用域

Spring 提供了多种作用域来管理 Bean 的生命周期：

- singleton：单例模式，默认值。Spring 容器只会创建一个 Bean 实例，并在整个应用程序中共享。
- prototype：原型模式。每次从容器中获取 Bean 时，都会创建一个新的 Bean 实例。
- request：请求作用域。每次 HTTP 请求都会创建一个新的 Bean 实例。仅在 Web 应用程序中有效。
- session：会话作用域。每个 HTTP 会话都会创建一个新的 Bean 实例。仅在 Web 应用程序中有效。
- globalSession：全局会话作用域。每个全局 HTTP 会话都会创建一个新的 Bean 实例。仅在 Web 应用程序中有效。

可以使用 `@Scope` 注解来指定 Bean 的作用域：

```java
@Service
@Scope("prototype")
public class BookServiceImpl implements BookService {
    public List<Book> listBooks() {
        return bookDao.listBooks();
    }
}
```

通常来讲，只会用到 `singleton` 这一种。

## IoC 源码解读

![IoC 关键类](/assets/post/images/spring4.webp)

IoC 最核心的思想包括了以下两点：

- **控制反转**：将对象的创建和管理交给 Spring 容器，而不是由其它对象来管理。Spring 容器会在特定的生命周期事件（如初始化、销毁）发生时，自动调用对象的相应方法
- **依赖查找 & 依赖注入**：通过依赖查找来获取对象的引用，通过依赖注入来将对象注入到其它对象中，而不是由对象自身来获取它的依赖

方便起见，我们只看注解配置的 IoC 容器。

源码我们从 `AnnotationConfigApplicationContext` 开始。我们最常用的构造函数是 `AnnotationConfigApplicationContext(String... basePackages)`：

```java
public AnnotationConfigApplicationContext(String... basePackages) {
    this();
    scan(basePackages);
    refresh();
}
```

它一共分了三步：

### 构造方法

<details>
<summary>点击查看构造方法源码解读</summary>
<div markdown="1">

`this()` 当然是先调用 `AnnotationConfigApplicationContext()` 构造函数：

```java
public AnnotationConfigApplicationContext() {
    StartupStep createAnnotatedBeanDefReader = getApplicationStartup().start("spring.context.annotated-bean-reader.create");
    // 注解 Bean 读取器
    this.reader = new AnnotatedBeanDefinitionReader(this);
    createAnnotatedBeanDefReader.end();
    // 注解 Bean 扫描器
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}
```

同时还会调用父类 `GenericApplicationContext` 的构造函数：

```java
public GenericApplicationContext() {
    this.beanFactory = new DefaultListableBeanFactory();
}
```

它会创建一个 `DefaultListableBeanFactory` 对象：

```java
public DefaultListableBeanFactory() {
    super();
}
```

这个对象就是默认情况下，用来创建 Bean 的工厂类。

我们看到这玩意儿直接调用了 `AbstractAutowireCapableBeanFactory` 的构造函数：

```java
public AbstractAutowireCapableBeanFactory() {
    super();
    // 忽略 BeanNameAware、BeanFactoryAware、BeanClassLoaderAware 等接口
    ignoreDependencyInterface(BeanNameAware.class);
    ignoreDependencyInterface(BeanFactoryAware.class);
    ignoreDependencyInterface(BeanClassLoaderAware.class);
    // 使用 CGLIB 代理
    this.instantiationStrategy = new CglibSubclassingInstantiationStrategy();
}
```

> BeanNameAware、BeanFactoryAware 和 BeanClassLoaderAware 是 Spring 框架中的三个回调接口，允许 Bean 在初始化阶段获取与容器相关的信息。
>
> - `BeanNameAware`：获取 Bean 的名称
>
>   可以通过实现这个接口的 `setBeanName()` 方法来获取 Bean 的名称
>
>   ```java
>   public class MyBean implements BeanNameAware {
>       private String beanName;
>
>       @Override
>       public void setBeanName(String name) {
>           this.beanName = name;
>       }
>   }
>   ```
>
> - `BeanFactoryAware`：获取 BeanFactory
>
>   可以通过实现这个接口的 `setBeanFactory()` 方法来获取 BeanFactory。这可以帮助我们动态地获取 BeanFactory 中的其他 Bean 或者执行一些与容器相关的操作
>
>   ```java
>   public class MyBean implements BeanFactoryAware {
>       private BeanFactory beanFactory;
>
>       @Override
>       public void setBeanFactory(BeanFactory beanFactory) {
>           this.beanFactory = beanFactory;
>       }
>
>       public void doSomething() {
>           MyOtherBean otherBean = beanFactory.getBean(MyOtherBean.class);
>           // 使用 otherBean 做一些事情
>       }
>   }
>   ```
>
> - `BeanClassLoaderAware`：获取类加载器
>
>   可以通过实现这个接口的 `setBeanClassLoader()` 方法来获取类加载器。这在需要动态加载类或者资源时非常有用，便于实现插件化架构
>
>   ```java
>   public class MyBean implements BeanClassLoaderAware {
>       private ClassLoader classLoader;
>
>       @Override
>       public void setBeanClassLoader(ClassLoader classLoader) {
>           this.classLoader = classLoader;
>       }
>
>       public void loadClass(String className) throws ClassNotFoundException {
>           Class<?> clazz = classLoader.loadClass(className);
>           // 使用 clazz 做一些事情
>       }
>   }
>   ```
>
> 这三个接口的实现类会被忽略掉，Spring 不会对它们进行依赖注入，因为它们会在初始化阶段获取与容器相关的信息，而这时容器还没有完全初始化。

这里的 `super()` 又调用了 `AbstractBeanFactory` 的构造函数，不过这个构造函数是空的。

</div>
</details>

总之，这个构造方法就是实例化了一堆工厂类。没有搞个大新闻。

### 扫描包

<details>
<summary>点击查看扫描包源码解读</summary>
<div markdown="1">

接着调用 `scan(basePackages)` 方法：

```java
@Override
public void scan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    // 扫描包
    StartupStep scanPackages = getApplicationStartup().start("spring.context.base-packages.scan")
        .tag("packages", () -> Arrays.toString(basePackages));
    this.scanner.scan(basePackages);
    scanPackages.end();
}
```

继续看 `ClassPathBeanDefinitionScanner` 的 `scan()` 方法：

```java
public int scan(String... basePackages) {
    // 获取当前 BeanDefinition 的数量
    int beanCountAtScanStart = this.registry.getBeanDefinitionCount();

    // 扫描包
    doScan(basePackages);

    // 注册注解处理器
    if (this.includeAnnotationConfig) {
        AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
    }

    // 返回本次注册的 BeanDefinition 的数量
    return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
}
```

继续看 `doScan()` 方法：

```java
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");

    // BeanDefinitions 使用了一个 LinkedHashSet 来存储扫描到的 BeanDefinition
    // 每个元素都包含了 BeanDefinition 和 Bean 名称的二元组
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();

    // 遍历需要扫描的包
    for (String basePackage : basePackages) {
        // 获取包里所有符合条件的类以供筛选（下文会详细介绍）
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        
        // 遍历候选类
        for (BeanDefinition candidate : candidates) {

            // 获取作用域并绑定
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            candidate.setScope(scopeMetadata.getScopeName());

            // 生成 Bean 名称，如果指定了 Bean 名称则使用指定的名称
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);

            // 对 AbstractBeanDefinition 进行后处理
            if (candidate instanceof AbstractBeanDefinition abstractBeanDefinition) {
                postProcessBeanDefinition(abstractBeanDefinition, beanName);
            }
            // 处理类上的通用注解（如 @Lazy、@Primary、@DependsOn）
            if (candidate instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {
                AnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition);
            }

            // 检查 Bean 是否可以注册
            if (checkCandidate(beanName, candidate)) {

                // 封装 BeanDefinition 和 beanName 到 BeanDefinitionHolder
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                // 根据作用域代理模式生成代理（即处理作用域为 request/session 的 Bean）
                definitionHolder =
                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);

                // 将 BeanDefinitionHolder 加入到结果集，并注册到容器中（下文会详细介绍）
                beanDefinitions.add(definitionHolder);
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
```

这个函数完成了包扫描的主要流程，包括：

1. 遍历所有包路径并找到候选 Bean
2. 为每个候选 Bean 处理其作用域、生成 Bean 名称、后处理 BeanDefinition、处理通用注解
3. 检查 Bean 是否可以注册，如果可以，则应用作用域代理模式（作用域为 request/session）并注册 BeanDefinition
4. 返回注册的 BeanDefinition 集合

接下来，我们来看当中具体的几个方法：

- `findCandidateComponents()` 方法：

  ```java
  public Set<BeanDefinition> findCandidateComponents(String basePackage) {
      // 不存在组件索引 且 检查当前配置的包含过滤器支持索引查询
      if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
          // 执行索引加速扫描（下文会详细介绍）
          return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
      }
      else {
          // 执行常规路径扫描（下文会详细介绍）
          return scanCandidateComponents(basePackage);
      }
  }
  ```

  > 组件索引是 Spring 提供的一种加速扫描的机制。Spring 在编译时生成一个索引文件（`META-INF/spring.components`），记录所有带有特定注解（如 `@Component`）的类，避免运行时扫描类路径。它可以显著加快大型应用的启动速度。

  - `addCandidateComponentsFromIndex()` 方法会直接从索引中获取 Bean。它会：

    1. 先找出属于 `basePackage` 的类
    2. 遍历这些类，检查是否匹配当前的 `includeFilters`，如果匹配则添加到候选类中
    3. 对于匹配的类生成 `ScannedGenericBeanDefinition`

    我们就不细看这个函数了。

  - `scanCandidateComponents()` 方法：

    ```java
    private Set<BeanDefinition> scanCandidateComponents(String basePackage) {
        Set<BeanDefinition> candidates = new LinkedHashSet<>();
        try {
            // ​转换包路径为资源路径，类似 classpath*:com/example/**/*.class
            // 其中，classpath* 表示扫描所有类路径下的资源
            String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                resolveBasePackage(basePackage) + '/' + this.resourcePattern;
            
            // 获取所有 .class 资源（包括 jar 包）
            Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);

            boolean traceEnabled = logger.isTraceEnabled();
            boolean debugEnabled = logger.isDebugEnabled();

            // 遍历资源
            for (Resource resource : resources) {

                // 获取文件名
                String filename = resource.getFilename();

                // 忽略 CGLIB 生成的类（即文件名包含 $$）
                if (filename != null && filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
                    continue;
                }

                if (traceEnabled) {
                    logger.trace("Scanning " + resource);
                }

                try {
                    // 通过反射获取类的元数据
                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);

                    // 根据过滤器包含或排除一些类
                    // 默认包含 @Component、@Service、@Repository、@Controller、@Configuration
                    if (isCandidateComponent(metadataReader)) {

                        // 将类的元数据封装为 ScannedGenericBeanDefinition
                        // 包含了类名、作用域、是否懒加载等信息
                        ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                        sbd.setSource(resource);

                        // 验证类是否符合条件
                        // 必须是具体类、有可实例化的构造方法、如果是内部类则必须为静态类
                        if (isCandidateComponent(sbd)) {
                            if (debugEnabled) {
                                logger.debug("Identified candidate component class: " + resource);
                            }
                            
                            candidates.add(sbd);
                        }

        /* 省略一堆异常处理 */

        return candidates;
    }
    ```

    可以看到，这个方法会：

    1. 将包路径转换为资源路径
    2. 获取所有符合条件的资源，包括 jar 包
    3. 遍历资源，获取类的元数据
    4. 过滤出 `@Component`、`@Service`、`@Repository`、`@Controller`、`@Configuration` 注解的类
    5. 将类的元数据封装为 `ScannedGenericBeanDefinition`（包含了类名、作用域、是否懒加载等信息）
    6. 验证类是否符合条件（必须是具体类、有可实例化的构造方法、如果是内部类则必须为静态类）
    7. 返回符合条件的类

  总体上来讲，这里就是扫描到了所有符合条件的类。

- `registerBeanDefinition()` 方法：

  ```java
  protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) {
      BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
  }
  ```

  继续跟踪 `registerBeanDefinition()` 方法：

  ```java
  public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {

      // 注册主名称的 BeanDefinition
      String beanName = definitionHolder.getBeanName();
      registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

      // 如果存在别名，则注册别名
      String[] aliases = definitionHolder.getAliases();
      if (aliases != null) {
          for (String alias : aliases) {
              registry.registerAlias(beanName, alias);
          }
      }
  }
  ```

  > 别名是 Spring 中的一个概念，用于给 Bean 起一个或多个别名。别名可以用来简化 Bean 的引用，或者提供更具语义性的名称。别名可以这样注册：
  >
  > ```java
  > // 第一个是原始 Bean 的名称，后面都是别名
  > @Bean(name = {"bookService", "alias1", "alias2"})
  > public BookService bookService() {}
  > ```

  这里的 Bean 名称就是我们在上一步获取到的。

  接下来，我们继续关注主名称的注册。`registerBeanDefinition()` 是个接口，我们这里用的 `DefaultListableBeanFactory` 的实现：

  ```java
  @Override
  public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

      Assert.hasText(beanName, "Bean name must not be empty");
      Assert.notNull(beanDefinition, "BeanDefinition must not be null");

      // 校验必要属性是否缺失
      if (beanDefinition instanceof AbstractBeanDefinition abd) {
          try {
              abd.validate();
          }
          catch (BeanDefinitionValidationException ex) {
              throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                  "Validation of bean definition failed", ex);
          }
      }

      //  处理同名 Bean 覆盖
      BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
      if (existingDefinition != null) {
          if (!isBeanDefinitionOverridable(beanName)) {
              throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
          }
          else {
              logBeanDefinitionOverriding(beanName, beanDefinition, existingDefinition);
          }
          // 覆盖 BeanDefinition
          this.beanDefinitionMap.put(beanName, beanDefinition);
      }
      else {
          // 如果 Bean 名称是其它 Bean 的别名
          if (isAlias(beanName)) {
              String aliasedName = canonicalName(beanName);
              if (!isBeanDefinitionOverridable(aliasedName)) {
                  if (containsBeanDefinition(aliasedName)) {
                      throw new BeanDefinitionOverrideException(
                          beanName, beanDefinition, getBeanDefinition(aliasedName));
                  }
                  else {
                      throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                          "Cannot register bean definition for bean '" + beanName +
                          "' since there is already an alias for bean '" + aliasedName + "' bound.");
                  }
              }
              else {
                  if (logger.isInfoEnabled()) {
                      logger.info("Removing alias '" + beanName + "' for bean '" + aliasedName +
                          "' due to registration of bean definition for bean '" + beanName + "': [" +
                          beanDefinition + "]");
                  }
                  removeAlias(beanName);
              }
          }
          
          if (hasBeanCreationStarted()) { // 如果已经有其它的 Bean 在初始化了，需要线程安全操作
              synchronized (this.beanDefinitionMap) {
                  // 将 BeanDefinition 存入 beanDefinitionMap
                  this.beanDefinitionMap.put(beanName, beanDefinition);

                  // 使用 CoW 向 List 添加新 Bean 名称
                  List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                  updatedDefinitions.addAll(this.beanDefinitionNames);
                  updatedDefinitions.add(beanName);
                  this.beanDefinitionNames = updatedDefinitions;

                  // 去掉手动注册的单例 Bean
                  removeManualSingletonName(beanName);
              }
          }
          else { // 如果没有其它的 Bean 在初始化
              // 直接操作
              this.beanDefinitionMap.put(beanName, beanDefinition);
              this.beanDefinitionNames.add(beanName);
              removeManualSingletonName(beanName);
          }

          // 它被用来缓存 BeanDefinitionName，加速查找
          // 重置冻结状态，使得缓存失效
          this.frozenBeanDefinitionNames = null;
      }

      if (existingDefinition != null || containsSingleton(beanName)) {
          // 清除解析过的元数据
          resetBeanDefinition(beanName);
      }
      else if (isConfigurationFrozen()) {
          // 清理按类型查找的缓存
          clearByTypeCache();
      }

      // 记录 @Primary 注解的 Bean 名称
      if (beanDefinition.isPrimary()) {
          this.primaryBeanNames.add(beanName);
      }
  }
  ```

  这个函数考虑了很多问题：

  - 根据覆盖策略，决定是否覆盖已有的 BeanDefinition
  - 如果 Bean 名称是其它 Bean 的别名，则先移除别名
  - 如果已经有其它的 Bean 在初始化，则需要线程安全操作
  - 清除各类缓存
  - 记录 @Primary 注解的 Bean 名称

</div>
</details>

扫描包的过程其实就是将指定包下的类换成 Bean 存储到一个名为 beanDefinitions 的 LinkedHashSet 中，集合的每个元素都包含了 BeanDefinition 和 Bean 名称的二元组。然后，再将其挨个取出检查后放入 beanDefinitionMap。

最终，我们得到的是名字和 BeanDefinition 的映射关系。

### 刷新容器

<details>
<summary>点击查看刷新容器源码解读</summary>
<div markdown="1">

`refresh()` 方法在 `AbstractApplicationContext` 中：

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    // 上锁，防止一个 refresh() 还没结束，另一个 refresh() 就开始了
    this.startupShutdownLock.lock();
    try {
        this.startupShutdownThread = Thread.currentThread();

        StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");

        // 记录容器启动时间、标记为活动状态、检查环境变量等
        prepareRefresh();

        // 获取默认的 DefaultListableBeanFactory
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 准备 BeanFactory
        prepareBeanFactory(beanFactory);

        try {
            // 创建 BeanFactoryPostProcessor
            postProcessBeanFactory(beanFactory);

            StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
            // 调用 postProcessBeanFactory(factory) 方法
            invokeBeanFactoryPostProcessors(beanFactory);
            // 注册 BeanPostProcessor
            registerBeanPostProcessors(beanFactory);
            beanPostProcess.end();

            // 初始化消息源，i18n
            initMessageSource();

            //初始化当前的应用事件广播器
            initApplicationEventMulticaster();

            // 初始化其它特殊的 Bean
            onRefresh();

            // 注册监听器
            registerListeners();

            // 完成 BeanFactory 的初始化
            finishBeanFactoryInitialization(beanFactory);

            // 发布容器刷新完成事件
            finishRefresh();
        }
        catch (RuntimeException | Error ex ) {
            if (logger.isWarnEnabled()) {
                logger.warn("Exception encountered during context initialization - " +
                    "cancelling refresh attempt: " + ex);
            }
            destroyBeans();
            cancelRefresh(ex);
            throw ex;
        }
        finally {
            contextRefresh.end();
        }
    }
    finally {
        // 释放锁
        this.startupShutdownThread = null;
        this.startupShutdownLock.unlock();
    }
}
```

这里面用到了一些辅助函数：

- `prepareRefresh()`

  ```java
  protected void prepareRefresh() {
      // 记录开始时间
      this.startupDate = System.currentTimeMillis();

      // 标记为活动状态
      this.closed.set(false);
      this.active.set(true);

      if (logger.isDebugEnabled()) {
        if (logger.isTraceEnabled()) {
          logger.trace("Refreshing " + this);
        }
        else {
          logger.debug("Refreshing " + getDisplayName());
        }
      }

      // 初始化上下文环境中的占位符属性资源
      initPropertySources();

      // 确认所有必需的属性都能够被解析
      getEnvironment().validateRequiredProperties();

      if (this.earlyApplicationListeners == null) {
        this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
      }
      else {
        this.applicationListeners.clear();
        this.applicationListeners.addAll(this.earlyApplicationListeners);
      }

      this.earlyApplicationEvents = new LinkedHashSet<>();
  }
  ```
- `obtainFreshBeanFactory()`

  ```java
  protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
      // 获取 DefaultListableBeanFactory
      refreshBeanFactory();
      // 返回 BeanFactory
      return getBeanFactory();
  }
  ```

  这里的两个函数都使用了接口，以适配 XML 和注解两种配置。对于注解配置，具体的实现在 `GenericWebApplicationContext` 中：

  ```java
  @Override
  protected final void refreshBeanFactory() throws IllegalStateException {
      if (!this.refreshed.compareAndSet(false, true)) {
          throw new IllegalStateException(
              "GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once");
      }
      // 使用了默认的 DefaultListableBeanFactory
      this.beanFactory.setSerializationId(getId());
  }

  @Override
  public final ConfigurableListableBeanFactory getBeanFactory() {
      // 返回创建的 BeanFactory
      return this.beanFactory;
  }
  ```

  这里的 `setSerializationId(getId())` 是为了在序列化时使用当前 ApplicationContext 的 ID。

  ```java
  public void setSerializationId(@Nullable String serializationId) {
      if (serializationId != null) {
          serializableFactories.put(serializationId, new WeakReference<>(this));
      }
      else if (this.serializationId != null) {
          serializableFactories.remove(this.serializationId);
      }
      this.serializationId = serializationId;
  }
  ```

  可以看到，`DefaultListableBeanFactory` 中使用了一个 `WeakReference` 来保存 BeanFactory 的引用，并将其放入 `serializableFactories` 中。

- `prepareBeanFactory()`

  ```java
  protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
      // 设置 ClassLoader 为加载 ApplicationContext 的类加载器
      beanFactory.setBeanClassLoader(getClassLoader());
      // 设置 Bean 表达式解析器
      beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
      // 设置 PropertyEditorRegistrar
      beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

      // 注册默认的 ApplicationContextAwareProcessor，它可以用作回调获取 ApplicationContext
      beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));

      // Autowire 时忽略一些接口
      beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
      beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
      beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
      beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
      beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
      beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
      beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);

      // 为几个特殊的 Bean 赋值
      beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
      beanFactory.registerResolvableDependency(ResourceLoader.class, this);
      beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
      beanFactory.registerResolvableDependency(ApplicationContext.class, this);

      // 注册事件监听器
      beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

      // 检测 LoadTimeWeaverAwareProcessor，如果存在则注册一个 BeanPostProcessor
      if (!NativeDetector.inNativeImage() && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
          beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
          // 为了类型匹配，设置临时的 ClassLoader
          beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
      }

      // 注册默认的环境变量 Bean
      if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
          beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
      }
      // 注册默认的系统属性 Bean
      if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
          beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
      }
      // 注册默认的系统环境 Bean
      if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
          beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
      }
      // 注册默认的 ApplicationStartup Bean
      if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) {
          beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());
      }
  }
  ```

- `finishBeanFactoryInitialization()`

  ```java
  protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
      // 初始化引导执行器
      if (beanFactory.containsBean(BOOTSTRAP_EXECUTOR_BEAN_NAME) &&
          beanFactory.isTypeMatch(BOOTSTRAP_EXECUTOR_BEAN_NAME, Executor.class)) {
          beanFactory.setBootstrapExecutor(
              beanFactory.getBean(BOOTSTRAP_EXECUTOR_BEAN_NAME, Executor.class));
      }

      // 初始化转换服务
      if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
          beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
          beanFactory.setConversionService(
              beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
      }

      // 注册默认的嵌入式值解析器
      if (!beanFactory.hasEmbeddedValueResolver()) {
          beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
      }

      // 先初始化部分指定的 Bean
      String[] initializerNames = beanFactory.getBeanNamesForType(BeanFactoryInitializer.class, false, false);
      for (String initializerName : initializerNames) {
          beanFactory.getBean(initializerName, BeanFactoryInitializer.class).initialize(beanFactory);
      }

      // 然后初始化 LoadTimeWeaverAware 的 Bean
      String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
      for (String weaverAwareName : weaverAwareNames) {
          try {
              beanFactory.getBean(weaverAwareName, LoadTimeWeaverAware.class);
          }
          catch (BeanNotOfRequiredTypeException ex) {
              if (logger.isDebugEnabled()) {
                  logger.debug("Failed to initialize LoadTimeWeaverAware bean '" + weaverAwareName +
                      "' due to unexpected type mismatch: " + ex.getMessage());
              }
          }
      }

      // 不再使用用于类型匹配的临时 ClassLoader
      beanFactory.setTempClassLoader(null);

      // 已注册的 Bean 不再允许被修改或后处理
      beanFactory.freezeConfiguration();

      // 初始化
      beanFactory.preInstantiateSingletons();
  }
  ```

  跟踪最后的初始化函数：

  ```java
  @Override
  public void preInstantiateSingletons() throws BeansException {
      if (logger.isTraceEnabled()) {
          logger.trace("Pre-instantiating singletons in " + this);
      }

      List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

      // 这里的 futures 是个线程安全的集合
      List<CompletableFuture<?>> futures = new ArrayList<>();

      
      // 递归查找父类并初始化，这里需要确保线程安全
      this.preInstantiationPhase = true;
      this.preInstantiationThread.set(PreInstantiation.MAIN);
      try {
          for (String beanName : beanNames) {
              RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
              if (!mbd.isAbstract() && mbd.isSingleton()) {
                  CompletableFuture<?> future = preInstantiateSingleton(beanName, mbd);
                  if (future != null) {
                      futures.add(future);
                  }
              }
          }
      }
      finally {
          this.preInstantiationThread.remove();
          this.preInstantiationPhase = false;
      }

      if (!futures.isEmpty()) {
          try {
              CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0])).join();
          }
          catch (CompletionException ex) {
              ReflectionUtils.rethrowRuntimeException(ex.getCause());
          }
      }

      for (String beanName : beanNames) {
          // 创建单例
          Object singletonInstance = getSingleton(beanName, false);
          if (singletonInstance instanceof SmartInitializingSingleton smartSingleton) {
              StartupStep smartInitialize = getApplicationStartup().start("spring.beans.smart-initialize")
                  .tag("beanName", beanName);
              smartSingleton.afterSingletonsInstantiated();
              smartInitialize.end();
          }
      }
  }
  ```

  我们来看一下 `getBean()` 方法：

  ```java
  protected <T> T doGetBean(
      String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
      throws BeansException {

      String beanName = transformedBeanName(name);
      Object beanInstance;

      // 检查是否已经实例化过
      Object sharedInstance = getSingleton(beanName);
      // 如果已经实例化过，直接返回
      if (sharedInstance != null && args == null) {
          if (logger.isTraceEnabled()) {
              if (isSingletonCurrentlyInCreation(beanName)) {
                  logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                      "' that is not fully initialized yet - a consequence of a circular reference");
              }
              else {
                  logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
              }
          }
          beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);
      }

      else {
          // 如果存在 ParentBeanFactory
          if (isPrototypeCurrentlyInCreation(beanName)) {
              throw new BeanCurrentlyInCreationException(beanName);
          }

          // 如果 Bean 有父类且没有实例化过
          BeanFactory parentBeanFactory = getParentBeanFactory();
          if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
              String nameToLookup = originalBeanName(name);
              if (parentBeanFactory instanceof AbstractBeanFactory abf) {
                  return abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
              }
              else if (args != null) {
                  return (T) parentBeanFactory.getBean(nameToLookup, args);
              }
              else if (requiredType != null) {
                  return parentBeanFactory.getBean(nameToLookup, requiredType);
              }
              else {
                  return (T) parentBeanFactory.getBean(nameToLookup);
              }
          }

          if (!typeCheckOnly) {
              markBeanAsCreated(beanName);
          }

          StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate")
              .tag("beanName", name);
          // 开始实例化 Bean
          try {
              if (requiredType != null) {
                beanCreation.tag("beanType", requiredType::toString);
              }
              RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
              checkMergedBeanDefinition(mbd, beanName, args);

              // 获取依赖的 Bean
              String[] dependsOn = mbd.getDependsOn();
              if (dependsOn != null) {
                  for (String dep : dependsOn) {
                      // 检查循环依赖
                      if (isDependent(beanName, dep)) {
                          throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                              "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                      }
                      // 注册依赖关系
                      registerDependentBean(dep, beanName);
                      try {
                          // 先初始化依赖的 Bean
                          getBean(dep);
                      }
                      catch (NoSuchBeanDefinitionException ex) {
                          throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                              "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
                      }
                      catch (BeanCreationException ex) {
                          if (requiredType != null) {
                              throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                  "Failed to initialize dependency '" + ex.getBeanName() + "' of " +
                                      requiredType.getSimpleName() + " bean '" + beanName + "': " +
                                      ex.getMessage(), ex);
                          }
                          throw ex;
                      }
                  }
              }

              // 单例模式
              if (mbd.isSingleton()) {
                  sharedInstance = getSingleton(beanName, () -> {
                      try {
                          return createBean(beanName, mbd, args);
                      }
                      catch (BeansException ex) {
                          destroySingleton(beanName);
                          throw ex;
                      }
                  });
                  beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
              }

              // 原型模式
              else if (mbd.isPrototype()) {
                  Object prototypeInstance = null;
                  try {
                      beforePrototypeCreation(beanName);
                      prototypeInstance = createBean(beanName, mbd, args);
                  }
                  finally {
                      afterPrototypeCreation(beanName);
                  }
                  beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
              }

              // 自定义作用域
              else {
                  String scopeName = mbd.getScope();
                  if (!StringUtils.hasLength(scopeName)) {
                      throw new IllegalStateException("No scope name defined for bean '" + beanName + "'");
                  }
                  Scope scope = this.scopes.get(scopeName);
                  if (scope == null) {
                      throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                  }
                  try {
                      Object scopedInstance = scope.get(beanName, () -> {
                          beforePrototypeCreation(beanName);
                          try {
                              return createBean(beanName, mbd, args);
                          }
                          finally {
                              afterPrototypeCreation(beanName);
                          }
                      });
                      beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                  }
                  catch (IllegalStateException ex) {
                      throw new ScopeNotActiveException(beanName, scopeName, ex);
                  }
              }
          }
          catch (BeansException ex) {
              beanCreation.tag("exception", ex.getClass().toString());
              beanCreation.tag("message", String.valueOf(ex.getMessage()));
              cleanupAfterBeanCreationFailure(beanName);
              throw ex;
          }
          finally {
              beanCreation.end();
              if (!isCacheBeanMetadata()) {
                  clearMergedBeanDefinition(beanName);
              }
          }
      }

      return adaptBeanInstance(name, beanInstance, requiredType);
  }
  ```

  总之，这个函数就是先去做了循环依赖检查，然后分单例、原型、自定义三种作用域，分别实例化 Bean。当然，如果父类还没实例化完，它会先实例化父类。

  继续看 `createBean()` 方法：

  ```java
  @Override
  protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {

      if (logger.isTraceEnabled()) {
          logger.trace("Creating instance of bean '" + beanName + "'");
      }
      RootBeanDefinition mbdToUse = mbd;

      // 确保 BeanClass 是可解析的
      Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
      if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
          mbdToUse = new RootBeanDefinition(mbd);
          mbdToUse.setBeanClass(resolvedClass);
          try {
              mbdToUse.prepareMethodOverrides();
          }
          catch (BeanDefinitionValidationException ex) {
              throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                  beanName, "Validation of method overrides failed", ex);
          }
      }

      try {
          // 处理代理
          Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
          if (bean != null) {
              return bean;
          }
      }
      catch (Throwable ex) {
          throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
              "BeanPostProcessor before instantiation of bean failed", ex);
      }

      try {
          // 实例化 Bean
          Object beanInstance = doCreateBean(beanName, mbdToUse, args);
          if (logger.isTraceEnabled()) {
              logger.trace("Finished creating instance of bean '" + beanName + "'");
          }
          return beanInstance;
      }
      catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
        throw ex;
      }
      catch (Throwable ex) {
        throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
      }
  }
  ```

  这个函数主要是把 PostProcessor 的代理单独拎出来讲了下。然后我们看 `doCreateBean()` 方法：

  ```java
  protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {

      BeanWrapper instanceWrapper = null;
      if (mbd.isSingleton()) {
          // 删除 BeanFactory 中的缓存
          instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
      }
      if (instanceWrapper == null) {
          // 实例化 Bean
          instanceWrapper = createBeanInstance(beanName, mbd, args);
      }
      // 获取 Bean 的实例
      Object bean = instanceWrapper.getWrappedInstance();
      // 获取 Bean 的类型
      Class<?> beanType = instanceWrapper.getWrappedClass();
      if (beanType != NullBean.class) {
          mbd.resolvedTargetType = beanType;
      }

      synchronized (mbd.postProcessingLock) {
          if (!mbd.postProcessed) {
              try {
                  // 调用 BeanPostProcessor
                  applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
              }
              catch (Throwable ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                      "Post-processing of merged bean definition failed", ex);
              }
              mbd.markAsPostProcessed();
          }
      }

      // 解决循环依赖
      boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
          isSingletonCurrentlyInCreation(beanName));
      if (earlySingletonExposure) {
          if (logger.isTraceEnabled()) {
              logger.trace("Eagerly caching bean '" + beanName +
                  "' to allow for resolving potential circular references");
          }
          // 将正在创建的 Bean 放入单例工厂，此时循环依赖的 Bean 可以从工厂中获取 ObjectFactory，达到允许循环依赖的目的
          addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
      }

      // 初始化 Bean 实例
      Object exposedObject = bean;
      try {
          // 填充属性
          populateBean(beanName, mbd, instanceWrapper);
          // 初始化完成后的回调函数
          exposedObject = initializeBean(beanName, exposedObject, mbd);
      }
      catch (Throwable ex) {
          if (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {
              throw bce;
          }
          else {
              throw new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);
          }
      }

      // 继续解决循环依赖
      if (earlySingletonExposure) {
          Object earlySingletonReference = getSingleton(beanName, false);
          if (earlySingletonReference != null) {
              if (exposedObject == bean) {
                  exposedObject = earlySingletonReference;
              }
              else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                  String[] dependentBeans = getDependentBeans(beanName);
                  Set<String> actualDependentBeans = CollectionUtils.newLinkedHashSet(dependentBeans.length);
                  for (String dependentBean : dependentBeans) {
                      if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                          actualDependentBeans.add(dependentBean);
                      }
                  }
                  if (!actualDependentBeans.isEmpty()) {
                      throw new BeanCurrentlyInCreationException(beanName,
                          "Bean with name '" + beanName + "' has been injected into other beans [" +
                          StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                          "] in its raw version as part of a circular reference, but has eventually been " +
                          "wrapped. This means that said other beans do not use the final version of the " +
                          "bean. This is often the result of over-eager type matching - consider using " +
                          "'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.");
                  }
              }
          }
      }

      // 把 Bean 注册到对应的作用域
      try {
          registerDisposableBeanIfNecessary(beanName, bean, mbd);
      }
      catch (BeanDefinitionValidationException ex) {
          throw new BeanCreationException(
              mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
      }

      return exposedObject;
  }
  ```

  这个函数主要是实例化 Bean、填充属性、并执行初始化相关的函数。它还解决了循环依赖的问题。

  - `createBeanInstance()` 方法：

    ```java
    protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
        // 确保 BeanClass 是可解析的
        Class<?> beanClass = resolveBeanClass(mbd, beanName);

        // 不能实例化非公共的类
        if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                "Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
        }

        if (args == null) {
            Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
            if (instanceSupplier != null) {
                return obtainFromSupplier(instanceSupplier, beanName, mbd);
            }
        }

        if (mbd.getFactoryMethodName() != null) {
            return instantiateUsingFactoryMethod(beanName, mbd, args);
        }

        // 是否是第一次实例化
        boolean resolved = false;
        // 是否采用构造函数注入
        boolean autowireNecessary = false;
        if (args == null) {
            synchronized (mbd.constructorArgumentLock) {
                if (mbd.resolvedConstructorOrFactoryMethod != null) {
                    resolved = true;
                    autowireNecessary = mbd.constructorArgumentsResolved;
                }
            }
        }
        if (resolved) {
            if (autowireNecessary) {
                return autowireConstructor(beanName, mbd, null, null);
            }
            else {
                return instantiateBean(beanName, mbd);
            }
        }

        // 判断是否有构造参数
        Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
        if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
            return autowireConstructor(beanName, mbd, ctors, args);
        }

        ctors = mbd.getPreferredConstructors();
        if (ctors != null) {
            return autowireConstructor(beanName, mbd, ctors, null);
        }

        return instantiateBean(beanName, mbd);
    }
    ```

    这个函数其实就算分了有无构造函数、有无参数来分别处理。

    方便起见，我们看其中无参构造函数的实现：

    ```java
    protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {
        try {
            Object beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this);
            BeanWrapper bw = new BeanWrapperImpl(beanInstance);
            initBeanWrapper(bw);
            return bw;
        }
        catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);
        }
    }
    ```

    继续跟踪 `instantiate()` 方法：

    ```java
    @Override
  public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
        // 如果不存在方法覆写，那就使用 Java 反射进行实例化
        if (!bd.hasMethodOverrides()) {
            Constructor<?> constructorToUse;
            synchronized (bd.constructorArgumentLock) {
                constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;
                if (constructorToUse == null) {
                    Class<?> clazz = bd.getBeanClass();
                    if (clazz.isInterface()) {
                        throw new BeanInstantiationException(clazz, "Specified class is an interface");
                    }
                    try {
                        constructorToUse = clazz.getDeclaredConstructor();
                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                    }
                    catch (Throwable ex) {
                        throw new BeanInstantiationException(clazz, "No default constructor found", ex);
                    }
                }
            }
            return BeanUtils.instantiateClass(constructorToUse);
        }
        else {
            // 否则使用 CGLIB
            return instantiateWithMethodInjection(bd, beanName, owner);
        }
    }
    ```

    没什么好说的，就是用反射找到构造函数并调用。

  - `populateBean()` 方法：

    ```java
    protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
        if (bw == null) {
            if (mbd.hasPropertyValues()) {
                throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
            }
            else {
                return;
            }
        }

        if (bw.getWrappedClass().isRecord()) {
            if (mbd.hasPropertyValues()) {
                throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, "Cannot apply property values to a record");
            }
            else {
                return;
            }
        }

        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
            for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
                if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                    return;
                }
            }
        }

        // 获取属性值
        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

        int resolvedAutowireMode = mbd.getResolvedAutowireMode();
        if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
            // 按名称 Autowire
            if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
                autowireByName(beanName, mbd, bw, newPvs);
            }
            // 按类型 Autowire
            if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
                autowireByType(beanName, mbd, bw, newPvs);
            }
            pvs = newPvs;
        }
        if (hasInstantiationAwareBeanPostProcessors()) {
            if (pvs == null) {
                pvs = mbd.getPropertyValues();
            }
            for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
                PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                if (pvsToUse == null) {
                    return;
                }
                pvs = pvsToUse;
            }
        }

        boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);
        if (needsDepCheck) {
            PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            checkDependencies(beanName, mbd, filteredPds, pvs);
        }

        if (pvs != null) {
            // 赋值
            applyPropertyValues(beanName, mbd, bw, pvs);
        }
    }
    ```

</div>
</details>

好！啰啰嗦嗦地说了这么多，总算看完了 Spring 刷新容器的过程。

这个过程中，Spring 主要就是在管理 Bean 的生命周期。

### 总结

你应该可以看出来，Spring 对 IoC 的处理是非常复杂的。但我们抽丝剥茧，还是能发现其内核就是一个大 Map，存储了 BeanDefinition 和 Bean 的映射关系。
