---
layout: post
title:  "MD5 Collision"
date:   2020-12-01 00:00:00 +0800
categories: 实验
tags: seedlab md5
series: SEEDLabs
series_index: 6
comments: true
mathjax: true
copyrights: 原创
---

本文为 [SEED Labs 2.0 - MD5 Collision Attack Lab](https://seedsecuritylabs.org/Labs_20.04/Crypto/Crypto_MD5_Collision/) 的实验记录。

## 实验原理

<img src="/assets/post/images/md51.png" style="zoom: 33%;" alt="md51" />

$\begin{cases}F(X,Y,Z) = (X\wedge{Y}) \vee (\neg{X} \wedge{Z})\\
G(X,Y,Z) = (X\wedge{Z}) \vee (Y \wedge \neg{Z})\\
H(X,Y,Z) = X \oplus Y \oplus Z\\
I(X,Y,Z) = Y \oplus (X \vee \neg{Z})\end{cases}$

四个函数每个作用 16 轮，得到最后的结果。

## Task 1: Generating Two Different Files with the Same MD5 Hash

首先创建 `prefix.txt`

```shell
touch prefix.txt
vim prefix.txt
```

例如，我们修改内容为

```plaintext
hail hydra
```

然后生成两个 md5 相同的文件

```shell
md5collgen -p prefix.txt -o out1.bin out2.bin
```

验证我们的文件是否相同、md5是否相同

```shell
diff out1.bin out2.bin
md5sum out1.bin
md5sum out2.bin
```

得到如下结果

<img src="/assets/post/images/md52.png" alt="md52" style="zoom: 50%;" />

我们分别查看 out1.bin 和 out2.bin

<img src="/assets/post/images/md53.png" alt="md53" style="zoom: 67%;" />

<img src="/assets/post/images/md54.png" alt="md54" style="zoom:67%;" />

> **Question 1** If the length of your prefix file is not multiple of 64, what is going to happen?

补零至 64 Byte。

> **Question 2** Create a prefix file with exactly 64 bytes, and run the collision tool again, and see what happens.

将 prefix.txt 改为

```plaintext
abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk
```

这里一共 63 个字母，加上文件结束符 `0A` 正好 64 Byte。

```shell
md5collgen -p prefix.txt -o out1.bin out2.bin
```

生成文件后如下所示

<img src="/assets/post/images/md55.png" alt="md55" style="zoom:67%;" />

可以看到没有补零了。

> **Question 3** Are the data (128 bytes) generated by md5collgen completely different for the two
> output files? Please identify all the bytes that are different.

例如第一个例子中，有 3 个 Byte 不同。经过多次尝试发现，这些不同的数量和位置不固定。

## Task 2: Understanding MD5’s Property

我们对刚刚的两个 md5 相同的文件分别加上一个后缀，然后查看它们的 md5

```shell
echo hello >> out1.bin
echo hello >> out2.bin
md5sum out1.bin out2.bin
```

<img src="/assets/post/images/md56.png" alt="md56" style="zoom:50%;" />

可以看到，md5 相同的文件加上相同后缀后，md5 依然相同。

## Task 3: Generating Two Executable Files with the Same MD5 Hash

新建 pro.c

```shell
touch pro.c
```

修改内容如下

```c
#include <stdio.h>
unsigned char xyz[200] = {
    'B', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'B'
};
int main()
{
    int i;
    for (i=0; i<200; i++){
        printf("%x", xyz[i]);
    }
    printf("\n");
}
```

编译

```shell
gcc -o pro pro.c
```

定位到刚刚的字符串存储在 `0x3020` 位置

<img src="/assets/post/images/md57.png" alt="md57" style="zoom:80%;" />

我们不妨截取到 12340 位置

```shell
head -c 12340 pro > prefix
```

计算得到在 12320 到 12379 范围内，12352 为 64 的倍数，因此我们把12352 后面的截取出来

```shell
tail -c +12353 pro > suffix
```

然后对 prefix 生成 md5 相同的两个文件

```shell
md5collgen -p prefix -o prefix1 prefix2
```

把刚刚的尾巴接到这两个文件后面

```shell
cat suffix >> prefix1
cat suffix >> prefix2
```

赋予执行权限

```shell
chmod +x prefix1
chmod +x prefix1
```

运行

<img src="/assets/post/images/md58.png" alt="md58" style="zoom: 50%;" />

可以看到，两个输出是不同的

```shell
./prefix1 > prefix1.out
./prefix2 > prefix2.out
diff -q prefix1.out prefix2.out
```

<img src="/assets/post/images/md59.png" alt="md59" style="zoom:50%;" />

## Task 4: Making the Two Programs Behave Differently

构造 `origin.c` 如下

```c
#include <stdio.h>
unsigned char a[200] = {
    'B', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'B'
};
unsigned char b[200] = {
    'B', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A',
    'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'B'
};
int main()
{
    int i;
    int isSame=1;
    for(i = 0; i < 200; i++)
    {
        if(a[i]!=b[i])
            isSame=0;
    }
    if(isSame)
        printf("run benign code\n");
    else
        printf("run malicious code\n");
}
```

编译

```shell
gcc -o origin origin.c
```

找到两个数组位置

<img src="/assets/post/images/md510.png" alt="md510" style="zoom:80%;" />

与上一个 task 同样的方法，我们构造两个 md5 相同的文件

```shell
head -c 12340 origin > prefix
md5collgen -p prefix -o prefix1 prefix2
```

查看 prefix1

![md511](/assets/post/images/md511.png)

截取

```shell
tail -c +12320 prefix1 > middle # 截取生成的字符串
tail -c +12768 origin > suffix # 截取第二个字符串（不含）后面的内容
head -c 12543 origin > tmp1 # 截取第二个字符串（不含）前面的内容
tail -c 63 tmp1 > tmp # 截取到需要填充的 0x00
cat tmp >> prefix1
cat tmp >> prefix2
cat middle >> prefix1
cat middle >> prefix2
cat tmp >> prefix1
cat tmp >> prefix2
cat suffix >> prefix1
cat suffix >> prefix2
chmod +x prefix1
chmod +x prefix2
```

分别运行并检查 md5

<img src="/assets/post/images/md512.png" alt="md512" style="zoom:50%;" />

可以看到，它们运行了不同的代码，但 md5 是相同的。

## 实验总结

前面 3 个 Task 非常简单。最后一个接来接去的不搞乱了、把该截取多少个想清楚了，就做出来了。
