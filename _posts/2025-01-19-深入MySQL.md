---
layout: post
title:  "深入 MySQL"
date:   2025-01-19 00:00:00 +0800
categories: 工具
tags: mysql sql db
comments: true
copyrights: 原创
draft: true
---

MySQL 是一个 SQL 数据库。

## 执行流程

当我们向 MySQL 发送 SQL 语句时，MySQL 的执行流程如下图所示：

![MySQL框架](/assets/post/images/mysql1.svg)

### 客户端发送语句

用户要想使用 MySQL，首先要连接到 MySQL 服务器。

```shell
$ mysql -u root -p
Enter password: ********
```

这个连接是通过 TCP/IP 协议来实现的。MySQL 服务器监听一个端口，通常是 `3306`。当用户连接到 MySQL 服务器时，MySQL 服务器会为用户创建一个线程。这个线程会处理用户发送的 SQL 语句。

MySQL 的不同用户可以有不同的权限。MySQL 会在执行 SQL 语句之前，根据用户的权限来决定用户是否有权执行。这一权限在连接时就会被确定，即便之后管理员修改了用户的权限，也不会对当前的连接产生影响。

用户的连接情况可以使用 `SHOW PROCESSLIST` 来查看。如果用户在连接后发送了 SQL 语句，那么这个连接会被标记为 `Query` 状态。相反，如果一个用户连接后从没发送过 SQL 语句，那么这个连接会被标记为 `Sleep` 状态。

```sql
mysql> SHOW PROCESSLIST;
+----+----------+---------+------+-------+------------------+
| Id | User     | Command | Time | State | Info             |
+----+----------+---------+------+-------+------------------+
| 15 | root     | Query   |    0 | init  | SHOW PROCESSLIST |
| 16 | ch3nyang | Sleep   |   60 |       | NULL             |
+----+----------+---------+------+-------+------------------+
```

可以看到，`root` 用户正在执行 `SHOW PROCESSLIST` 语句，而 `ch3nyang` 用户正在 `Sleep` 状态，已经有 60 秒了。

MySQL 定义了最大的 `Sleep` 时常，由 `wait_timeout` 参数控制。如果一个连接在 `wait_timeout` 时间内没有发送 SQL 语句，那么这个连接会被 MySQL 服务器断开。`wait_timeout` 默认是 28800 秒，即 8 小时。

```sql
mysql> SELECT @@global.wait_timeout;
+-----------------------+
| @@global.wait_timeout |
+-----------------------+
|                 28800 |
+-----------------------+
```

我们可以手动设置 `wait_timeout` 参数：

```sql
mysql> SET GLOBAL wait_timeout=28800;
```

对于长时间不使用的连接，我们也可以使用 `KILL` 命令来手动断开：

```sql
mysql> KILL 16;
```

MySQL 对最大连接数也有限制，由 `max_connections` 参数控制。如果 MySQL 服务器的连接数达到了 `max_connections`，那么新的连接会被拒绝。

```sql
mysql> SELECT @@global.max_connections;
+--------------------------+
| @@global.max_connections |
+--------------------------+
|                      151 |
+--------------------------+
```

客户端和服务器之间的 TCP/IP 连接分为长连接和短连接。MySQL 默认使用长连接，其可以减少连接的建立和断开的开销，但是会占用服务器的资源。为了单个长连接避免占用内存过多，可以使用 `mysql_reset_connection()` 来重置连接。如果你是在命令行中，只需断开再重新连接即可。

### 查询缓存

这一步在 MySQL 8.0 版本中已经被移除。

在这之前，MySQL 会检查查询缓存，看看是否有相同的 `SELECT` 语句已经被执行过。如果有，MySQL 会直接返回查询缓存中的结果，而不会再执行一次查询。

然而，只要一个表发生了变化，这个表上的所有查询缓存都会被清空。因此，当更新较为频繁时，查询缓存大概率不会命中。这使得查询缓存只对读多写少的场景有用，对于高并发场景，查询缓存会导致性能下降，这也是为什么 MySQL 8.0 移除了查询缓存。

### 解析器

这一步 MySQL 会对 SQL 语句进行解析，检查 SQL 语句是否符合 MySQL 的语法规范。如果 SQL 语句不符合规范，MySQL 会返回一个错误。

其基本就是编译原理里的一些东西，比如词法分析、语法分析等。此处不再赘述。

### 执行查询

预处理器会对 SQL 语句进行一些处理，比如检查表名和列名是否存在，检查用户是否有权限等，同时还会对 SQL 语句进行一些处理，比如将 `SELECT *` 扩展为 `SELECT column1, column2, ...`。

紧接着，MySQL 会调用优化器来生成一个执行计划。优化器会生成多个执行计划，然后选择成本最低的执行计划。例如，如果一个查询有多个索引可以使用，那么优化器会选择成本最低的索引。

为了查看 MySQL 生成的执行计划，我们可以在 SQL 语句前加上 `EXPLAIN` 关键字：

```sql
mysql> EXPLAIN SELECT * FROM city WHERE id = 1899;
+--+---+-----+-------------+-------+---+
|id|...|type |possible_keys|key    |...|
+--+---+-----+-------------+-------+---+
| 1|...|const|PRIMARY      |PRIMARY|...|
+--+---+-----+-------------+-------+---+
```

可以看到，MySQL 会返回一个表格，其中包含了查询的执行计划。这个表格的列的含义如下：

- `id`：查询中的每个查询块都有一个唯一的标识符。
- `select_type`：查询块的类型，比如 `SIMPLE`、`PRIMARY`、`SUBQUERY` 等。
- `table`：查询块中的表名。
- `type`：MySQL 在表中查找行的方式，比如 `const`、`eq_ref`、`ref`、`range`、`index`、`ALL` 等。
- `possible_keys`：可能使用的索引。
- `key`：实际使用的索引。
- `key_len`：索引的长度。
- `ref`：比较的列。
- `rows`：MySQL 估计要检查的行数。
- `Extra`：额外的信息。

如果查询需要全表扫描，那么 `type` 会是 `ALL`，`key` 会是 `NULL`：

```sql
mysql> EXPLAIN SELECT * FROM city WHERE name Like '%nanjing%';
+--+-----------+---+-----+-------------+---+---+
|id|select_type|...|type |possible_keys|key|...|
+--+-----------+---+-----+-------------+---+---+
| 1|SIMPLE     |...|ALL  |NULL         |NULL|...|
+--+-----------+---+-----+-------------+---+---+
```

我们可以再建立一个二级索引，然后再查看执行计划：

```sql
mysql> CREATE INDEX idx_population ON city(population);
mysql> EXPLAIN SELECT * FROM city WHERE id > 1 AND population > 10000000;
+--+---+-----+----------------------+--------------+---+
|id|...|type |possible_keys         |key           |...|
+--+---+-----+----------------------+--------------+---+
| 1|...|range|PRIMARY,idx_population|idx_population|...|
+--+---+-----+----------------------+--------------+---+
```

这里，我们看到有 `PRIMARY` 和 `idx_population` 两个索引可以使用，MySQL 选择了 `idx_population` 索引。

接下来，执行计划会被交由执行器执行。执行器会调用存储引擎的接口来执行查询。存储引擎会返回查询的结果给执行器，然后执行器会将结果返回给客户端。这个过程包含了三个部分。

1. 主键索引查找
2. 全表扫描
3. 索引下推
