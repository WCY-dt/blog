---
layout: post
title:  "【数据结构】排序"
date:   2020-07-15 00:00:00 +0800
categories: A&DS
tags: 数据结构 算法 排序 QuickSort ShellSort HeapSort
comments: 1
mathjax: true
copyrights: 原创
---

本文为数据结构系列第七篇，主要介绍三种排序方法。

# Quick Sort

## 快速排序

![](https://img-blog.csdnimg.cn/20200904182032170.gif#pic_center)

- 首先规定一个“基准”， 将数据分为两个部分。
- 将大于等于（大于）的数据放在基准的右面，将小于（小于等于）的数据放在基准的左面。
- 然后，左面的数据又可以规定一个基准，分为两部分；右面的数据也可以规定一个基准，也分为两部分。递归下去。
- 直到分到不可再分，或数据有序。

![img](https://img2018.cnblogs.com/common/1915061/202002/1915061-20200222114001524-1278744058.jpg)

如果右面找到一个小于基准的数，左面找到一个小于基准的数，而且左右没有相遇则交换左右数据。如果左右相遇了，那么就把基准与相遇点数据交换。自此，将序列分为左右两部分。左面的小于基准，右面的大于基准。

### 程序

```cpp
#include <stdio.h>
#include <string.h>

void QuickSort(char arry[], int L, int R);
  
void main(void)
{
     int i;
     char arry[8] = {5, 4, 9, 8, 7, 6, 2, 1};
     printf("原来顺序：\n");
     for (i = 0; i < sizeof (arry); i++)
     {
        printf("%d\t", arry[i]);
     }
     printf("\n");
     QuickSort(arry, 0, 7);
     printf("排序后：\n");
     for (i = 0; i < sizeof (arry); i++)
     {
        printf("%d\t", arry[i]);
     }
     printf("\n");
     return;
}

void QuickSort(char arry[], int L, int R)
{
     int left = L,right = R;
     int x;
     int Centor = 0,temp = 0;
     
      if (L > R)
     {
         return;
     }
     Centor = arry[L];//基准保存在Centor中
     while (left != right)//left 与 right 没有相遇 则继续循环交换
     {
         while (arry[right] >= Centor && left < right)//如果右面的数大于基准跳过，小于基准停止，
         {
             right--;
         }
         while (arry[left] <= Centor && left < right)//如果左面的数小于基准跳过，大于基准停止，
         {
             left++;
         }
         if (left < right)//如果left 与 right 没有相遇，则将 右面小于基准的数 与 左面大于基准的数交换
         {
             temp = arry[left];
             arry[left] = arry[right];
             arry[right] = temp;
         }
         //显示交换后的序列
         for (x = 0; x < 8; x++)
         {
            printf("%d\t", arry[x]);
         }
         printf("\n");
     }
     //如果left 与 right 相遇 则将基准以相遇的位置数据互换，至此 就将数据分为了左右两部分
     //左面的小于基准，右面的大于基准
     arry[L] = arry[left];
     arry[left] = Centor;
     //将左面的继续进行排序
     QuickSort(arry, L, left-1);
     //将右面的继续进行排序
     QuickSort(arry, right+1, R);
}
```

运行结果：

```
原来顺序：
5       4       9       8       7       6       2       1
5       4       1       8       7       6       2       9
5       4       1       2       7       6       8       9
5       4       1       2       7       6       8       9
2       1       4       5       7       6       8       9
2       1       4       5       7       6       8       9
1       2       4       5       7       6       8       9
1       2       4       5       6       7       8       9
排序后：
1       2       4       5       6       7       8       9
```

# Shell Sort

## 基本思想

​          希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至$1$时，整个文件恰被分成一组，算法便终止。

　　简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如`[5,4,3,2,1,0]`这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需$n-1$次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为$1$。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为$1$时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

　　我们来看下希尔排序的基本步骤，在此我们选择增量$\text{gap}=\text{length}/2$，缩小增量继续以$\text{gap} = \text{gap}/2$的方式，这种增量选择我们可以用一个序列来表示，$\left\{\frac{n}{2},\frac{\frac{n}{2}}{2}\cdots1\right\}$，称为**增量序列**。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

![img](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png)

## 代码

　　在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，我们可以不用这么按部就班地处理完一组再调转回来处理下一组（这样还得加个for循环去处理分组）比如`[5,4,3,2,1,0]` ，首次增量设$\text{gap}=\text{length}/2=3$,则为3组`[5,2] [4,1] [3,0]`，实现时不用循环按组处理，我们可以从第`gap`个元素开始，逐个跨组处理。同时，在插入数据时，可以采用元素交换法寻找最终位置，也可以采用数组元素移动法寻觅。希尔排序的代码比较简单，如下：

```cpp

```

# Heap Sort

## 基本思想

​         堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余$n-1$个元素重新构造成一个堆，这样会得到$n$个元素的次小值。如此反复执行，便能得到一个有序序列了

- **构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)**
  - 假设给定无序序列结构如下
    ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192038651-934327647.png)
  - 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 `arr.length/2-1=5/2-1=1`，也就是下面的$6$结点），从左至右，从下至上进行调整。
    ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192209433-270379236.png)
  - 找到第二个非叶节点$4$，由于`[4,9,8]`中$9$元素最大，$4$和$9$交换。
    ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217192854636-1823585260.png)
    这时，交换导致了子根`[4,5,6]`结构混乱，继续调整，`[4,5,6]`中$6$最大，交换$4$和$6$。
    ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217193347886-1142194411.png)
    此时，我们就将一个无需序列构造成了一个大顶堆。
- **步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**
  - 将堆顶元素$9$和末尾元素$4$进行交换
   ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217194207620-1455153342.png)
  - 重新调整结构，使其继续满足堆定义
    ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218153110495-1280388728.png)
  - 再将堆顶元素$8$与末尾元素$5$进行交换，得到第二大元素$8$.
    ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152929339-1114983222.png)
    后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序
    ![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218152348229-935654830.png)

再简单总结下堆排序的基本思路：

- 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
- 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端
- 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序

## 代码

```cpp

```

