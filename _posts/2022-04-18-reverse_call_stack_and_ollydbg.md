---
layout: post
title:  "逆向工程（二）——调用栈和 Ollydbg"
date:   2022-04-18 00:00:00 +0800
categories: 安全
tags: assembly ollydbg
comments: 1
mathjax: true
copyrights: 转载 翻译
---

在计算机科学中，调用堆栈是一种数据结构，用于存储有关计算机程序的活动子例程的信息。这种堆栈也称为执行堆栈、程序堆栈、控制堆栈、运行时堆栈或机器堆栈，通常简称为“堆栈”。

在上一章中，您已经阅读了有关 x86 的说明。你还记得任何与堆栈相关的指令吗？`push`？`pop`？`call`？`ret`？我们很快就会再次解决这些问题。

# 调用堆栈的用途

1. 存储返回地址

   拥有调用堆栈的主要原因是跟踪每个活动子例程在完成执行时应该返回的点。例如，如果子程序 `DrawSquare` 从四个不同的位置调用子程序 `DrawLine`，则 `DrawLine` 必须知道在其执行完成时返回到哪里。为了实现这一点，调用指令后面的地址——返回地址——在每次调用时需要被压入调用堆栈。

2. 局部变量存储
   
   函数经常需要内存空间来存储局部变量的值，这些变量仅在函数内部是已知的，并且在返回后不存储值。通过将堆栈的顶部移向较低的地址，可以方便地为这些变量分配空间，以提供必要的空间。

3. 参数传递
   
   子例程通常要求调用它们的代码向它们提供参数值。调用堆栈可以很好地存放这些参数，特别是因为对子例程的每次调用都将在调用堆栈上为这些值分配单独的空间。

# 调用栈结构

调用堆栈由堆栈帧组成 - 包含子程序状态信息的数据结构。什么是状态信息？函数参数、局部变量、返回地址和帧的基地址。 每个堆栈帧对应于对尚未返回的子例程的调用。

例如，如果一个名为 `DrawLine` 的子程序当前正在运行（并且被 `DrawSquare` 调用），则调用堆栈的顶部可能会像图中那样布置（非常粗糙，不要用作参考）：

<img src="https://static.wixstatic.com/media/c52569_32501e853f4841ba9a66823d6ca10734~mv2.png/v1/fill/w_428,h_349,al_c,lg_1,enc_auto/c52569_32501e853f4841ba9a66823d6ca10734~mv2.png" alt="img" style="zoom: 67%;" />

堆栈顶部的堆栈帧用于当前执行的例程。堆栈帧通常至少包括以下项目（按 `push` 顺序）：

- 传递给例程的参数（参数值）（如果有）；
- 返回到例程调用者的返回地址（例如，在 `DrawLine` 堆栈帧中，`DrawSquare` 代码中的地址）；
- 和例程的局部变量的空间（如果有）。

# 堆栈和帧指针

接下来的两段可能非常混乱。如有必要，请一遍又一遍地阅读它们，用笔和纸重复一遍，直到您对所提供的信息感到满意为止。这一点很重要 ：）

回想一下：`ESP` 是堆栈指针——它总是指向堆栈的顶部。

当值被压入堆栈时 - 它会减少。当值从堆栈中弹出时 - 它会增加。

该寄存器不断变化。

在函数执行期间，我们需要一种访问函数数据的方法——它的参数和局部变量。由于 `ESP` 的动态特性 - 我们不能将其用作锚点。相反，我们在调用函数时获取 `ESP` 的值，并将其放入 `EBP` - Base Pointer。在函数执行期间，`EBP` 将保持固定（与 `ESP` 不同）。因此，`EBP` 可以用作访问参数和变量的锚。

请注意，当将 `ESP` 的值移动到 `EBP` 中时，我们会覆盖已经存储在 `EBP` 中的值。出于这个原因，我们需要以某种方式保留 `EBP` 的先前值——这是通过在 `EBP` 收到新值之前将 `EBP` 推入堆栈来完成的。

想象一下 `DrawSquare` 调用 `DrawLine`。 `DrawSquare` 的堆栈帧将首先出现在堆栈上（在更高的地址中）。

1. 当 `DrawLine` 被调用时，当前的 `EBP`（`DrawSqaure` 的基指针）将被压入堆栈。
2. 然后 `EBP` 将被赋 `ESP` 的当前值。从现在开始，`EBP` 被用作 `DrawLine` 的基指针来访问它的变量和参数。
3. 在整个 `DrawLine` 中，`ESP` 可能会多次更改，但 `EBP` 是固定的。
4. 当 `DrawLine` 终止时，`ESP` 将被设置为 `EBP` 的值。这将指向堆栈顶部的指针设置为等于基指针，并实际上释放了在堆栈上为局部变量分配的内存。
5. `DrawSquare` 的 `EBP` 将从堆栈中弹出。从现在开始，`EBP` 可以再次用作 `DrawSquare` 的基指针。

所以，事实上，对于某些函数 `func` 来说，`func` 的栈帧中包含了 `func` 调用者的EBP值，而 `EBP` 寄存器本身就是 `func` 的基指针。

可以看 https://www.youtube.com/watch?v=vcfQVwtoyHY，视频中有动态演示。

# Ollydbg

下载并安装 Ollydbg。

现在我们来实操一下函数堆栈。在 https://drive.google.com/file/d/1cvgVawnk0Y93n9bbLqQ6Srx1hAwx0f54/view?usp=sharing 下载扫雷游戏。

1. 打开 OllyDbg。确保没有错误消息等（您可能需要以管理员身份运行它）。
2. 在 Olly 中，打开扫雷。
3. 按 <kbd>F9</kbd>。这使程序运行到下一个断点 (BP) 或直到需要用户输入。
4. 找到地址 `01003E36` 并单击它以突出显示它。
5. 按 <kbd>F2</kbd> 在该地址中的指令上放置一个 BP。
6. 按 <kbd>F9</kbd>。程序应在地址 `01003E36` 处停止。
7. 按 <kbd>F7</kbd> 进入该功能。
8. 现在按 <kbd>F8</kbd> 跳过指令。
9. 好的，现在关闭所有东西，我们已经完成了这一章：D
