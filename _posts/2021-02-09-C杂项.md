---
layout: post
title:  "【C】杂项"
date:   2021-02-09 00:00:00 +0800
categories: toturial
tags: C 杂项
comments: 1
mathjax: true
---

本文主要罗列了C语言相关的琐碎知识点。

# typedef

C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如有一个结构体的名字是` stu`，要想定义一个结构体变量就得这样写：

```cpp
struct stu stu1;
```

`struct` 看起来就是多余的，但不写又会报错。如果为 `struct stu `起了一个别名 `STU`，书写起来就简单了：

```cpp
STU stu1;
```

这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名。使用关键字 **typedef** 可以为类型起一个新的别名。typedef 的用法一般为：

```cpp
typedef  oldName  newName;
```

`oldName` 是类型原来的名字，`newName` 是类型新的名字。例如：

```cpp
typedef int INTEGER;
INTEGER a, b;
a = 1;b = 2;
```

`INTEGER a, b;`等效于`int a, b;`。

`typedef` 还可以给数组、指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：

```cpp
typedef char ARRAY20[20];
```

表示 `ARRAY20` 是类型`char [20]`的别名。它是一个长度为 20 的数组类型。接着可以用 `ARRAY20` 定义数组：

```cpp
ARRAY20 a1, a2, s1, s2;
```

它等价于：

```cpp
char a1[20], a2[20], s1[20], s2[20];
```

注意，数组也是有类型的。例如`char a1[20];`定义了一个数组` a1`，它的类型就是 `char [20]`。

又如，为结构体类型定义别名：

```cpp
typedef struct stu{   
    char name[20];  
    int age; 
    char sex;
}STU;
```

`STU` 是 `struct stu `的别名，可以用 `STU` 定义结构体变量：

```cpp
STU body1,body2;
```

它等价于：

```cpp
struct stu body1, body2;
```

再如，为指针类型定义别名：

```cpp
typedef int (*PTR_TO_ARR)[4];
```

表示 `PTR_TO_ARR `是类型`int * [4]`的别名，它是一个二维数组指针类型。接着可以使用 `PTR_TO_ARR` 定义二维数组指针：

```cpp
PTR_TO_ARR p1, p2;
```

按照类似的写法，还可以为函数指针类型定义别名：

```
typedef int (*PTR_TO_FUNC)(int, int);
PTR_TO_FUNC pfunc;
```

需要强调的是，`typedef` 是赋予现有类型一个新的名字，而不是创建新的类型。为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。

# const

有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定。例如，用一个变量来表示班级的最大人数，或者表示缓冲区的大小。为了满足这一要求，可以使用`const`关键字对变量加以限定：

```cpp
const int MaxNum = 100;  //班级的最大人数
```

这样` MaxNum` 的值就不能被修改了，任何对 `MaxNum `赋值的行为都将引发错误：

```cpp
MaxNum = 90;  //错误，试图向 const 变量写入数据
```

我们经常将` const` 变量称为常量（Constant）。创建常量的格式通常为：

```cpp
const type name = value;
```

`const` 和 `type` 都是用来修饰变量的，它们的位置可以互换，也就是将 `type` 放在 `const` 前面：

```cpp
type const name = value;
```

但我们通常采用第一种方式，不采用第二种方式。另外建议将常量名的首字母大写，以提醒程序员这是个常量。由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。一如既往，初始化常量可以使用任意形式的表达式，如下所示：

```cpp
#include <stdio.h>int getNum(){    return 100;}int main(){    int n = 90;    const int MaxNum1 = getNum();  //运行时初始化    const int MaxNum2 = n;  //运行时初始化    const int MaxNum3 = 80;  //编译时初始化    printf("%d, %d, %d\n", MaxNum1, MaxNum2, MaxNum3);    return 0;}
```

运行结果：

```
100, 90, 80
```

## const 和指针

`const` 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。`const` 和指针一起使用会有几种不同的顺序，如下所示：

```cpp
const int *p1;
int const *p2;
int * const p3;
```

在最后一种情况下，指针是只读的，也就是 `p3` 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 `p1`、`p2` 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。

当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点：

```cpp
const int * const p4;
int const * const p5;
```

`const` 和指针结合的写法多少有点让初学者摸不着头脑，大家可以这样来记忆：`const` 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。

## const 和函数形参

在C语言中，单独定义 `const` 变量没有明显的优势，完全可以使用`#define`命令代替。`const `通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 `const` 来限制。

在C语言标准库中，有很多函数的形参都被` const `限制了，下面是部分函数的原型：

```cpp
size_t strlen ( const char * str );
int strcmp ( const char * str1, const char * str2 );
char * strcat ( char * destination, const char * source );
char * strcpy ( char * destination, const char * source );
int system (const char* command);
int puts ( const char * str );
int printf ( const char * format, ... );
```

我们自己在定义函数时也可以使用 `const `对形参加以限制，例如查找字符串中某个字符出现的次数：

```cpp
#include <stdio.h>
size_t strnchr(const char *str, char ch)
{    
    int i, n = 0, len = strlen(str); 
    for(i=0; i<len; i++)
    {     
        if(str[i] == ch)
        {    
            n++;     
        }  
    }    
    return n;
}
int main()
{   
    char *str = "hi"; 
    char ch = 't';   
    int n = strnchr(str, ch);  
    printf("%d\n", n);   
    return 0;
}
```

运行结果：

```
3
```

根据` strnchr()` 的功能可以推断，函数内部要对字符串` str` 进行遍历，不应该有修改的动作，用` const` 加以限制，不但可以防止由于程序员误操作引起的字符串修改，还可以给用户一个提示，函数不会修改你提供的字符串，请你放心。

## const 和非 const 类型转换

当一个指针变量 `str1` 被` const` 限制时，并且类似`const char *str1`这种形式，说明指针指向的数据不能被修改；如果将 `str1` 赋值给另外一个未被 `const `修饰的指针变量` str2`，就有可能发生危险。因为通过` str1 `不能修改数据，而赋值后通过` str2` 能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。

也就是说，`const char *`和`char *`是不同的类型，不能将`const char *`类型的数据赋值给`char *`类型的变量。但反过来是可以的，编译器允许将`char *`类型的数据赋值给`const char *`类型的变量。

这种限制很容易理解，`char *`指向的数据有读取和写入权限，而`const char *`指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。

C语言标准库中很多函数的参数都被 `const `限制了，但我们在以前的编码过程中并没有注意这个问题，经常将非` const `类型的数据传递给 `const `类型的形参，这样做从未引发任何副作用，原因就是上面讲到的，将非` const` 类型转换为 `const` 类型是允许的。

下面是一个将 `const` 类型赋值给非 `const` 类型的例子：

```cpp
#include <stdio.h>
void func(char *str)
{ 
}
int main()
{   
    const char *str1 = "hi"; 
    char *str2 = str1;  
    func(str1);  
    return 0;
}
```

第7、8行代码分别通过赋值、传参（传参的本质也是赋值）将 `const` 类型的数据交给了非 `const` 类型的变量，编译器不会容忍这种行为，会给出警告，甚至直接报错。

# struct

在C语言中，可以使用**结构体（Struct）**来存放一组不同类型的数据。结构体的定义形式为：

```cpp
struct 结构体名{
  结构体所包含的变量或数组
};
```

结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。请看下面的一个例子：

```cpp
struct stu{  
    char *name;  //姓名   
    int num;  //学号    
    int age;  //年龄   
    char group;  //所在学习小组  
    float score;  //成绩
};
```

`stu` 为结构体名，它包含了 5 个成员，分别是 `name`、`num`、`age`、`group`、`score`。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。

> 注意大括号后面的分号`;`不能少，这是一条完整的语句。

结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据。

像 `int`、`float`、`char` 等是由C语言本身提供的数据类型，不能再进行分拆，我们称之为基本数据类型；而结构体可以包含多个基本类型的数据，也可以包含其他的结构体，我们将它称为复杂数据类型或构造数据类型。

## 结构体变量

既然结构体是一种数据类型，那么就可以用它来定义变量。例如：

```cpp
struct stu stu1, stu2;
```

定义了两个变量 `stu1 `和` stu2`，它们都是` stu` 类型，都由 5 个成员组成。注意关键字`struct`不能少。

`stu `就像一个“模板”，定义出来的变量都具有相同的性质。也可以将结构体比作“图纸”，将结构体变量比作“零件”，根据同一张图纸生产出来的零件的特性都是一样的。

你也可以在定义结构体的同时定义结构体变量：

```cpp
struct stu{   
    char *name;  //姓名 
    int num;  //学号 
    int age;  //年龄  
    char group;  //所在学习小组 
    float score;  //成绩
} stu1, stu2;
```

将变量放在结构体定义的最后即可。

如果只需要 `stu1`、`stu2` 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：

```cpp
struct{ 
    //没有写 stu 
    char *name;  //姓名   
    int num;  //学号   
    int age;  //年龄  
    char group;  //所在学习小组 
    float score;  //成绩
} stu1, stu2;
```

这样做书写简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量。
理论上讲结构体的各个成员在内存中是连续存储的，和数组非常类似，例如上面的结构体变量 `stu1`、`stu2 `的内存分布如下图所示，共占用 4+4+4+1+4 = 17 个字节。

![img](http://c.biancheng.net/uploads/allimg/190118/150GQ243-0.jpg)


但是在编译器的具体实现中，各个成员之间可能会存在缝隙，对于` stu1`、`stu2`，成员变量 `group `和` score` 之间就存在 3 个字节的空白填充（见下图）。这样算来，`stu1`、`stu2` 其实占用了 17 + 3 = 20 个字节。

![img](http://c.biancheng.net/uploads/allimg/190118/150GUE0-1.jpg)


## 成员的获取和赋值

结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标`[ ]`获取单个元素，结构体使用点号`.`获取单个成员。获取结构体成员的一般格式为：

```cpp
结构体变量名.成员名;
```

通过这种方式可以获取成员的值，也可以给成员赋值：

```cpp
#include <stdio.h>
int main()
{   
    struct{    
        char *name;  //姓名 
        int num;  //学号       
        int age;  //年龄      
        char group;  //所在小组    
        float score;  //成绩  
    } stu1;   
    //给结构体成员赋值   
    stu1.name = "Tom";   
    stu1.num = 12;  
    stu1.age = 18; 
    stu1.group = 'A'; 
    stu1.score = 136.5;   
    //读取结构体成员的值 
    printf("%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n", stu1.name, stu1.num, stu1.age, stu1.group, stu1.score);  
    return 0;
}
```

运行结果：

```
Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！
```

除了可以对成员进行逐一赋值，也可以在定义时整体赋值，例如：

```cpp
struct{    
    char *name;  //姓名  
    int num;  //学号   
    int age;  //年龄  
    char group;  //所在小组  
    float score;  //成绩
} stu1, stu2 = { "Tom", 12, 18, 'A', 136.5 };
```

不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。

需要注意的是，结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储。

# enum

在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用，比如一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。

以每周七天为例，我们可以使用`#define`命令来给每天指定一个名字：`#define`命令虽然能解决问题，但也带来了不小的副作用，导致宏名过多，代码松散，看起来总有点不舒服。C语言提供了一种**枚举（`Enum`）类型**，能够列出所有可能的取值，并给它们取一个名字。

枚举类型的定义形式为：

```cpp
enum typeName{ valueName1, valueName2, valueName3, ...... };
```

`enum`是一个新的关键字，专门用来定义枚举类型，这也是它在C语言中的唯一用途；`typeName`是枚举类型的名字；`valueName1, valueName2, valueName3, ......`是每个值对应的名字的列表。注意最后的`;`不能少。

例如，列出一个星期有几天：

```cpp
enum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };
```

可以看到，我们仅仅给出了名字，却没有给出名字对应的值，这是因为枚举值默认从 0 开始，往后逐个加 1（递增）；也就是说，`week` 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。

我们也可以给每个名字都指定一个值：

```cpp
enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };
```

更为简单的方法是只给第一个名字指定值：

```cpp
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
```

这样枚举值就从 1 开始递增，跟上面的写法是等效的。

枚举是一种类型，通过它可以定义枚举变量：

```cpp
enum week a, b, c;
```

也可以在定义枚举类型的同时定义变量：

```cpp
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a, b, c;
```

有了枚举变量，就可以把列表中的值赋给它：

```cpp
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
enum week a = Mon, b = Wed, c = Sat;
```

或者：

```cpp
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a = Mon, b = Wed, c = Sat;
```

例如判断用户输入的是星期几：

```cpp
#include <stdio.h>
int main(){
    enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day;
    scanf("%d", &day);
    switch(day){
        case Mon: puts("Monday"); break;
        case Tues: puts("Tuesday"); break;
        case Wed: puts("Wednesday"); break;
        case Thurs: puts("Thursday"); break;
        case Fri: puts("Friday"); break;
        case Sat: puts("Saturday"); break;
        case Sun: puts("Sunday"); break;
        default: puts("Error!");
    }
    return 0;
}
```

需要注意的两点是：

1. 枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 `main()` 函数内部），不能再定义与它们名字相同的变量。

2. Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。

枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。

对于上面的代码，在编译的某个时刻会变成类似下面的样子：

```cpp
#include <stdio.h>
int main(){
    enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day;
    scanf("%d", &day);
    switch(day){
        case 1: puts("Monday"); break;
        case 2: puts("Tuesday"); break;
        case 3: puts("Wednesday"); break;
        case 4: puts("Thursday"); break;
        case 5: puts("Friday"); break;
        case 6: puts("Saturday"); break;
        case 7: puts("Sunday"); break;
        default: puts("Error!");
    }
    return 0;
}
```

Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用`&`取得它们的地址。这就是枚举的本质。

case 关键字后面必须是一个整数，或者是结果为整数的表达式，但不能包含任何变量，正是由于 Mon、Tues、Wed 这些名字最终会被替换成一个整数，所以它们才能放在 case 后面。

枚举类型变量需要存放的是一个整数，我猜测它的长度和 int 应该相同，下面来验证一下：

```cpp
#include <stdio.h>
int main(){
    enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day = Mon;
    printf("%d, %d, %d, %d, %d\n", sizeof(enum week), sizeof(day), sizeof(Mon), sizeof(Wed), sizeof(int) );
    return 0;
}
```

运行结果：

```
4, 4, 4, 4, 4
```

# union

通过前面的讲解，我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做**共用体（Union）**，它的定义格式为：

```cpp
union 共用体名{
  成员列表
};
```

> 共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。

结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。

结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

共用体也是一种自定义类型，可以通过它来创建变量，例如：

```cpp
union data{   
    int n;
    char ch; 
    double f;
};
union data a, b, c;
```

上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：

```cpp
union data{ 
    int n;  
    char ch; 
    double f;
} a, b, c;
```

如果不再定义新的变量，也可以将共用体的名字省略：

```cpp
union{   
    int n;   
    char ch;   
    double f;
} a, b, c;
```

共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存，请看下面的演示：

```cpp
#include <stdio.h>
union data{
    int n;
    char ch;
    short m;
};
int main(){
    union data a;
    printf("%d, %d\n", sizeof(a), sizeof(union data) );
    a.n = 0x40;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    a.ch = '9';
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    a.m = 0x2059;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    a.n = 0x3E25AD54;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
   
    return 0;
}
```

运行结果：

```
4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
```

这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。

要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 data 为例，各个成员在内存中的分布如下：
![img](http://c.biancheng.net/uploads/allimg/190118/152553G12-0.jpg)
成员 n、ch、m 在内存中“对齐”到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对 n 赋值修改的是全部字节。也就是说，ch、m 会影响到 n 的一部分数据，而 n 会影响到 ch、m 的全部数据。

上图是在绝大多数 PC 机上的内存分布情况，如果是 51 单片机，情况就会有所不同：
![img](http://c.biancheng.net/uploads/allimg/190118/1525532T7-1.jpg)

## 共用体的应用

共用体在一般的编程中应用较少，在单片机中应用较多。对于 PC 机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：

| Name        | Num  | Sex  | Profession | Score / Course |
| ----------- | ---- | ---- | ---------- | -------------- |
| HanXiaoXiao | 501  | f    | s          | 89.5           |
| YanWeiMin   | 1011 | m    | t          | math           |
| LiuZhenTao  | 109  | f    | t          | English        |
| ZhaoFeiYan  | 982  | m    | s          | 95.0           |


f 和 m 分别表示女性和男性，s 表示学生，t 表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。

如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前 4 个成员变量是一样的，第 5 个成员变量可能是 score 或者 course。当第 4 个成员变量的值是 s 的时候，第 5 个成员变量就是 score；当第 4 个成员变量的值是 t 的时候，第 5 个成员变量就是 course。

经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码：

```cpp
#include <stdio.h>
#include <stdlib.h>
#define TOTAL 4  //人员总数
struct{
    char name[20];
    int num;
    char sex;
    char profession;
    union{
        float score;
        char course[20];
    } sc;
} bodys[TOTAL];
int main(){
    int i;
    //输入人员信息
    for(i=0; i<TOTAL; i++){
        printf("Input info: ");
        scanf("%s %d %c %c", bodys[i].name, &(bodys[i].num), &(bodys[i].sex), &(bodys[i].profession));
        if(bodys[i].profession == 's'){  //如果是学生
            scanf("%f", &bodys[i].sc.score);
        }else{  //如果是老师
            scanf("%s", bodys[i].sc.course);
        }
        fflush(stdin);
    }

    //输出人员信息
    printf("\nName\t\tNum\tSex\tProfession\tScore / Course\n");
    for(i=0; i<TOTAL; i++){
        if(bodys[i].profession == 's'){  //如果是学生
            printf("%s\t%d\t%c\t%c\t\t%f\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score);
        }else{  //如果是老师
            printf("%s\t%d\t%c\t%c\t\t%s\n", bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course);
        }
    }
    return 0;
}
```

运行结果：

```
Input info: HanXiaoXiao 501 f s 89.5↙
Input info: YanWeiMin 1011 m t math↙
Input info: LiuZhenTao 109 f t English↙
Input info: ZhaoFeiYan 982 m s 95.0↙

Name            Num     Sex     Profession      Score / Course
HanXiaoXiao     501     f       s               89.500000
YanWeiMin       1011    m       t               math
LiuZhenTao      109     f       t               English
ZhaoFeiYan      982     m       s               95.000000
```

# 输入输出

## scanf&printf

格式控制符：

| 格式控制符                      | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| %c                              | 输出一个单一的字符                                           |
| %hd、%d、%ld                    | 以十进制、有符号的形式输出 short、int、long 类型的整数       |
| %hu、%u、%lu                    | 以十进制、无符号的形式输出 short、int、long 类型的整数       |
| %ho、%o、%lo                    | 以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %#ho、%#o、%#lo                 | 以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %hx、%x、%lx %hX、%X、%lX       | 以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。 |
| %#hx、%#x、%#lx %#hX、%#X、%#lX | 以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。 |
| %f、%lf                         | 以十进制的形式输出 float、double 类型的小数                  |
| %e、%le %E、%lE                 | 以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。 |
| %g、%lg %G、%lG                 | 以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。 |
| %s                              | 输出一个字符串                                               |

### scanf

| 类型         | 示例                     | 作用             |
| ------------ | ------------------------ | ---------------- |
| `%[num]type` | `%2d`,`%10s`             | 控制读入数据长度 |
| `%[]`        | `%[a-z]`,`%[a-z-A-Z0-9]` | 匹配字符         |
| `%*[]`       | `%*d`,`%*[a-z]`,`%*[^]`  | 丢弃字符         |

### printf

```cpp
%[flag][width][.precision]type
```

- `type`为数据类型

- `width`为最小宽度，不足用空格补齐，超出则按照数据本身宽度

- `.precision`为输出精度

  - 小数：>precision，四舍五入丢掉多余数字；<precision，后面补0
  - 整数：最小输出宽度，左边补0
  - 字符串：最大输出宽度，>precision，截掉多余字符；<precision，正常输出

- `flag`

  | 标志字符 | 含  义                                                       |
  | :------- | :----------------------------------------------------------- |
  | `-`      | `-`表示左对齐。如果没有，就按照默认的对齐方式，默认一般为右对齐。 |
  | `+`      | 用于整数或者小数，表示输出符号（正负号）。如果没有，那么只有负数才会输出符号。 |
  | 空格     | 用于整数或者小数，输出值为正时冠以空格，为负时冠以负号。     |
  | `#`      | 对于八进制（%o）和十六进制（%x / %X）整数，# 表示在输出时添加前缀；八进制的前缀是 0，十六进制的前缀是 0x / 0X。对于小数（%f / %e / %g），# 表示强迫输出小数点。如果没有小数部分，默认是不输出小数点的，加上 # 以后，即使没有小数部分也会带上小数点。 |

## 字符和字符串

### 字符

| 函数      | 缓冲区 | 头文件  | 回显 | 适用平台                          |
| :-------- | :----- | :------ | :--- | :-------------------------------- |
| getchar() | 有     | stdio.h | 有   | Windows、Linux、Mac OS 等所有平台 |
| getche()  | 无     | conio.h | 有   | Windows                           |
| getch()   | 无     | conio.h | 无   | Windows                           |

### 字符串

| 函数    | 读入空格 |
| ------- | -------- |
| gets()  | 是       |
| scanf() | 否       |

# 字符串

C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 **null** 字符 '\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。

下面的声明和初始化创建了一个 "Hello" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 "Hello" 的字符数多一个。

```cpp
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

依据数组初始化规则，您可以把上面的语句写成以下语句：

```cpp
char greeting[] = "Hello";
```

以下是 C/C++ 中定义的字符串的内存表示：

![C/C++ 中的字符串表示](https://www.runoob.com/wp-content/uploads/2014/08/string_representation.jpg)

其实，您不需要把 `null`字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '\0' 放在字符串的末尾。让我们尝试输出上面的字符串：

```cpp
#include <iostream> 
using namespace std;  
int main () 
{  
    char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; 
    cout << "Greeting message: ";   
    cout << greeting << endl; 
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Greeting message: Hello
```

C++ 中有大量的函数用来操作以 null 结尾的字符串：

| 函数           | 目的                                                         |
| :------------- | :----------------------------------------------------------- |
| strcpy(s1, s2) | 复制字符串 s2 到字符串 s1。                                  |
| strcat(s1, s2) | 连接字符串 s2 到字符串 s1 的末尾。                           |
| strlen(s1)     | 返回字符串 s1 的长度。                                       |
| strcmp(s1, s2) | 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| strchr(s1, ch) | 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。   |
| strstr(s1, s2) | 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

下面的实例使用了上述的一些函数：

```cpp
#include <iostream>
#include <cstring>  
using namespace std; 
int main () 
{   
    char str1[11] = "Hello"; 
    char str2[11] = "World"; 
    char str3[11];  
    int  len ;  
    // 复制 str1 到 str3 
    strcpy( str3, str1);  
    cout << "strcpy( str3, str1) : " << str3 << endl;    
    // 连接 str1 和 str2   
    strcat( str1, str2);  
    cout << "strcat( str1, str2): " << str1 << endl; 
    // 连接后，str1 的总长度 
    len = strlen(str1);   
    cout << "strlen(str1) : " << len << endl;  
    return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
strcpy( str3, str1) : Hello
strcat( str1, str2): HelloWorld
strlen(str1) : 10
```

