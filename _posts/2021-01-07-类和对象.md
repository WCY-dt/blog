---
layout: post
title:  "【C++】类和对象 <img src='https://img.shields.io/badge/-转载-C9284D?style=flat'>"
date:   2021-01-07 00:00:00 +0800
categories: toturial
tags: C++ 面向对象
comments: 1
mathjax: true
---

本文是C++类和对象系列第一篇：类和对象基础。

# 类和对象

C++是一门面向对象的编程语言，理解 C++，首先要理解<mark>类</mark>（Class）和<mark>对象</mark>（Object）这两个概念。

C++ 中的类可以看做C语言中<mark>结构体</mark>（Struct）的升级版。结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。例如：

```cpp
#include <stdio.h>

//定义结构体 Student
struct Student{
    //结构体包含的成员变量
    char *name;
    int age;
    float score;
};
//显示结构体的成员变量
void display(struct Student stu){
    printf("%s的年龄是 %d，成绩是 %f\n", stu.name, stu.age, stu.score);
}

int main(){
    struct Student stu1;
    //为结构体的成员变量赋值
    stu1.name = "小明";
    stu1.age = 15;
    stu1.score = 92.5;
    //调用函数
    display(stu1);

    return 0;
}
```

运行结果：

```
小明的年龄是 15，成绩是 92.500000
```

C++ 中的类也是一种构造类型，但是进行了一些扩展，**类的成员不但可以是变量，还可以是函数**；通过类定义出来的变量也有特定的称呼，叫做“对象”。例如：

```cpp
#include <stdio.h>

//通过class关键字类定义类
class Student{
public:
    //类包含的变量
    char *name;
    int age;
    float score;
    //类包含的函数
    void say(){
        printf("%s的年龄是 %d，成绩是 %f\n", name, age, score);
    }
};

int main(){
    //通过类来定义变量，即创建对象
    class Student stu1;  //也可以省略关键字class
    //为类的成员变量赋值
    stu1.name = "小明";
    stu1.age = 15;
    stu1.score = 92.5f;
    //调用类的成员函数
    stu1.say();

    return 0;
}
```

运行结果与上例相同。

> 对于熟悉 C++ 的读者，这段代码并不规范，请忽略这一细节，本节的重点是引入类和对象的概念。

`class` 和 `public` 都是 C++ 中的关键字。

C语言中的 `struct `只能包含变量，而 C++ 中的 `class` 除了可以包含变量，还可以包含函数。`display()` 是用来处理成员变量的函数，在C语言中，我们将它放在了 `struct Student` 外面，它和成员变量是分离的；而在 C++ 中，我们将它放在了 `class Student` 内部，使它和成员变量聚集在一起，看起来更像一个整体。

结构体和类都可以看做一种由用户自己定义的复杂数据类型，在C语言中可以通过结构体名来定义变量，在 C++ 中可以通过类名来定义变量。不同的是，通过结构体定义出来的变量还是叫变量，而通过类定义出来的变量有了新的名称，叫做对象。

在第二段代码中，我们先通过 `class` 关键字定义了一个类 `Student`，然后又通过 `Student` 类创建了一个对象 `stu1`。变量和函数都是类的成员，创建对象后就可以通过点号`.`来使用它们。

可以将类比喻成图纸，对象比喻成零件，图纸说明了零件的参数（成员变量）及其承担的任务（成员函数）；一张图纸可以生产出多个具有相同性质的零件，不同图纸可以生产不同类型的零件。类只是一张图纸，起到说明的作用，不占用内存空间；对象才是具体的零件，要有地方来存放，才会占用内存空间。在 C++ 中，通过类名就可以创建对象，即将图纸生产成零件，这个过程叫做类的实例化，因此也称对象是类的一个<mark>实例</mark>（Instance）。

有些资料也将类的成员变量称为<mark>属性</mark>（Property），将类的成员函数称为<mark>方法</mark>（Method）。

## Object Oriented Programming

类是一个通用的概念，C++、Java、C#、PHP 等很多编程语言中都支持类，都可以通过类创建对象。可以将类看做是结构体的升级版，C语言的晚辈们看到了C语言的不足，尝试加以改善，继承了结构体的思想，并进行了升级，让程序员在开发或扩展大中型项目时更加容易。

因为 C++、Java、C#、PHP 等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言。

在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，将拥有相关功能的多个函数放在一个源文件，再提供一个对应的头文件，这就是一个模块。使用模块时，引入对应的头文件就可以。

而在 C++ 中，多了一层封装，就是类。类由一组相关联的函数、变量组成，你可以将一个类或多个类放在一个源文件，使用时引入对应的类就可以。下面是C和C++项目组织方式的对比：

C语言中项目的组织方式：

![C语言中项目的组织方式](http://c.biancheng.net/uploads/allimg/190212/100PJ491-0.png)

C++中项目的组织方式：

![C++中项目的组织方式](http://c.biancheng.net/uploads/allimg/190212/100PK0J-1.png)

不要小看类这一层封装，它有很多特性，极大地方便了中大型程序的开发，它让 C++ 成为面向对象的语言。

面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。

面向对象编程是针对开发中大规模的程序而提出来的，目的是提高软件开发的效率。不要把面向对象和面向过程对立起来，面向对象和面向过程不是矛盾的，而是各有用途、互为补充的。如果你希望开发一个贪吃蛇游戏，类和对象或许是多余的，几个函数就可以搞定；但如果开发一款大型游戏，那你绝对离不开面向对象。

# 类和对象的定义

## 类的定义

类是用户自定义的类型，如果程序中要用到类，必须提前说明，或者使用已存在的类（别人写好的类、标准库中的类等），C++语法本身并不提供现成的类的名称、结构和内容。

一个简单的类的定义：

```cpp
class Student{
public:
    //成员变量
    char *name;
    int age;
    float score;

    //成员函数
    void say(){
        cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
    }
};
```

`class`是 C++ 中新增的关键字，专门用来定义类。`Student`是类的名称；类名的首字母一般大写，以和其他的标识符区分开。`{ }`内部是类所包含的成员变量和成员函数，它们统称为类的<mark>成员</mark>（Member）；由`{ }`包围起来的部分有时也称为类体，和函数体的概念类似。`public`也是 C++ 的新增关键字，它只能用在类的定义中，表示类的成员变量或成员函数具有“公开”的访问权限。

> **注意在类定义的最后有一个分号`;`**，它是类定义的一部分，表示类定义结束了，不能省略。

整体上讲，上面的代码创建了一个 `Student` 类，它包含了 3 个成员变量和 1 个成员函数。

类只是一个<mark>模板</mark>（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。

类可以理解为一种新的数据类型，该数据类型的名称是 `Student`。与` char`、`int`、`float` 等基本数据类型不同的是，`Student `是一种复杂数据类型，可以包含基本类型，而且还有很多基本类型中没有的特性，以后大家会见到。

## 创建对象

有了 `Student` 类后，就可以通过它来创建对象了，例如：

```cpp
Student liLei;  //创建对象
```

`Student`是类名，`liLei`是对象名。这和使用基本类型定义变量的形式类似：

```cpp
int a;  //定义整型变量
```

从这个角度考虑，我们可以把 `Student` 看做一种新的数据类型，把 `liLei` 看做一个变量。

在创建对象时，`class` 关键字可要可不要，但是出于习惯我们通常会省略掉 `class` 关键字，例如：

```cpp
class Student LiLei;  //正确
Student LiLei;  //同样正确
```

除了创建单个对象，还可以创建对象数组：

```cpp
Student allStu[100];
```

该语句创建了一个 `allStu` 数组，它拥有100个元素，每个元素都是 `Student` 类型的对象。

## 访问类的成员

创建对象以后，可以使用点号`.`来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似，如下所示：

```cpp
#include <iostream>
using namespace std;

//类通常定义在函数外面
class Student{
public:
    //类包含的变量
    char *name;
    int age;
    float score;
    //类包含的函数
    void say(){
        cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
    }
};

int main(){
    //创建对象
    Student stu;
    stu.name = "小明";
    stu.age = 15;
    stu.score = 92.5f;
    stu.say();

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是92.5
```

`stu` 是一个对象，占用内存空间，可以对它的成员变量赋值，也可以读取它的成员变量。

类通常定义在函数外面，当然也可以定义在函数内部，不过很少这样使用。

## 使用对象指针

C语言中经典的指针在 C++ 中仍然广泛使用，尤其是指向对象的指针，没有它就不能实现某些功能。

上面代码中创建的对象 `stu` 在栈上分配内存，需要使用`&`获取它的地址，例如：

```cpp
Student stu;
Student *pStu = &stu;
```

`pStu` 是一个指针，它指向 `Student` 类型的数据，也就是通过 `Student` 创建出来的对象。

当然，你也可以在堆上创建对象，这个时候就需要使用前面讲到的`new`关键字，例如：

```cpp
Student *pStu = new Student;
```

在栈上创建出来的对象都有一个名字，比如 `stu`，使用指针指向它不是必须的。但是通过 `new `创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。

栈内存是程序自动管理的，不能使用 delete 删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过 delete 删除。在实际开发中，`new` 和 `delete` 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。

有了对象指针后，可以通过箭头`->`来访问对象的成员变量和成员函数，这和通过结构体指针来访问它的成员类似，请看下面的示例：

```cpp
pStu -> name = "小明";
pStu -> age = 15;
pStu -> score = 92.5f;
pStu -> say();
```

下面是一个完整的例子：

```cpp
#include <iostream>
using namespace std;

class Student{
public:
    char *name;
    int age;
    float score;

    void say(){
        cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
    }
};

int main(){
    Student *pStu = new Student;
    pStu -> name = "小明";
    pStu -> age = 15;
    pStu -> score = 92.5f;
    pStu -> say();
    delete pStu;  //删除对象

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是92.5
```

虽然在一般的程序中无视垃圾内存影响不大，但记得 delete 掉不再使用的对象依然是一种良好的编程习惯。

# 成员变量&成员函数

类可以看做是一种数据类型，它类似于普通的数据类型，但是又有别于普通的数据类型。类这种数据类型是一个包含成员变量和成员函数的集合。

类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。但是，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。

类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。

上节我们在示例中给出了 `Student `类的定义，如下所示：

```cpp
class Student{
public:
    //成员变量
    char *name;
    int age;
    float score;

    //成员函数
    void say(){
        cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
    }
};
```

这段代码在类体中定义了成员函数。你也可以只在类体中声明函数，而将函数定义放在类体外面，如下图所示：

```cpp
class Student{
public:
    //成员变量
    char *name;
    int age;
    float score;

    //成员函数
    void say();  //函数声明
};

//函数定义
void Student::say(){
    cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
}
```

在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。

但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。`::`被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。

成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。

## 在类体中和类体外定义成员函数的区别

在类体中和类体外定义成员函数是有区别的：在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加 `inline` 关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。

内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。

当然，如果你的函数比较短小，希望定义为内联函数，那也没有什么不妥的。

如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 `inline` 关键字。当然你也可以在函数声明处加 `inline`，不过这样做没有效果，编译器会忽略函数声明处的 `inline`。

下面是一个将内联函数定义在类外部的例子：

```cpp
class Student{
public:
    char *name;
    int age;
    float score;

    void say();  //内联函数声明，可以增加 inline 关键字，但编译器会忽略
};

//函数定义
inline void Student::say(){
    cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
}
```

这样，`say()` 就会变成内联函数。

这种在类体外定义` inline` 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出）。

# 成员访问权限&类的封装

前面我们在定义类时多次使用到了 `public` 关键字，表示类的成员具有“公开”的访问权限，这节我们就来详细讲解。

C++通过 `public`、`protected`、`private` 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。

> Java、C#程序员注意，C++ 中的 `public`、`private`、`protected` 只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。

在类的内部（定义类的代码内部），无论成员被声明为 `public`、`protected` 还是 `private`，都是可以互相访问的，没有访问权限的限制。

在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 `public` 属性的成员，不能访问 `private`、`protected` 属性的成员。

下面通过一个 `Student` 类来演示成员的访问权限：

```cpp
#include <iostream>
using namespace std;

//类的声明
class Student{
private:  //私有的
    char *m_name;
    int m_age;
    float m_score;

public:  //共有的
    void setname(char *name);
    void setage(int age);
    void setscore(float score);
    void show();
};

//成员函数的定义
void Student::setname(char *name){
    m_name = name;
}
void Student::setage(int age){
    m_age = age;
}
void Student::setscore(float score){
    m_score = score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    //在栈上创建对象
    Student stu;
    stu.setname("小明");
    stu.setage(15);
    stu.setscore(92.5f);
    stu.show();

    //在堆上创建对象
    Student *pstu = new Student;
    pstu -> setname("李华");
    pstu -> setage(16);
    pstu -> setscore(96);
    pstu -> show();

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是92.5
李华的年龄是16，成绩是96
```

类的声明和成员函数的定义都是类定义的一部分，在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。

类中的成员变量 `m_name`、`m_age` 和`m_ score` 被设置成 `private` 属性，在类的外部不能通过对象访问。也就是说，私有成员变量和成员函数只能在类内部使用，在类外都是无效的。

成员函数 `etname()`、`setage()` 和 `setscore()` 被设置为 `public` 属性，是公有的，可以通过对象访问。

`private` 后面的成员都是私有的，直到有 `public` 出现才会变成共有的；`public` 之后再无其他限定符，所以 public 后面的成员都是共有的。

成员变量大都以`m_`开头，这是约定成俗的写法，不是语法规定的内容。以`m_`开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。

以 `setname()` 为例，如果将成员变量`m_name`的名字修改为`name`，那么 `setname()` 的形参就不能再叫`name`了，得换成诸如`name1`、`_name`这样没有明显含义的名字，否则`name=name;`这样的语句就是给形参`name`赋值，而不是给成员变量`name`赋值。

因为三个成员变量都是私有的，不能通过对象直接访问，所以必须借助三个 `public` 属性的成员函数来修改它们的值。下面的代码是错误的：

```cpp
Student stu;
//m_name、m_age、m_score 是私有成员变量，不能在类外部通过对象访问
stu.m_name = "小明";
stu.m_age = 15;
stu.m_score = 92.5f;
stu.show();
```

## 简单地谈类的封装

`private` 关键字的作用在于更好地隐藏类的内部实现，该向外暴露的接口（能通过对象访问的成员）都声明为 `public`，不希望外部知道、或者只在类内部使用的、或者对外部没有影响的成员，都建议声明为 `private`。

根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 `private`，而只将允许通过对象调用的成员函数声明为 `public`。

> 另外还有一个关键字 `protected`，声明为 `protected` 的成员在类外也不能通过对象访问，但是在它的派生类内部可以访问，这点我们将在后续章节中介绍，现在你只需要知道 `protected` 属性的成员在类外无法访问即可。

有读者可能会提出疑问，将成员变量都声明为 `private`，如何给它们赋值呢，又如何读取它们的值呢？

我们可以额外添加两个 `public` 属性的成员函数，一个用来设置成员变量的值，一个用来获取成员变量的值。上面的代码中，`setname()`、`setage()`、`setscore()` 函数就用来设置成员变量的值；如果希望获取成员变量的值，可以再添加三个函数 `getname()`、`getage()`、`getscore()`。

给成员变量赋值的函数通常称为 `set` 函数，它们的名字通常以`set`开头，后跟成员变量的名字；读取成员变量的值的函数通常称为 `get` 函数，它们的名字通常以`get`开头，后跟成员变量的名字。

除了` set `函数和 `get` 函数，在创建对象时还可以调用构造函数来初始化各个成员变量。不过构造函数只能给成员变量赋值一次，以后再修改还得借助 `set` 函数。

这种将成员变量声明为 `private`、将部分成员函数声明为 `public` 的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。

有读者可能会说，额外添加 `set `函数和 `get` 函数多麻烦，直接将成员变量设置为 `public `多省事！确实，这样做 99.9% 的情况下都不是一种错误，我也不认为这样做有什么不妥；但是，将成员变量设置为 `private` 是一种软件设计规范，尤其是在大中型项目中，还是请大家尽量遵守这一原则。

## 对`private`和`public`的更多说明

声明为 `private` 的成员和声明为 `public` 的成员的次序任意，既可以先出现 `private` 部分，也可以先出现 `public` 部分。如果既不写 `private` 也不写 `public`，就默认为 `private`。

在一个类体中，`private` 和 `public `可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。但是为了使程序清晰，应该养成这样的习惯，使每一种成员访问限定符在类定义体中只出现一次。

下面的类声明也是完全正确的：

```cpp
class Student{
private:
    char *m_name;
private:
    int m_age;
    float m_score;
public:
    void setname(char *name);
    void setage(int age);
public:
    void setscore(float score);
    void show();
};
```

# 对象的内存模型

当对象被创建时，编译器会为每个对象分配内存空间，包括成员变量和成员函数。

直观的认识是，如果定义了10个对象，那么就要分别为这10个对象的变量和函数分配内存空间，如下图所示：

![img](http://c.biancheng.net/cpp/uploads/allimg/150909/1-150Z9134434637.png)

虽然每个对象的成员变量不同，但是成员函数的代码却是一样的，上面的内存模型保存了10份相同的代码片段，浪费了很多空间。

事实上，编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。如下图所示：

![img](http://c.biancheng.net/cpp/uploads/allimg/150909/1-150Z9135223356.png)

请看下面的一个例子：

```cpp
#include<iostream>
using namespace std;

class Demo{
public:
    int a;
    float b;
    void display();
};
void Demo::display(){
    cout<<"a="<<a<<", b="<<b<<endl;
}

int main(){
    Demo obj;
    obj.a = 1;
    obj.b = 2;
    obj.display();

    return 0;
}
```

`obj` 既是对象，也是 `main` 函数中的局部变量，类型为 `Demo`，它和通过 `int`、`char` 等定义出来的普通变量一样，都在栈区分配内存。

假设 `obj` 的起始地址为 `0X1000`，那么它的内存分布如下图所示：

![img](http://c.biancheng.net/cpp/uploads/allimg/150909/1-150Z9162122339.png)

`a`、`b` 都为` int` 类型，占用4个字节内存，并且按照声明时的顺序依次排列，所以 `obj` 对象总共占用8个字节的内存。读者可以使用 `sizeof(obj)`语句亲测。

对象的大小只受成员变量的影响，和成员函数没有关系。成员函数在代码区分配内存，而不是在栈区。

# 函数编译原理&成员函数实现

从上节的例子可以看出，对象的内存模型中只保留了成员变量，除此之外没有任何其他信息，程序运行时不知道 `obj` 的类型为` Demo`，也不知道它还有一个成员函数 `display()`。那么，究竟是如何通过对象调用成员函数的呢？

## C++函数的编译

C++和C语言的编译方式不同。C语言中的函数在编译时名字不变，或者只是简单的加一个下划线 `_`（不同的编译器有不同的实现），例如，`func()` 编译后为 `func()` 或 `_func()`。

而C++中的函数在编译时会根据命名空间、类、参数签名等信息进行重新命名，形成新的函数名。这个重命名的过程是通过一个特殊的算法来实现的，称为<mark>名字编码</mark>（Name Mangling）。

Name Mangling 是一种可逆的算法，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。Name Mangling 可以确保新函数名的唯一性，只要命名空间、所属的类、参数签名等有一个不同，那么产生的新函数名也不同。

如果你希望看到经算法产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到。请看下面的代码：

```cpp
#include<iostream>  
using namespace std;  
  
void display();  
void display(int);  
  
namespace ns{  
    void display();  
}  
  
class Demo{  
public:  
    void display();  
};  
  
int main(){  
    display();  
    display(1);  
    ns::display();  
    Demo obj;  
    obj.display();  
  
    return 0;  
}  
```

该例中声明了四个同名函数，包括两个具有重载关系的全局函数，一个位于命名空间 ns 下的函数，以及一个属于类 `Demo` 的函数。它们都是只声明而未定义的函数。

编译源代码即可看到错误信息：

![img](http://c.biancheng.net/cpp/uploads/allimg/150909/1-150Z91ZU0P1.png)

小括号中就是 Name Mangling 产生的新函数名，它们都以`?`开始，以区别C语言中的`_`。上图是VS2010产生的错误信息，不同的编译器有不同的 Name Mangling 算法，产生的函数名也不一样。除了函数，某些变量也会经 Name Mangling 算法产生新名字，不再赘述。

## 成员函数的调用

从上图可以看出，成员函数最终被编译成与对象无关的普通函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。

如果成员函数中使用到了成员变量，该怎么办呢？成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。

假设 `Demo` 类有两个 `int` 型的成员变量，分别是 `a` 和 `b`，并且在成员函数 `display()` 中使用到了，如下所示：

```cpp
void Demo::display(){  
    cout<<a<<endl;  
    cout<<b<<endl;  
}  
```

那么编译后的形式类似于：

```cpp
void new_function_name(const Demo *p){  
    //通过指针p来访问a、b  
    cout<<p->a<<endl;  
    cout<<p->b<<endl;  
}  
```

调用时的形式类似于：

```cpp
new_function_name(&obj);
```

这样就完成了对象和成员函数的关联，只不过与我们从表明上看到的相反，不是通过对象找函数，而是通过函数找对象。这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。

# 构造函数

在C++中，有一种特殊的成员函数，它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是<mark>构造函数</mark>（Constructor）。

在成员的访问权限以及类的封装一节中，我们通过成员函数 `setname()`、`setage()`、`setscore() `分别为成员变量 `name`、`age`、`score` 赋值，这样做虽然有效，但显得有点麻烦。有了构造函数，我们就可以简化这项工作，在创建对象的同时为成员变量赋值，请看下面的代码：

```cpp
#include <iostream>
using namespace std;

class Student{
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    //声明构造函数
    Student(char *name, int age, float score);
    //声明普通成员函数
    void show();
};

//定义构造函数
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
//定义普通成员函数
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    //创建对象时向构造函数传参
    Student stu("小明", 15, 92.5f);
    stu.show();
    //创建对象时向构造函数传参
    Student *pstu = new Student("李华", 16, 96);
    pstu -> show();

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是92.5
李华的年龄是16，成绩是96
```

该例在 `Student` 类中定义了一个构造函数`Student(char *, int, float)`，它的作用是给三个 `private` 属性的成员变量赋值。要想调用该构造函数，就得在创建对象的同时传递实参，并且实参由`( )`包围，和普通的函数调用非常类似。

在栈上创建对象时，实参位于对象名后面，例如`Student stu("小明", 15, 92.5f)`；在堆上创建对象时，实参位于类名后面，例如`new Student("李华", 16, 96)`。

构造函数必须是 `public` 属性的，否则创建对象时无法调用。当然，设置为 `private`、`protected` 属性也不会报错，但是没有意义。

构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，这意味着：

- 不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 `void` 也不允许；
- 函数体中不能有 `return` 语句。

## 构造函数的重载

和普通成员函数一样，构造函数是允许重载的。一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。

构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。

如果写作`Student stu`或者`new Student`就是错误的，因为类中包含了构造函数，而创建对象时却没有调用。更改代码，再添加一个构造函数：

```cpp
#include <iostream>
using namespace std;

class Student{
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    Student();
    Student(char *name, int age, float score);
    void setname(char *name);
    void setage(int age);
    void setscore(float score);
    void show();
};

Student::Student(){
    m_name = NULL;
    m_age = 0;
    m_score = 0.0;
}
Student::Student(char *name, int age, float score){
    m_name = name;
    m_age = age;
    m_score = score;
}
void Student::setname(char *name){
    m_name = name;
}
void Student::setage(int age){
    m_age = age;
}
void Student::setscore(float score){
    m_score = score;
}
void Student::show(){
    if(m_name == NULL || m_age <= 0){
        cout<<"成员变量还未初始化"<<endl;
    }else{
        cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
    }
}

int main(){
    //调用构造函数 Student(char *, int, float)
    Student stu("小明", 15, 92.5f);
    stu.show();

    //调用构造函数 Student()
    Student *pstu = new Student();
    pstu -> show();
    pstu -> setname("李华");
    pstu -> setage(16);
    pstu -> setscore(96);
    pstu -> show();

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是92.5
成员变量还未初始化
李华的年龄是16，成绩是96
```

构造函数`Student(char *, int, float)`为各个成员变量赋值，构造函数`Student()`将各个成员变量的值设置为空，它们是重载关系。根据`Student()`创建对象时不会赋予成员变量有效值，所以还要调用成员函数 `setname()`、`setage()`、`setscore()` 来给它们重新赋值。

构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，例如对成员变量赋值、预先打开文件等。

## 默认构造函数

如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。比如上面的 `Student` 类，默认生成的构造函数如下：

```cpp
Student(){}
```

一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。在示例中，`Student` 类已经有了一个构造函数`Student(char *, int, float)`，也就是我们自己定义的，编译器不会再额外添加构造函数`Student()`，在示例2中我们才手动添加了该构造函数。

> 实际上编译器只有在必要的时候才会生成默认构造函数，而且它的函数体一般不为空。默认构造函数的目的是帮助编译器做初始化工作，而不是帮助程序员。这是C++的内部实现机制，这里不再深究，初学者可以按照上面说的“一定有一个空函数体的默认构造函数”来理解。

最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。对于示例的代码，在栈上创建对象可以写作`Student stu()`或`Student stu`，在堆上创建对象可以写作`Student *pstu = new Student()`或`Student *pstu = new Student`，它们都会调用构造函数 `Student()`。

以前我们就是这样做的，创建对象时都没有写括号，其实是调用了默认的构造函数。

# 构造函数初始化列表

构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。

C++构造函数的初始化列表使得代码更加简洁，请看下面的例子：

```cpp
#include <iostream>
using namespace std;

class Student{
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    Student(char *name, int age, float score);
    void show();
};

//采用初始化列表
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    //TODO:
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    Student stu("小明", 15, 92.5f);
    stu.show();
    Student *pstu = new Student("李华", 16, 96);
    pstu -> show();

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是92.5
李华的年龄是16，成绩是96
```

如本例所示，定义构造函数时并没有在函数体中对成员变量一一赋值，其函数体为空（当然也可以有其他语句），而是在函数首部与函数体之间添加了一个冒号`:`，后面紧跟`m_name(name), m_age(age), m_score(score)`语句，这个语句的意思相当于函数体内部的`m_name = name; m_age = age; m_score = score;`语句，也是赋值的意思。

使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。

初始化列表可以用于全部成员变量，也可以只用于部分成员变量。下面的示例只对 m_name 使用初始化列表，其他成员变量还是一一赋值：

```cpp
Student::Student(char *name, int age, float score): m_name(name){
    m_age = age;
    m_score = score;
}
```

注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。请看代码：

```cpp
#include <iostream>
using namespace std;

class Demo{
private:
    int m_a;
    int m_b;
public:
    Demo(int b);
    void show();
};

Demo::Demo(int b): m_b(b), m_a(m_b){ }
void Demo::show(){ cout<<m_a<<", "<<m_b<<endl; }

int main(){
    Demo obj(100);
    obj.show();
    return 0;
}
```

运行结果：

```
2130567168, 100
```

在初始化列表中，我们将 `m_b` 放在了 `m_a` 的前面，看起来是先给 `m_b `赋值，再给 `m_a` 赋值，其实不然！成员变量的赋值顺序由它们在类中的声明顺序决定，在 `Demo` 类中，我们先声明的 `m_a`，再声明的 `m_b`，所以构造函数和下面的代码等价：

```cpp
Demo::Demo(int b): m_b(b), m_a(m_b){
    m_a = m_b;
    m_b = b;
}
```

给 `m_a` 赋值时，`m_b` 还未被初始化，它的值是不确定的，所以输出的 `m_a` 的值是一个奇怪的数字；给 `m_a` 赋值完成后才给 `m_b` 赋值，此时 `m_b` 的值才是 100。

> `obj` 在栈上分配内存，成员变量的初始值是不确定的。

## 初始化 `const` 成员变量

构造函数初始化列表还有一个很重要的作用，那就是初始化 `const` 成员变量。初始化 `const` 成员变量的唯一方法就是使用初始化列表。例如 VS/VC 不支持变长数组（数组长度不能是变量），我们自己定义了一个` VLA `类，用于模拟变长数组，请看下面的代码：

```cpp
class VLA{
private:
    const int m_len;
    int *m_arr;
public:
    VLA(int len);
};

//必须使用初始化列表来初始化 m_len
VLA::VLA(int len): m_len(len){
    m_arr = new int[len];
}
```

`VLA` 类包含了两个成员变量，`m_len` 和 `m_arr` 指针，需要注意的是 `m_len` 加了 `const` 修饰，只能使用初始化列表的方式赋值，如果写作下面的形式是错误的：

```cpp
class VLA{
private:
    const int m_len;
    int *m_arr;
public:
    VLA(int len);
};

VLA::VLA(int len){
    m_len = len;
    m_arr = new int[len];
}
```

# 析构函数

创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数。

<mark>析构函数</mark>（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个`~`符号。

**注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。**

上节我们定义了一个 `VLA` 类来模拟变长数组，它使用一个构造函数为数组分配内存，这些内存在数组被销毁后不会自动释放，所以非常有必要再添加一个析构函数，专门用来释放已经分配的内存。请看下面的完整示例：

```cpp
#include <iostream>
using namespace std;

class VLA{
public:
    VLA(int len);  //构造函数
    ~VLA();  //析构函数
public:
    void input();  //从控制台输入数组元素
    void show();  //显示数组元素
private:
    int *at(int i);  //获取第i个元素的指针
private:
    const int m_len;  //数组长度
    int *m_arr; //数组指针
    int *m_p;  //指向数组第i个元素的指针
};

VLA::VLA(int len): m_len(len){  //使用初始化列表来给 m_len 赋值
    if(len > 0){ m_arr = new int[len];  /*分配内存*/ }
    else{ m_arr = NULL; }
}
VLA::~VLA(){
    delete[] m_arr;  //释放内存
}
void VLA::input(){
    for(int i=0; m_p=at(i); i++){ cin>>*at(i); }
}
void VLA::show(){
    for(int i=0; m_p=at(i); i++){
        if(i == m_len - 1){ cout<<*at(i)<<endl; }
        else{ cout<<*at(i)<<", "; }
    }
}
int * VLA::at(int i){
    if(!m_arr || i<0 || i>=m_len){ return NULL; }
    else{ return m_arr + i; }
}

int main(){
    //创建一个有n个元素的数组（对象）
    int n;
    cout<<"Input array length: ";
    cin>>n;
    VLA *parr = new VLA(n);
    //输入数组元素
    cout<<"Input "<<n<<" numbers: ";
    parr -> input();
    //输出数组元素
    cout<<"Elements: ";
    parr -> show();
    //删除数组（对象）
    delete parr;

    return 0;
}
```

运行结果：

```
Input array length: 5
Input 5 numbers: 99 23 45 10 100
Elements: 99, 23, 45, 10, 100
```

`~VLA()`就是 `VLA` 类的析构函数，它的唯一作用就是在删除对象（第 53 行代码）后释放已经分配的内存。

函数名是标识符的一种，原则上标识符的命名中不允许出现`~`符号，在析构函数的名字中出现的`~`可以认为是一种特殊情况，目的是为了和构造函数的名字加以对比和区分。

注意：`at()` 函数只在类的内部使用，所以将它声明为 `private` 属性；`m_len` 变量不允许修改，所以用 `const `进行了限制，这样就只能使用初始化列表来进行赋值。

C++中的 `new` 和 `delete` 分别用来分配和释放内存，它们与C语言中` malloc()`、`free() `最大的一个不同之处在于：用 `new` 分配内存时会调用构造函数，用 `delete` 释放内存时会调用析构函数。构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用 `new` 和 `delete`。

## 析构函数的执行时机

析构函数在对象被销毁时调用，而对象的销毁时机与它所在的内存区域有关。

在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。

在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。

`new` 创建的对象位于堆区，通过 `delete` 删除时才会调用析构函数；如果没有 `delete`，析构函数就不会被执行。

下面的例子演示了析构函数的执行。

```cpp
#include <iostream>
#include <string>
using namespace std;

class Demo{
public:
    Demo(string s);
    ~Demo();
private:
    string m_s;
};
Demo::Demo(string s): m_s(s){ }
Demo::~Demo(){ cout<<m_s<<endl; }

void func(){
    //局部对象
    Demo obj1("1");
}

//全局对象
Demo obj2("2");

int main(){
    //局部对象
    Demo obj3("3");
    //new创建的对象
    Demo *pobj4 = new Demo("4");
    func();
    cout<<"main"<<endl;
  
    return 0;
}
```

运行结果：

```
1
main
3
2
```

# 对象数组

到目前为止，我们所了解的是，数组中的所有元素必须是相同的数据类型，并且所使用的数组也只是具有一些简单的数据类型，如 `int` 数组和` string` 数组。

数组其实也可以容纳更复杂的数据类型，比如程序员定义的结构或对象。这一切所需的条件就是，每个元素都拥有相同类型的结构或同一类的对象。

现在来看一看对象数组。程序员可以像定义任何数组一样定义一个对象数组。例如，如果已经定义了一个名为 `Circle` 的类，那么就可以使用以下语句创建一个可以容纳 4 个 Circle 对象的数组：

```cpp
Circle circle[4];
```

这 4 个对象是` circle[0]`、`circle[1]`、`circle[2]` 和 `circle[3]`。

请注意，类的名称是 `Circle`，其首字母 C 是大写的，数组的名称是 `circle`，其首字母 c 是小写的。我们有过约定，类的名称首字母使用大写，变量或者对象的名称首字母则釆用小写。为对象数组中某个对象调用类函数就像为任何其他对象调用类函数一样，区别在于必须包含下标，以标识数组中的哪个对象被引用。

例如，以下语句将调用 `circle[2]` 的` findArea` 函数：

```cpp
circle[2].findArea();
```

下面的程序通过创建和使用 `Circle` 类对象数组来演示了上述操作。以下是它使用的 `Circle` 类的定义：

```cpp
// Thisheader file contains the Circle class declaration.
#ifndef CIRCLE_H
#define CIRCLE_H
#include <cmath>

class Circle
{
    private:
        double radius; // Circle radius
        int centerX, centerY; // Center coordinates
    public:
        Circle() // Default constructor
        {
            // accepts no arguments
            radius = 1.0;
            centerX = centerY = 0;
        }
        Circle(double r) // Constructor 2
        {
            // accepts 1 argument
            radius = r;
            centerX = centerY = 0;
        }
        Circle(double r, int x, int y) // Constructor 3
        {
            // accepts 3 arguments
            radius = r;   
            centerX = x;
            centerY = y;
        }
        void setRadius(double r)
        {
            radius = r;
        }
        int getXcoord()
        {
            return centerX;
        }
        int getYcoord()
        {
            return centerY;
        }
        double findArea()
        {
            return 3.14 * pow(radius, 2);
        }

}; // End Circle class declaration
#endif
```

在接下来的程序中，需要特别注意其关键部分，在第 5 行中包含了 Circle.h 头文件，在该文件中包含了 `Circle` 类定义。然后是在第 11 行中，创建了一个由 4 个 `Circle` 对象组成的数组。在第 13〜19 行中的循环为每个对象调用 `setRadius` 方法。在第 23〜26 行使用第 2 个循环为每个对象调用 `findArea` 方法并显示结果。

```cpp
// This program uses an array of objects.
// The objects are instances of the Circle class.
#include <iostream>
#include <iomanip>
#include "Circle.h" // Circle class declaration file
using namespace std;

const int NUM_CIRCLES = 4;
int main()
{
    Circle circle[NUM_CIRCLES]; // Define an array of Circle objects
    // Use'a loop to initialize the radius of each object
    for (int index = 0; index < NUM_CIRCLES; index++)
    {
        double r;
        cout << "Enter the radius for circle " << (index+1) <<":";
        cin >> r;
        circle[index].setRadius(r);
    }
    // Use a loop to get and print out the area of each object
    cout << fixed << showpoint << setprecision(2);
    cout << "\nHere are the areas of the " << NUM_CIRCLES << "circles . \n";
    for (int index = 0; index < NUM_CIRCLES; index++)
    {
        cout << "circle " << (index+1) << setw (8) << circle[index].findArea() << endl;
    }
    return 0;
}
```

程序输出结果：

```
Enter the radius for circle 1:0
Enter the radius for circle 2:2
Enter the radius for circle 3:2.5
Enter the radius for circle 4:10

Here are the areas of the 4circles .
circle 1  0.00
circle 2  12.56
circle 3  19.62
circle 4 314.00
```

注意，每当使用一个没有参数的构造函数创建对象数组时，如果存在默认构造函数，则它将为数组中的每个对象运行，此程序就是这样。

当 `Circle` 对象的数组首先被创建时，为数组中的每个对象执行默认构造函数，并为其半径赋值 1.0，但是这种情况并没有发生，这是因为每个对象对 `setRadius `成员函数的调用在起作用，它们都使用传递给 `setRadius` 的新值替换了默认的 1.0。

如果我们将上边程序的第 13〜19 行注释掉，那么就不会有` setRadius `的调用。因此，当第 23〜26 行的循环获取并打印圆面积时，数组中的每个对象的半径仍将为 1.0。其输出结果将如下所示：

```
Here are the areas of the 4 circles.
circle1 3.14
circle2 3.14
circle3 3.14
circle4 3.14
```

也可以创建一个对象数组，并为每个对象调用另一个构造函数。为此则必须使用初始化列表。以下数组定义和初始化列表将创建 4 个` Circle` 对象，并将它们初始化为在上边程序样本运行中输入的相同的 4 个值。

```cpp
circle[NUM_CIRCLES] = {0.0, 2.0, 2.5, 10.0};
```

这将调用构造函数接受一个 `double` 参数，并设置以下半径值：

| 对象         | 半径 |
| ------------ | ---- |
| `circle[0]`  | 0.0  |
| `circle[1]`  | 2.0  |
| `circle[2] ` | 2.5  |
| `circle[3] ` | 10.0 |

如果初始化列表的长度小于对象的数量，则任何剩余的对象都将由默认构造函数初始化。例如，以下语句调用构造函数，该构造函数为前 3 个对象接收一个 `double` 参数，并使默认构造函数为第 4 个对象运行。第 4 个对象的默认半径为 1.0。

```cpp
circle[NUM_CIRCLES] = {0.0, 2.0, 2.5};
```

在下面程序中有该用法演示：

```cpp
// This program demonstrates how an overloaded constructor
// that accepts an argument can be invoked for multiple objects
//when an array of objects is created.
#include <iostream>
#include <iomanip>
#include "Circle.h" // Circle class declaration file
using namespace std;

const int NUM_CIRCLES = 4;
int main()
{
    // Define an array of 4 Circle objects. Use an initialization list
    // to call the 1-argument constructor for the first 3 objects.
    // The default constructor will be called for the final object.
    Circle circle[NUM_CIRCLES] = {0.0, 2.0, 2.5};
    // Display the area of each object
    cout << fixed << showpoint << setprecision (2);
    cout << "Here are the areas of the " << NUM_CIRCLES << " circles . \n";
    for (int index = 0; index < NUM_CIRCLES; index++)
    {
        cout << "circle " << (index+1) << setw (8) << circle[index].findArea() << endl;
    }
    return 0;
}
```

程序输出结果：

```
Here are the areas of the 4 circles .
circle 1  0.00
circle 2  12.56
circle 3  19.62
circle 4  3.14
```

要使用需要多个参数的构造函数，则初始化项必须釆用函数调用的形式。例如，来看下面的定义语句，它为 3 个 `Circle` 对象的每一个调用 3 个参数的构造函数：

```cpp
Circle circle[3] = {Circle(4.0, 2, 1),Circle(2.0, 1, 3),Circle (2.5, 5, -1) };
```

`circle[0]` 的 `radius` 变量设置为 4.0，`centerX` 变量设置为 2，`centerY `变量设置为 1；`circle[1]` 的 `radius` 变量设置为 2.0，`centerX` 变量设置为 1，`centerY `变量设置为 3；`circle[2]` 的 `radius` 变量设置为 2.5，`centerX` 变量设置为 5，`centerY` 变量设置为 -1。

没有必要为数组中的每个对象调用相同的构造函数。例如，以下语句也是合法的：

```cpp
Circle circle [3] = { 4.0,Circle (2.0, 1, 3),2.5 };
```

该语句为 `circle[0]` 和 `circle[2]` 调用 1 参数构造函数，而为 `circle[1]` 调用的则是 3 参数构造函数。

总而言之，要记住关于对象数组的 7 个关键点：

1. 数组的元素可以是对象。
2. 如果在创建对象数组时未使用初始化列表，则会为数组中的每个对象调用默认构造函数。
3. 没有必要让数组中的所有对象都使用相同的构造函数。
4. 如果在创建对象数组时使用初始化列表，则将根据所使用参数的数量和类型为每个对象调用正确的构造函数。
5. 如果构造函数需要多个参数，则初始化项必须釆用构造函数调用的形式。
6. 如果列表中的初始化项调用少于数组中的对象，则将为所有剩余的对象调用默认构造函数。
7. 最好总是提供一个默认的构造函数。如果没有，则必须确保为数组中的每个对象提供一个初始化项。

# 成员对象&封闭类

一个类的成员变量如果是另一个类的对象，就称之为<mark>成员对象</mark>。包含成员对象的类叫<mark>封闭类</mark>（enclosed class）。

## 封闭类构造函数的初始化列表

当封闭类的对象生成并初始化时，它包含的成员对象也需要被初始化，这就会引发成员对象构造函数的调用。如何让编译器知道，成员对象到底是用哪个构造函数初始化的呢？这可以通过在定义封闭类的构造函数时，添加初始化列表的方式解决。

在构造函数中添加初始化列表的写法如下：

```cpp
类名::构造函数名(参数表): 成员变量1(参数表), 成员变量2(参数表), ...
{
  ...
}
```

`:`和`{`之间的部分就是初始化列表。初始化列表中的成员变量既可以是成员对象，也可以是基本类型的成员变量。对于成员对象，初始化列表的“参数表”中存放的是构造函数的参数（它指明了该成员对象如何初始化）。对于基本类型成员变量，“参数表”中就是一个初始值。

“参数表”中的参数可以是任何有定义的表达式，该表达式中可以包括变量甚至函数调用等，只要表达式中的标识符都是有定义的即可。例如：

```cpp
#include <iostream>
using namespace std;
class CTyre  //轮胎类
{
private:
    int radius;  //半径
    int width;  //宽度
public:
    CTyre(int r, int w) : radius(r), width(w) { }
};
class CEngine  //引擎类
{
};
class CCar {  //汽车类
private:
    int price;  //价格
    CTyre tyre;
    CEngine engine;
public:
    CCar(int p, int tr, int tw);
};
CCar::CCar(int p, int tr, int tw) : price(p), tyre(tr, tw)
{
};
int main()
{
    CCar car(20000, 17, 225);
    return 0;
}
```

第 9 行的构造函数添加了初始化列表，将 `radius` 初始化成 `r`，`width` 初始化成 `w`。这种写法比在函数体内用 `r` 和 `w` 对 `radius` 和 `width` 进行赋值的风格更好。建议对成员变量的初始化都使用这种写法。

`CCar` 是一个封闭类，有两个成员对象：`tyre` 和 `engine`。在编译第 27 行时，编译器需要知道 `car` 对象中的 `tyre` 和 `engine` 成员对象该如何初始化。

编评器已经知道这里的 `car` 对象是用上面的 `CCar(int p, int tr, int tw)` 构造函数初始化的，那么 `tyre` 和 `engine` 该如何初始化，就要看第 22 行 `CCar(int p,int tr,int tw)` 后面的初始化列表了。该初始化列表表明，`tyre` 应以 `tr `和 `tw` 作为参数调用 `CTyre(intr, hit w)` 构造函数初始化，但是并没有说明 `engine` 该如何处理。在这种情况下，编译器就认为 `engine` 应该用 `CEngine` 类的无参构造函数初始化。而 `CEngine` 类确实有一个编译器自动生成的默认无参构造函数，因此，整个 `car` 对象的初始化问题就都解决了。

总之，生成封闭类对象的语句一定要让编译器能够弄明白其成员对象是如何初始化的，否则就会编译错误。

在上面的程序中，如果 `CCar` 类的构造函数没有初始化列表，那么第 27 行就会编译出错，因为编译器不知道该如何初始化 `car.tyre` 对象，因为 `CTyre` 类没有无参构造函数，而编译器又找不到用来初始化 `car.tyre` 对象的参数。

封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类自己的构造函数。成员对象构造函数的执行次序和成员对象在类定义中的次序一致，与它们在构造函数初始化列表中出现的次序无关。

当封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，成员对象析构函数的执行次序和构造函数的执行次序相反，即先构造的后析构，这是 C++ 处理此类次序问题的一般规律。

例如下面的程序：

```cpp
#include<iostream>
using namespace std;
class CTyre {
public:
    CTyre() { cout << "CTyre constructor" << endl; }
    ~CTyre() { cout << "CTyre destructor" << endl; }
};
class CEngine {
public:
    CEngine() { cout << "CEngine constructor" << endl; }
    ~CEngine() { cout << "CEngine destructor" << endl; }
};
class CCar {
private:
    CEngine engine;
    CTyre tyre;
public:
    CCar() { cout << "CCar constructor" << endl; }
    ~CCar() { cout << "CCar destructor" << endl; }
};
int main() {
    CCar car;
    return 0;
}
```

运行结果：

```
CEngine constructor
CTyre constructor
CCar constructor
CCar destructor
CTyre destructor
CEngine destructor
```

封闭类的对象初始化时，要先执行成员对象的构造函数，是因为封闭类的构造函数中有可能用到成员对象。如果此时成员对象还没有初始化，那就不合理了。

思考题：为什么封闭类对象消亡时，要先执行封闭类的析构函数，然后才执行成员对象的析构函数？

## 封闭类的复制构造函数

封闭类的对象，如果是用默认复制构造函数初始化的，那么它包含的成员对象也会用复制构造函数初始化。例如下而的程序：

```cpp
#include <iostream>
using namespace std;
class A
{
public:
    A() { cout << "default" << endl; }
    A(A &a) { cout << "copy" << endl; }
};
class B
{
    A a;
};
int main()
{
    B b1, b2(b1);
    return 0;
}
```

程序的输出结果是：

```
default
copy
```

说明 `b2.a` 是用类` A `的复制构造函数初始化的，而且调用复制构造函数时的实参就是 `b1.a`。

# `this`指针

`this` 是 C++ 中的一个关键字，也是一个 `const` 指针，它指向当前对象，通过它可以访问当前对象的所有成员。

所谓当前对象，是指正在使用的对象。例如对于`stu.show();`，`stu` 就是当前对象，`this` 就指向 `stu`。

下面是使用 `this` 的一个完整示例：

```cpp
#include <iostream>
using namespace std;

class Student{
public:
    void setname(char *name);
    void setage(int age);
    void setscore(float score);
    void show();
private:
    char *name;
    int age;
    float score;
};

void Student::setname(char *name){
    this->name = name;
}
void Student::setage(int age){
    this->age = age;
}
void Student::setscore(float score){
    this->score = score;
}
void Student::show(){
    cout<<this->name<<"的年龄是"<<this->age<<"，成绩是"<<this->score<<endl;
}

int main(){
    Student *pstu = new Student;
    pstu -> setname("李华");
    pstu -> setage(16);
    pstu -> setscore(96.5);
    pstu -> show();

    return 0;
}
```

运行结果：

```
李华的年龄是16，成绩是96.5
```

`this` 只能用在类的内部，通过 `this` 可以访问类的所有成员，包括 `private`、`protected`、`public` 属性的。

本例中成员函数的参数和成员变量重名，只能通过 `this` 区分。以成员函数`setname(char *name)`为例，它的形参是`name`，和成员变量`name`重名，如果写作`name = name;`这样的语句，就是给形参`name`赋值，而不是给成员变量`name`赋值。而写作`this -> name = name;`后，`=`左边的`name`就是成员变量，右边的`name`就是形参，一目了然。

注意，`this` 是一个指针，要用`->`来访问成员变量或成员函数。

`this` 虽然用在类的内部，但是只有在对象被创建以后才会给 `this` 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 `this` 赋值。本例中，`this` 的值和 `pstu` 的值是相同的。

我们不妨来证明一下，给 `Student` 类添加一个成员函数`printThis()`，专门用来输出 `this` 的值，如下所示：

```cpp
void Student::printThis(){
    cout<<this<<endl;
}
```

然后在 `main()` 函数中创建对象并调用 `printThis()`：

```cpp
Student *pstu1 = new Student;
pstu1 -> printThis();
cout<<pstu1<<endl;

Student *pstu2 = new Student;
pstu2 -> printThis();
cout<<pstu2<<endl;
```

运行结果：

```
0x7b17d8
0x7b17d8
0x7b17f0
0x7b17f0
```

可以发现，`this` 确实指向了当前对象，而且对于不同的对象，`this` 的值也不一样。

几点注意：

- `this` 是 `const` 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
- `this` 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
- 只有当对象被创建后 `this` 才有意义，因此不能在 `static` 成员函数中使用。

## `this` 到底是什么

`this` 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 `this`。不过 `this` 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。

`this` 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 `this` 赋值。

成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 `this`，它是成员函数和成员变量关联的桥梁。

# 静态成员变量

对象的内存中包含了成员变量，不同的对象占用不同的内存，这使得不同对象的成员变量相互独立，它们的值不受其他对象的影响。例如有两个相同类型的对象 `a`、`b`，它们都有一个成员变量 `m_name`，那么修改 `a.m_name` 的值不会影响 `b.m_name` 的值。

可是有时候我们希望在多个对象之间共享数据，对象 `a` 改变了某份数据后对象 `b` 可以检测到。共享数据的典型使用场景是计数，以前面的 `Student` 类为例，如果我们想知道班级中共有多少名学生，就可以设置一份共享的变量，每次创建对象时让该变量加 1。

在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。静态成员变量是一种特殊的成员变量，它被关键字`static`修饰，例如：

```cpp
class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:
    static int m_total;  //静态成员变量
private:
    char *m_name;
    int m_age;
    float m_score;
};
```

这段代码声明了一个静态成员变量 `m_total`，用来统计学生的人数。

`static` 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 `m_total `分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了` m_total`，也会影响到其他对象。

`static` 成员变量必须在类声明的外部初始化，具体形式为：

```cpp
type class::name = value;
```

`type` 是变量的类型，`class` 是类名，`name` 是变量名，`value` 是初始值。将上面的 `m_total` 初始化：

```cpp
int Student::m_total = 0;
```

静态成员变量在初始化时不能再加 `static`，但必须要有数据类型。被 `private`、`protected`、`public` 修饰的静态成员变量都可以用这种方式初始化。

注意：`static` 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 `static` 成员变量不能使用。

`static` 成员变量既可以通过对象来访问，也可以通过类来访问。请看下面的例子：

```cpp
//通过类类访问 static 成员变量
Student::m_total = 10;
//通过对象来访问 static 成员变量
Student stu("小明", 15, 92.5f);
stu.m_total = 20;
//通过对象指针来访问 static 成员变量
Student *pstu = new Student("李华", 16, 96);
pstu -> m_total = 20;
```

这三种方式是等效的。

注意：`static` 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，`static` 成员变量和普通的 `static` 变量类似，都在内存分区中的全局数据区分配内存。

下面来看一个完整的例子：

```cpp
#include <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
    void show();
private:
    static int m_total;  //静态成员变量
private:
    char *m_name;
    int m_age;
    float m_score;
};

//初始化静态成员变量
int Student::m_total = 0;

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    m_total++;  //操作静态成员变量
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"（当前共有"<<m_total<<"名学生）"<<endl;
}

int main(){
    //创建匿名对象
    (new Student("小明", 15, 90)) -> show();
    (new Student("李磊", 16, 80)) -> show();
    (new Student("张华", 16, 99)) -> show();
    (new Student("王康", 14, 60)) -> show();

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是90（当前共有1名学生）
李磊的年龄是16，成绩是80（当前共有2名学生）
张华的年龄是16，成绩是99（当前共有3名学生）
王康的年龄是14，成绩是60（当前共有4名学生）
```

本例中将 `m_total` 声明为静态成员变量，每次创建对象时，会调用构造函数使 `m_total` 的值加 1。

之所以使用匿名对象，是因为每次创建对象后只会使用它的 `show()` 函数，不再进行其他操作。不过使用匿名对象无法回收内存，会导致内存泄露，在中大型程序中不建议使用。

## 几点说明 

- 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。

- `static` 成员变量和普通 `static` 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，`static` 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。

- 静态成员变量必须初始化，而且只能在类体外进行。例如：
  ```cpp
  int Student::m_total = 10;
  ```
  初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。

- 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 `private`、`protected `和` public `关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。

# 静态成员函数

在类中，`static` 除了可以声明静态成员变量，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 `this`，并把当前对象的地址赋值给 `this`，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 `this`，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

普通成员变量占用对象的内存，静态成员函数没有 `this` 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。

普通成员函数必须通过对象才能调用，而静态成员函数没有 `this` 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。

静态成员函数与普通成员函数的根本区别在于：普通成员函数有 `this` 指针，可以访问类中的任意成员；而静态成员函数没有 `this` 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

下面是一个完整的例子，该例通过静态成员函数来获得学生的总人数和总成绩：

```cpp
#include <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:  //声明静态成员函数
    static int getTotal();
    static float getPoints();
private:
    static int m_total;  //总人数
    static float m_points;  //总成绩
private:
    char *m_name;
    int m_age;
    float m_score;
};

int Student::m_total = 0;
float Student::m_points = 0.0;

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    m_total++;
    m_points += score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
//定义静态成员函数
int Student::getTotal(){
    return m_total;
}
float Student::getPoints(){
    return m_points;
}

int main(){
    (new Student("小明", 15, 90.6)) -> show();
    (new Student("李磊", 16, 80.5)) -> show();
    (new Student("张华", 16, 99.0)) -> show();
    (new Student("王康", 14, 60.8)) -> show();

    int total = Student::getTotal();
    float points = Student::getPoints();
    cout<<"当前共有"<<total<<"名学生，总成绩是"<<points<<"，平均分是"<<points/total<<endl;

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是90.6
李磊的年龄是16，成绩是80.5
张华的年龄是16，成绩是99
王康的年龄是14，成绩是60.8
当前共有4名学生，总成绩是330.9，平均分是82.725
```

总人数 `m_total` 和总成绩 `m_points` 由各个对象累加得到，必须声明为 `static `才能共享；`getTotal()`、`getPoints()` 分别用来获取总人数和总成绩，为了访问 `static` 成员变量，我们将这两个函数也声明为 `static`。

在C++中，静态成员函数的主要目的是访问静态成员。`getTotal()`、`getPoints()` 当然也可以声明为普通成员函数，但是它们都只对静态成员进行操作，加上 `static` 语义更加明确。

和静态成员变量类似，静态成员函数在声明时要加 `static`，在定义时不能加 `static`。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用，上例仅仅演示了如何通过类来调用。

# `const`成员变量和函数

在类中，如果你不希望某些数据被修改，可以使用`const`关键字加以限定。`const` 可以用来修饰成员变量和成员函数。

## const成员变量

`const` 成员变量的用法和普通 `const` 变量的用法相似，只需要在声明时加上 `const` 关键字。初始化 `const` 成员变量只有一种方法，就是通过构造函数的初始化列表。

## const成员函数

`const `成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。`const `成员函数也称为常成员函数。

我们通常将 `get` 函数设置为常成员函数。读取成员变量的函数的名字通常以`get`开头，后跟成员变量的名字，所以通常将它们称为 `get `函数。

常成员函数需要在声明和定义的时候在**函数头部的结尾**加上 `const `关键字，请看下面的例子：

```cpp
class Student{
public:
    Student(char *name, int age, float score);
    void show();
    //声明常成员函数
    char *getname() const;
    int getage() const;
    float getscore() const;
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
//定义常成员函数
char * Student::getname() const{
    return m_name;
}
int Student::getage() const{
    return m_age;
}
float Student::getscore() const{
    return m_score;
}
```

`getname()`、`getage()`、`getscore() `三个函数的功能都很简单，仅仅是为了获取成员变量的值，没有任何修改成员变量的企图，所以我们加了` const` 限制，这是一种保险的做法，同时也使得语义更加明显。

需要强调的是，必须在成员函数的声明和定义处同时加上 `const` 关键字。`char *getname() const`和`char *getname()`是两个不同的函数原型，如果只在一个地方加 `const` 会导致声明和定义处的函数原型冲突。

最后再来区分一下` const` 的位置：

- 函数开头的 `const` 用来修饰函数的返回值，表示返回值是 `const` 类型，也就是不能被修改，例如`const char * getname()`。
- 函数头部的结尾加上` const` 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如`char * getname() const`。

# `const`对象

在 C++中，`const` 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 `const` 成员（包括 `const` 成员变量和 `const` 成员函数）了。

定义常对象的语法和定义常量的语法类似：

```cpp
const class object(params);
class const object(params);
```

当然你也可以定义` const` 指针：

```cpp
const class *p = new class(params);
class const *p = new class(params);
```

`class`为类名，`object`为对象名，`params`为实参列表，`p`为指针名。两种方式定义出来的对象都是常对象。

一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 `const` 修饰的成员了（包括 `const` 成员变量和 `const `成员函数），因为非 `const` 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。

常对象使用举例：

```cpp
#include <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
public:
    void show();
    char *getname() const;
    int getage() const;
    float getscore() const;
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
char * Student::getname() const{
    return m_name;
}
int Student::getage() const{
    return m_age;
}
float Student::getscore() const{
    return m_score;
}

int main(){
    const Student stu("小明", 15, 90.6);
    //stu.show();  //error
    cout<<stu.getname()<<"的年龄是"<<stu.getage()<<"，成绩是"<<stu.getscore()<<endl;

    const Student *pstu = new Student("李磊", 16, 80.5);
    //pstu -> show();  //error
    cout<<pstu->getname()<<"的年龄是"<<pstu->getage()<<"，成绩是"<<pstu->getscore()<<endl;

    return 0;
}
```

本例中，`stu`、`pstu `分别是常对象以及常对象指针，它们都只能调用 `const `成员函数。

# 友元函数&友元类

在 C++中，一个类中可以有 `public`、`protected`、`private` 三种属性的成员，通过对象可以访问 `public` 成员，只有本类中的函数可以访问本类的 `private` 成员。现在，我们来介绍一种例外情况——<mark>友元</mark>（friend）。借助友元，可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 `private` 成员。

friend 的意思是朋友，或者说是好友，与好友的关系显然要比一般人亲密一些。我们会对好朋友敞开心扉，倾诉自己的秘密，而对一般人会谨言慎行，潜意识里就自我保护。在 C++ 中，这种友好关系可以用 `friend`关键字指明，中文多译为“友元”，借助友元可以访问与其有好友关系的类中的私有成员。如果你对“友元”这个名词不习惯，可以按原文 friend 理解为朋友。

## 友元函数

在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 `friend` 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

友元函数可以访问当前类中的所有成员，包括 `public`、`protected`、`private` 属性的。

### 将非成员函数声明为友元函数。

请大家直接看下面的例子：

```cpp
#include <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
public:
    friend void show(Student *pstu);  //将show()声明为友元函数
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }

//非成员函数
void show(Student *pstu){
    cout<<pstu->m_name<<"的年龄是 "<<pstu->m_age<<"，成绩是 "<<pstu->m_score<<endl;
}

int main(){
    Student stu("小明", 15, 90.6);
    show(&stu);  //调用友元函数
    Student *pstu = new Student("李磊", 16, 80.5);
    show(pstu);  //调用友元函数

    return 0;
}
```

运行结果：

```
小明的年龄是 15，成绩是 90.6
李磊的年龄是 16，成绩是 80.5
```

`show() `是一个全局范围内的非成员函数，它不属于任何类，它的作用是输出学生的信息。`m_name`、`m_age`、`m_score` 是 `Student` 类的 `private` 成员，原则上不能通过对象访问，但在 `show()` 函数中又必须使用这些 `private `成员，所以将`show() `声明为 `Student `类的友元函数。读者可以亲自测试一下，将上面程序中的第 8 行删去，观察编译器的报错信息。

注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。下面的写法是错误的：

```cpp
void show(){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
}
```

成员函数在调用时会隐式地增加 `this `指针，指向调用它的对象，从而使用该对象的成员；而 `show() `是非成员函数，没有` this `指针，编译器不知道使用哪个对象的成员，要想明确这一点，就必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象。

### 将其他类的成员函数声明为友元函数

`friend` 函数不仅可以是全局函数（非成员函数），还可以是另外一个类的成员函数。请看下面的例子：

```cpp
#include <iostream>
using namespace std;

class Address;  //提前声明Address类

//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};

//声明Address类
class Address{
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
public:
    Address(char *province, char *city, char *district);
    //将Student类中的成员函数show()声明为友元函数
    friend void Student::show(Address *addr);
};

//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(Address *addr){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
    cout<<"家庭住址："<<addr->m_province<<"省"<<addr->m_city<<"市"<<addr->m_district<<"区"<<endl;
}

//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}

int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);

    return 0;
}
```

运行结果：

```
小明的年龄是 16，成绩是 95.5
家庭住址：陕西省西安市雁塔区
李磊的年龄是 16，成绩是 80.5
家庭住址：河北省衡水市桃城区
```

本例定义了两个类 `Student` 和 `Address`，程序第 27 行将 `Student` 类的成员函数 `show() `声明为 `Address` 类的友元函数，由此，`show()` 就可以访问 `Address` 类的` private` 成员变量了。

几点注意：

- 程序第 4 行对 `Address` 类进行了提前声明，是因为在 `Address` 类定义之前、在 `Student` 类中使用到了它，如果不提前声明，编译器会报错，提示`'Address' has not been declared`。类的提前声明和函数的提前声明是一个道理。

- 程序将 `Student` 类的声明和实现分开了，而将 `Address` 类的声明放在了中间，这是因为编译器从上到下编译代码，`show()` 函数体中用到了` Address` 的成员 `province`、`city`、`district`，如果提前不知道 `Address` 的具体声明内容，就不能确定 `Address `是否拥有该成员（类的声明中指明了类有哪些成员）。
  这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是某些情况下（如上例所示），只要做好提前声明，也可以先使用。
  但是应当注意，类的提前声明的使用范围是有限的，只有在正式声明一个类以后才能用它去创建对象。如果在上面程序的第4行之后增加如下所示的一条语句，编译器就会报错：
  ```cpp
  Address addr; //企图使用不完整的类来创建对象
  ```
  因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 `Address` 类的指针变量）或引用变量（后续会介绍引用），因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。

- 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。

## 友元类

不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。

例如将类 `B` 声明为类 `A `的友元类，那么类` B `中的所有成员函数都是类` A `的友元函数，可以访问类 `A` 的所有成员，包括 `public`、`protected`、`private` 属性的。

更改上例的代码，将` Student `类声明为 `Address `类的友元类：

```cpp
#include <iostream>
using namespace std;

class Address;  //提前声明Address类

//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};

//声明Address类
class Address{
public:
    Address(char *province, char *city, char *district);
public:
    //将Student类声明为Address类的友元类
    friend class Student;
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
};

//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(Address *addr){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
    cout<<"家庭住址："<<addr->m_province<<"省"<<addr->m_city<<"市"<<addr->m_district<<"区"<<endl;
}

//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}

int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);

    return 0;
}
```

第 24 行代码将` Student` 类声明为 `Address `类的友元类，声明语句为：

```cpp
friend class Student;
```

有的编译器也可以不写 `class `关键字，不过为了增强兼容性还是建议写上。

关于友元，有两点需要说明：

- 友元的关系是单向的而不是双向的。如果声明了类 `B` 是类 `A `的友元类，不等于类` A `是类` B `的友元类，类 `A`中的成员函数不能访问类 `B` 中的 `private` 成员。
- 友元的关系不能传递。如果类 `B` 是类 `A` 的友元类，类 `C` 是类 `B` 的友元类，不等于类` C `是类 `A `的友元类。


除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。

# 类作用域

全局变量可以在文件的任意位置使用它，但是局部变量只能在其所属的代码块中使用。C++中引入了一种新的作用域，类作用域。作用域为类的名称在整个类中是已知的，在类外是不可见的。也就是说，作用域为类的成员只能被通过对象调用。

## 类成员的三种访问形式

使用类成员时，必须根据上下文使用直接成员运算符`.`、间接成员运算符`->`或作用域解析符`::`

1. 直接成员运算符：使用在对象上，以调用成员

```cpp
Student student;
student.show();
```

2. 间接成员运算符，一般用在对象指针上

```cpp
Student *student = new Student();
student->show();
```

3. 作用域解析符：常用在类的内部

```cpp
void Student::show(){
    cout<<Student::name<<endl;
}
```

## 类作用域常量

在类的内部创建常量不能直接使用`const`，因为类的声明只是描述了对象的形式，并没有创建对象。因此在对象创建之前，将没有用于存储的空间。但有两种方式可以实现相同的效果。

1. 在类中声明一个枚举

```cpp
class Stack{
private:
    enum{size=30}
public:
};
```

此时我们能够使用`size`常量作为栈的最大长度。假如我们想声明一个`double`类型的常量，可以在枚举下声明类型。

```cpp
enum{size=30}
double costs[size];
```

此时就可以将`size`当做浮点型类操作了。

2. 使用`static`关键字

```cpp
class Stack{
private:
    static const int size = 30;
    double costs[size];
public:
};
```

在c++98中，只能使用`static`声明整数或者枚举的静态常量，c++11消除了这种限制。

## c++11 作用域内枚举

当我们使用的枚举中包含名称冲突时，我们可以采用作用域为类的新枚举类型

```cpp
enum class chinese{teacher};
enum class english{teacher};
```

这样我们可以采用上述这种方式来给各门课的老师设置常量。我们可以使用`class`或者`struct`中任意一个关键字。
这里需要注意的是常规枚举可以自动当做`int`整型去使用，但是作用域枚举如果想要当成`int`使用必须经过强转

```cpp
int x = int(chinese::teacher);
```

c++枚举的实现默认为int，但是在c++98中，枚举的表示与操作系统相关。c++11中统一了枚举的格式为`int`。并且如果我们不想使用默认的`int`还能通过下列语法更换枚举的底层实现。

```cpp
enum class:short color{red,blue};
```

此时底层枚举实现为`short`类型，可以节省内存。注意：自定义类型必须是整型。

# `class`&`struct`

C++中保留了C语言的 `struct` 关键字，并且加以扩充。在C语言中，`struct` 只能包含成员变量，不能包含成员函数。而在C++中，`struct` 类似于 `class`，既可以包含成员变量，又可以包含成员函数。

C++中的 `struct` 和 `class` 基本是通用的，唯有几个细节不同：

- 使用 `class` 时，类中的成员默认都是 `private` 属性的；而使用 `struct` 时，结构体中的成员默认都是 `public` 属性的。
- `class` 继承默认是 `private` 继承，而 `struct` 继承默认是 `public` 继承。
- `class` 可以使用模板，而 `struct` 不能。

C++ 没有抛弃C语言中的 `struct `关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。

在编写C++代码时，我强烈建议使用 `class `来定义类，而使用 `struct `来定义结构体，这样做语义更加明确。

使用` struct` 来定义类的一个反面教材：

```cpp
#include <iostream>
using namespace std;

struct Student{
    Student(char *name, int age, float score);
    void show();

    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

int main(){
    Student stu("小明", 15, 92.5f);
    stu.show();
    Student *pstu = new Student("李华", 16, 96);
    pstu -> show();

    return 0;
}
```

运行结果：

```
小明的年龄是15，成绩是92.5
李华的年龄是16，成绩是96
```

这段代码可以通过编译，说明 `struct` 默认的成员都是 `public` 属性的，否则不能通过对象访问成员函数。如果将 `struct` 关键字替换为` class`，那么就会编译报错。

