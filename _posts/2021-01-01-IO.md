---
layout: post
title:  "【C++】IO"
date:   2021-01-01 00:00:00 +0800
categories: toturial
tags: C++ IO
comments: 1
mathjax: true
copyrights: 转载
---

C++ 又可以称为“带类的 C”，即可以理解为 C++ 是 C 语言的基础上增加了面向对象（类和对象）。在此基础上，学过 C 语言的读者应该知道，它有一整套完成<mark>数据读写</mark>（I/O）的解决方案：

- 使用 `scanf()`、`gets()`等函数从键盘读取数据，使用 `printf()`、`puts() `等函数向屏幕上输出数据；

- 使用 `fscanf()`、`fgets() `等函数读取文件中的数据，使用 `fprintf()`、`fputs() `等函数向文件中写入数据。

要知道，C 语言的这套 I/O 解决方案也适用于 C++ 程序，但 C++ 并没有“偷懒”，它自己独立开发了一套全新的 I/O 解决方案，其中就包含大家一直使用的 `cin` 和 `cout`。前面章节中，我们一直在用 `cin` 接收从键盘输入的数据，用 `cout `向屏幕上输出数据（这 2 个过程又统称为<mark>标准 I/O</mark>）。除此之外，C++ 也对从文件中读取数据和向文件中写入数据做了支持（统称为<mark>文件 I/O</mark>）。

本质上来说，C++ 的这套 I/O 解决方案就是一个包含很多类的类库（作为 C++ 标准库的组成部分），这些类常被称为<mark>流类</mark>。

> C++ 的开发者认为数据输入和输出的过程也是数据传输的过程，数据像水一样从一个地方流动到另一个地方，所以 C++ 中将此过程称为“流”，实现此过程的类称为“流类”。

图展示了 C++ 中用于实现数据输入和输出的这些流类以及它们之间的关系：


![img](http://c.biancheng.net/uploads/allimg/180831/1-1PS1153301321.jpg)

> 其中，图中的箭头代表各个类之间的派生关系。比如，`ios `是所有流类的基类，它派生出 `istream `和` ostream`。特别需要指出的是，为了避免多继承的二义性，从` ios` 派生出` istream `和` ostream` 时，均使用了 `virtual `关键字（虚继承）。

图中这些流类各自的功能分别为：

- `istream`：常用于接收从键盘输入的数据；
- `ostream`：常用于将数据输出到屏幕上；
- `ifstream`：用于读取文件中的数据；
- `ofstream`：用于向文件中写入数据；
- `iostream`：继承自 `istream `和` ostream` 类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出；
- `fstream`：兼` ifstream `和 `ofstream` 类功能于一身，既能读取文件中的数据，又能向文件中写入数据。

# iostream

在前面章节的学习中，只要涉及输入或者输出数据，我们立马想到的就是 `cin` 和 `cout`。其实，`cin` 就是 `istream `类的对象，`cout `是` ostream `类的对象，它们都声明在` <iostream> `头文件中，这也解释了“为什么在 C++ 程序中引入 `<iostream> `就可以使用 `cin `和` cout`”（当然使用 `cin `和 `cout`，还需要声明 `std` 命名空间）。

除此之外，`<iostream>`头文件中还声明有 2 个 `ostream `类对象，分别为 `cerr` 和 `clog`。它们的用法和 `cout` 完全一样，但 `cerr` 常用来输出警告和错误信息给程序的使用者，`clog` 常用来输出程序执行过程中的日志信息（此部分信息只有程序开发者看得到，不需要对普通用户公开）。

`cout`、`cerr` 和 `clog` 之间的区别如下：

- `cout` 除了可以将数据输出到屏幕上，通过重定向（后续会讲），还可以实现将数据输出到指定文件中；而 `cerr` 和 `clog` 都不支持重定向，它们只能将数据输出到屏幕上；

- `cout` 和 `clog` 都设有缓冲区，即它们在输出数据时，会先将要数据放到缓冲区，等缓冲区满或者手动换行（使用换行符 `\n` 或者 `endl`）时，才会将数据全部显示到屏幕上；而 `cerr` 则不设缓冲区，它会直接将数据输出到屏幕上。


除了以上 2 点特性上的不同之外，`cerr`、`clog` 和 `cout` 没有任何不同。之所以我们常用 `cout`，是因为 `cerr` 和 `clog` 有各自不同的适用场景。以 `cerr` 为例，一旦程序某处使用 `cerr` 输出数据，我们自然而然地会认为此处输出的是警告或者错误信息。

> 值得一提的是，类似 `cin`、`cout`、`cerr `和 `clog` 这样，它们都是 C++ 标准库的开发者创建好的，可以直接拿来使用，这种在 C++ 中提前创建好的对象称为<mark>内置对象</mark>。实际上，`<iostream>` 头文件中还声明有处理宽字符的 4 个内置对象，分别为 `wcin`、`wcout`、`wcerr `以及 `wclog`，由于不是本节重点，这里不再对它们做详细讲解。

如下程序演示了 `cin`、`cout`、`cerr` 和 `clog `的基本用法：

```cpp
#include <iostream>
#include <string>
int main()
{   
    std::string url; 
    std::cin >> url;  
    std::cout << "cout：" << url << std::endl; 
    std::cerr << "cerr：" << url << std::endl; 
    std::clog << "clog：" << url << std::endl;  
    return 0;
}
```

程序执行结果为：

```
hi
cout：hi
cerr：hi
clog：hi
```

> 注意，此程序中并没有考虑 `cerr `和 `clog` 各自特有的含义，这里仅是为了演示 `cerr` 和 `clog `的基础用法，不建议读者这样使用。另外，如果程序中` std `命名空间提前声明，则所有的` std:: `可以省略。

它们的用法远不止此，`istream` 和 `ostream` 类提供了很多实用的函数，`cin`、`cout`、`cerr `和` clog `作为类对象，当然也能调用。

表罗列了 `cin` 对象常用的一些成员方法以及它们的功能：

| 成员方法名          | 功能                                                         |
| ------------------- | ------------------------------------------------------------ |
| `getline(str,n,ch)` | 从输入流中接收 $n-1$ 个字符给 `str` 变量，当遇到指定 `ch` 字符时会停止读取，默认情况下 `ch` 为 `\0`。 |
| `get()`             | 从输入流中读取一个字符，同时该字符会从输入流中消失。         |
| `gcount()`          | 返回上次从输入流提取出的字符个数，该函数常和 `get()`、`getline()`、`ignore()`、`peek()`、`read()`、`readsome()`、`putback()` 和 `unget()` 联用。 |
| `peek()`            | 返回输入流中的第一个字符，但并不是提取该字符。               |
| `putback(c)`        | 将字符 `c` 置入输入流（缓冲区）。                            |
| `ignore(n,ch)`      | 从输入流中逐个提取字符，但提取出的字符被忽略，不被使用，直至提取出 $n$ 个字符，或者当前读取的字符为 `ch`。 |
| `operator>>`        | 重载 `>>` 运算符，用于读取指定类型的数据，并返回输入流对象本身。 |


表罗列了 `cout`、`cerr` 和` clog `对象常用的一些成员方法以及它们的功能：


| 成员方法名   | 功能                                               |
| ------------ | -------------------------------------------------- |
| `put()`      | 输出单个字符。                                     |
| `write()`    | 输出指定的字符串。                                 |
| `tellp()`    | 用于获取当前输出流指针的位置。                     |
| `seekp()`    | 设置输出流指针的位置。                             |
| `flush()`    | 刷新输出流缓冲区。                                 |
| `operator<<` | 重载 `<<` 运算符，使其用于输出其后指定类型的数据。 |

举个例子：

```cpp
#include <iostream>
using namespace std;
int main()
{   
    char url[30] = {0};   
    //读取一行字符串   
    cin.getline(url, 30);   
    //输出上一条语句读取字符串的个数    
    cout << "读取了 "<<cin.gcount()<<" 个字符" << endl;  
    //输出 url 数组存储的字符串   
    cout.write(url, 30);
    return 0;
}
```

程序执行结果为：

```
hi
读取了 2 个字符
hi
```

## `put()`

通过前面的学习我们知道，C++程序中一般用 `ostream` 类的 `cout `输出流对象和` << `输出运算符实现输出，并且` cout `输出流在内存中有相应的缓冲区。但有时用户还有特殊的输出需求，例如只输出一个字符，这种情况下可以借助该类提供的 `put()` 成员方法实现。

`put() `方法专用于向输出流缓冲区中添加单个字符，其语法格式如下：

```cpp
ostream&put(char c);
```

其中，参数` c` 为要输出的字符。

可以看到，该函数会返回一个 `ostream `类的引用对象，可以理解返回的是 `cout` 的引用。这意味着，我们可以像下面这样使用 `put()` 函数：

```cpp
cout.put(c1).put(c2).put(c3);
```

因为` cout.put(c1)` 向输出流缓冲区中添加` c1` 字符的同时，返回一个引用形式的 `cout `对象，所以可以继续用此对象调用 `put(c2)`，依次类推。 

例如输出单个字符 `a`。

```cpp
cout.put('a');
```

调用该方法的结果是在屏幕上显示一个字符 `a`。

`put()` 函数的参数可以是字符或字符的 ASCII 代码（也可以是一个整型表达式）：

```cpp
cout.put(65 + 32);
cout.put(97);
```

上面两行代码都输出字符 `a`，因为 97 是字符 `a` 的 ASCII 代码。

## `write()`

在某些场景中，我们还需要输出指定的字符串，这时可以使用 `ostream` 类提供的 `write()` 成员方法。

`write()` 成员方法专用于向输出流缓冲区中添加指定的字符串，初学者可以简单的理解为输出指定的字符串。其语法格式如下：

```cpp
ostream&write(const char * s,streamsize n);
```

其中，`s` 用于指定某个长度至少为 $n$ 的字符数组或字符串；`n` 表示要输出的前 $n$ 个字符。

可以看到，该函数会返回一个 `ostream` 类的引用对象，可以理解返回的是 `cout `的引用。这意味着，我们可以像下面这样使用 `write()` 方法：

```cpp
cout.write(c1, 1).write(c2, 2).write(c3, 3);
```

因为 `cout.write(c1, 1)` 向输出流缓冲区中添加 `c1` 字符串中第 1 字符的同时，会返回一个引用形式的 `cout `对象，所以可以继续用此对象调用 `write(c2, 2)`，向输出流缓冲区添加 `c2 `字符串中前 2 个字符，依次类推。

例如输出 "hiabcdefgh" 字符串中前 4 个字符：

```cpp
#include <iostream>
using namespace std;
int main()
{   
    const char * str = "hiabcdefgh";  
    cout.write(str, 4);   
    return 0;
}
```

程序执行结果为：

```
hiab
```


又如连续使用 `write()` 方法：

```cpp
#include <iostream>
using namespace std;
int main()
{   
    cout.write("https://", 8).write("baidu", 5).write(".com", 4); 
    return 0;
}
```

程序执行结果为：

```
https://baidu.com
```

## 修改缓冲区

无论是使用 `cout` 输出普通数据，用 `cout.put() `输出指定字符，还是用 `cout.write() `输出指定字符串，数据都会先放到输出流缓冲区，待缓冲区刷新，数据才会输出到指定位置（屏幕或者文件中）。

值得一提的是，当数据暂存于输出流缓冲区中时，我们仍可以对其进行修改。`ostream` 类中提供有 `tellp() `和 `seekp() `成员方法，借助它们就可以修改位于输出流缓冲区中的数据。

### `tellp()`

首先，`tellp() `成员方法用于获取当前输出流缓冲区中最后一个字符所在的位置，其语法格式如下：

```cpp
streampos tellp();
```

显然，`tellp() `不需要传递任何参数，会返回一个 `streampos `类型值。事实上，`streampos `是 `fpos` 类型的别名，而` fpos` 通过自动类型转换，可以直接赋值给一个整形变量（即 `short`、`int` 和 `long`）。也就是说，在使用此函数时，我们可以用一个整形变量来接收该函数的返回值。

> 注意，当输出流缓冲区中没有任何数据时，该函数返回的整形值为 0；当指定的输出流缓冲区不支持此操作，或者操作失败时，该函数返回的整形值为 -1。

在下面的样例中，实现了借助 `cout.put()` 方法向 `test.txt` 文件中写入指定字符，由于此过程中字符会先存入输出流缓冲区，所以借助 `tellp()` 方法，我们可以实时监控新存入缓冲区中字符的位置。

举个例子：

```cpp
#include <iostream> //cin 和 cout
#include <fstream> //文件输入输出流
int main() 
{   
    //定义一个文件输出流对象  
    std::ofstream outfile;  
    //打开 test.txt，等待接收数据  
    outfile.open("test.txt");   
    const char * str = "hiabcdefgh";  
    //将 str 字符串中的字符逐个输出到 test.txt 文件中，每个字符都会暂时存在输出流缓冲区中  
    for (int i = 0; i < strlen(str); i++)
    {       
        outfile.put(str[i]);       
        //获取当前输出流 
        long pos = outfile.tellp();   
        std::cout << pos << std::endl;  
    }   
    //关闭文件之前，刷新 outfile 输出流缓冲区，使所有字符由缓冲区流入test.txt文件  
    outfile.close();  
    return 0;
}
```

其输出结果为 1~10。这意味着，程序中每次向输出流缓冲区中放入字符时，`pos` 都表示的是当前字符的位置。比如，当将 `str` 全部放入缓冲区中时，`pos` 值为10，表示的是最后一个字符`h`位于第 10个位置处。

### `seekp()`

`seekp()` 方法用于指定下一个进入输出缓冲区的字符所在的位置。

举个例子，假设当前输出缓冲区中存有如下数据：

```
hiabcdefgh
```

借助 `tellp()` 方法得知，最后一个`h`字符所在的位置是 10。此时如果继续向缓冲区中存入数据，则下一个字符所在的位置应该是11，但借助 `seekp()` 方法，我们可以手动指定下一个字符存放的位置。

比如通过 `seekp() `指定下一个字符所在的位置为 3，即对应字符 'a' 所在的位置。此时若再向缓冲区中存入 `python`，则缓冲区中存储的数据就变成了：

```
hipythongh
```

显然，新的 `python` 覆盖了原来的 `abcdef`。

`seekp() `方法有如下 2 种语法格式：

```cpp
//指定下一个字符存储的位置
ostream& seekp (streampos pos);
//通过偏移量间接指定下一个字符的存储位置   
ostream& seekp (streamoff off, ios_base::seekdir way);
```

其中，各个参数的含义如下：

- `pos`：用于接收一个正整数；、
- `off`：用于指定相对于` way `位置的偏移量，其本质也是接收一个整数，可以是正数（代表正偏移）或者负数（代表负偏移）；
- `way`：用于指定偏移位置，即从哪里计算偏移量，它可以接收表 1 所示的 3 个值。

| 模式标志   | 描 述                    |
| ---------- | ------------------------ |
| `ios::beg` | 从文件头开始计算偏移量   |
| `ios::end` | 从文件末尾开始计算偏移量 |
| `ios::cur` | 从当前位置开始计算偏移量 |

同时，`seekp()` 方法会返回一个引用形式的 `ostream` 类对象，这意味着 `seekp()` 方法可以这样使用：

```cpp
cout.seekp(23) << "当前位置为：" << cout.tellp();
```

## 格式化输出

在某些实际场景中，我们经常需要按照一定的格式输出数据，比如输出浮点数时保留 2 位小数，再比如以十六进制的形式输出整数，等等。

对于学过 C 语言的读者应该知道，当使用 `printf()` 函数输出数据时，可以通过设定一些合理的格式控制符，来达到以指定格式输出数据的目的。例如 `%.2f `表示输出浮点数时保留 2 位小数，`%#X` 表示以十六进制、带 `0X` 前缀的方式输出整数。

C++ 通常使用 `cout` 输出数据，和 `printf()` 函数相比，`cout` 实现格式化输出数据的方式更加多样化。一方面，`cout `作为 `ostream` 类的对象，该类中提供有一些成员方法，可实现对输出数据的格式化；另一方面，为了方面用户格式化输出数据，C++ 标准库专门提供了一个 `<iomanip>` 头文件，该头文件中包含有大量的格式控制符（严格意义上称为<mark>流操纵算子</mark>），使用更加方便。

### cout成员方法格式化输出

`ostream` 类中包含一些可实现格式化输出的成员方法，这些成员方法都是从 `ios `基类（以及 `ios_base` 类）中继承来的，`cout`（以及` cerr`、`clog`）也能调用。

表罗列了 `ostream `类中可实现格式化输出的常用成员方法，以及它们各自的用法。

| 成员函数            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `flags(fmtfl)`      | 当前格式状态全部替换为 `fmtfl`。注意，`fmtfl `可以表示一种格式，也可以表示多种格式。 |
| `precision(n)`      | 设置输出浮点数的精度为 `n`。                                 |
| `width(w)`          | 指定输出宽度为` w `个字符。                                  |
| `fill(c)`           | 在指定输出宽度的情况下，输出的宽度不足时用字符` c `填充（默认情况是用空格填充）。 |
| `setf(fmtfl, mask)` | 在当前格式的基础上，追加` fmtfl `格式，并删除 `mask`格式。其中，`mask `参数可以省略。 |
| `unsetf(mask)`      | 在当前格式的基础上，删除` mask `格式。                       |


其中，对于表中` flags() `函数的 `fmtfl `参数、`setf() `函数中的 `fmtfl `参数和 `mask `参数以及` unsetf() `函数 `mask `参数，可以选择表中列出的这些值。

| 标 志             | 作 用                                                        |
| ----------------- | ------------------------------------------------------------ |
| `ios::boolapha`   | 把 `true` 和` false` 输出为字符串                            |
| `ios::left`       | 输出数据在本域宽范围内向左对齐                               |
| `ios::right`      | 输出数据在本域宽范围内向右对齐                               |
| `ios::internal`   | 数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充   |
| `ios::dec`        | 设置整数的基数为 10                                          |
| `ios::oct`        | 设置整数的基数为 8                                           |
| `ios::hex`        | 设置整数的基数为 16                                          |
| `ios::showbase`   | 强制输出整数的基数（八进制数以` 0` 开头，十六进制数以 `0x` 打头） |
| `ios::showpoint`  | 强制输出浮点数的小点和尾数 0                                 |
| `ios::uppercase`  | 在以科学记数法格式 `E `和以十六进制输出字母时以大写表示      |
| `ios::showpos`    | 对正数显示`+`号                                              |
| `ios::scientific` | 浮点数以科学记数法格式输出                                   |
| `ios::fixed`      | 浮点数以定点格式（小数形式）输出                             |
| `ios::unitbuf`    | 每次输出之后刷新所有的流                                     |

举个例子：

```cpp
#include <iostream>
using namespace std;
int main()
{   
    double a = 1.23;   
    //设定后续输出的浮点数的精度为 4  
    cout.precision(4);   
    cout <<"precision: "<< a << endl;   
    //设定后续以科学计数法的方式输出浮点数  
    cout.setf(ios::scientific);  
    cout <<"scientific："<< a << endl; 
    return 0;
}
```

程序执行结果为：

```
precision: 1.23
scientific：1.2300e+00
```

> 注意，当 cout 采用此方式进行格式化输出时，其后不能立即输出数据，而只能像示例程序中那样，再用一个 cout 输出数据。

值得一提的是，当调用 `unsetf() `或者 2 个参数的 `setf() `函数时，为了提高编写代码的效率，可以给 `mask `参数传递如下 3 个组合格式：

- `ios::adjustfield`：等价于 `ios::left | ios::right | ios::internal`；
- `ios::basefield`：等价于 `ios::dec | ios::oct | ios::hex`；
- `ios::floatfield`：等价于 `ios::scientific | ios::fixed`。


举个例子：

```cpp
#include <iostream>
using namespace std;
int main()
{ 
    double f = 123;   
    //设定后续以科学计数法表示浮点数   
    cout.setf(ios::scientific); 
    cout << f << '\n';  
    //删除之前有关浮点表示的设定 
    cout.unsetf(ios::floatfield);   
    cout << f;   
    return 0;
}
```

程序执行结果为：

```
1.230000e+02
123
```

### 流操纵算子格式化输出

表罗列了 `<iomanip> `头文件中定义的一些常用的格式控制符，它们都可用于格式化输出。

| 流操纵算子            | 作  用                                                       |
| --------------------- | ------------------------------------------------------------ |
| *`dec`                | 以十进制形式输出整数                                         |
| `hex`                 | 以十六进制形式输出整数                                       |
| `oct`                 | 以八进制形式输出整数                                         |
| `fixed`               | 以普通小数形式输出浮点数                                     |
| `scientific`          | 以科学计数法形式输出浮点数                                   |
| `left`                | 左对齐，即在宽度不足时将填充字符添加到右边                   |
| *`right`              | 右对齐，即在宽度不足时将填充字符添加到左边                   |
| `setbase(b)`          | 设置输出整数时的进制，`b`=8、10 或 16                        |
| `setw(w)`             | 指定输出宽度为 `w` 个字符，或输入字符串时读入` w` 个字符。**注意，该函数所起的作用是一次性的，即只影响下一次 `cout `输出。** |
| `setfill(c)`          | 在指定输出宽度的情况下，输出的宽度不足时用字符 `c` 填充（默认情况是用空格填充） |
| `setprecision(n)`     | 设置输出浮点数的精度为 `n`。  在使用非 `fixed `且非 `scientific` 方式输出的情况下，`n `即为有效数字最多的位数，如果有效数字位数超过 `n`，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共` n `位有效数字。  在使用` fixed `方式和 `scientific `方式输出的情况下，`n `是小数点后面应保留的位数。 |
| `setiosflags(mask)`   | 在当前格式状态下，追加 `mask` 格式，`mask `参数可选择表 2 中的所有值。 |
| `resetiosflags(mask)` | 在当前格式状态下，删除` mask` 格式，`mask` 参数可选择表 2 中的所有值。 |
| `boolapha`            | 把 `true `和` false `输出为字符串                            |
| *`noboolalpha`        | 把`true `和 `false `输出为 0、1                              |
| `showbase`            | 输出表示数值的进制的前缀                                     |
| *`noshowbase`         | 不输出表示数值的进制.的前缀                                  |
| `showpoint`           | 总是输出小数点                                               |
| *`noshowpoint`        | 只有当小数部分存在时才显示小数点                             |
| `showpos`             | 在非负数值中显示` +`                                         |
| *`noshowpos`          | 在非负数值中不显示 `+`                                       |
| `uppercase`           | 十六进制数中使用` A`~`E`。若输出前缀，则前缀输出 `0X`，科学计数法中输出 `E` |
| *`nouppercase`        | 十六进制数中使用 `a`~`e`。若输出前缀，则前缀输出 `0x`，科学计数法中输出 `e`。 |
| `internal`            | 数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。 |

> 注意：“流操纵算子”一栏带有星号 * 的格式控制符，默认情况下就会使用。例如在默认情况下，整数是用十进制形式输出的，等效于使用了` dec` 格式控制符。

和 `cout `成员方法的用法不同，下面程序演示了表 3 中这些格式控制符的用法：

```cpp
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{   
    //以十六进制输出整数  
    cout << hex << 16 << endl;   
    //删除之前设定的进制格式，以默认的 10 进制输出整数 
    cout << resetiosflags(ios::basefield)<< 16 << endl;   
    double a = 123;  
    //以科学计数法的方式输出浮点数  
    cout << scientific << a << endl;   
    //删除之前设定的科学计数法的方法 
    cout << resetiosflags(ios::scientific) << a << endl; 
    return 0;
}
```

程序执行结果为：

```
10
16
1.230000e+02
123
```

> 注意，如果两个相互矛盾的标志同时被设置，如先设置 `setiosflags(ios::fixed)`，然后又设置 `setiosflags(ios::scientific)`，那么结果可能就是两个标志都不起作用。因此，在设置了某标志，又要设置其他与之矛盾的标志时，就应该用 `resetiosflags `清除原先的标志。

## 重定向

`cout` 和` cerr`、`clog `的一个区别是，`cout `允许被重定向，而 `cerr `和 `clog `都不支持。值得一提的是，`cin `也允许被重定向。

那么，什么是重定向呢？在默认情况下，`cin `只能接收从键盘输入的数据，`cout `也只能将数据输出到屏幕上。但通过重定向，`cin `可以将指定文件作为输入源，即接收文件中早已准备好的数据，同样` cout` 可以将原本要输出到屏幕上的数据转而写到指定文件中。

### `freopen()`函数实现重定向

`freopen()` 定义在`<stdio.h>`头文件中，是 C 语言标准库中的函数，专门用于重定向输入流（包括 `scanf()`、`gets() `等）和输出流（包括` printf()`、`puts() `等）。值得一提的是，该函数也可以对 C++ 中的` cin `和 `cout` 进行重定向。

举个例子：

```cpp
#include <iostream>    //cin、cout
#include <string>      //string
#include <stdio.h>     //freopen
using namespace std;
int main()
{   
    string name, url;  
    //将标准输入流重定向到 in.txt 文件  
    freopen("in.txt", "r", stdin);  
    cin >> name >> url;    
    //将标准输出重定向到 out.txt文件 
    freopen("out.txt", "w", stdout); 
    cout << name << "\n" << url;  
    return 0;
}
```

执行此程序之前，我们需要找到当前程序文件所在的目录，并手动创建一个` in.txt `文件，其包含的内容如下：

```
C++
hi
```

创建好 `in.txt` 文件之后，可以执行此程序，其执行结果为：控制台中，既不需要手动输入，也没有任何输出。与此同时，`in.txt` 文件所在目录下会自动生成一个 `out.txt `文件，其包含的内容和 i`n.txt `文件相同。

显然，通过 2 次调用 `freopen() `函数，分别对输入流和输出流重定向，使得` cin `不再接收由键盘输入的数据，而是直接从` in.txt` 文件中获取数据；同样，`cout `也不再将数据输出到屏幕上，而是写入到 `out.txt `文件中。

### `rdbuf()`函数实现重定向

`rdbuf()` 函数定义在`<ios>`头文件中，专门用于实现 C++ 输入输出流的重定向。值得一提的是，`ios` 作为` istream `和 `ostream `类的基类，`rdbuf() `函数也被继承，因此 `cin `和` cout `可以直接调用该函数实现重定向。

`rdbuf() `函数的语法格式有 2 种，分别为：

```cpp
streambuf * rdbuf() const;
streambuf * rdbuf(streambuf * sb);
```

> `streambuf` 是 C++ 标准库中用于表示缓冲区的类，该类的指针对象用于代指某个具体的流缓冲区。

其中，第一种语法格式仅是返回一个指向当前流缓冲区的指针；第二种语法格式用于将 sb 指向的缓冲区设置为当前流的新缓冲区，并返回一个指向旧缓冲区的对象。举个例子：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
int main()
{   
    //打开 in.txt 文件，等待读取 
    ifstream fin("in.txt");   
    //打开 out.txt 文件，等待写入 
    ofstream fout("out.txt");  
    streambuf *oldcin; 
    streambuf *oldcout;    
    char a[100];  
    //用 rdbuf() 重新定向，返回旧输入流缓冲区指针 
    oldcin = cin.rdbuf(fin.rdbuf()); 
    //从input.txt文件读入 
    cin >> a;   
    //用 rdbuf() 重新定向，返回旧输出流缓冲区指针
    oldcout = cout.rdbuf(fout.rdbuf()); 
    //写入 out.txt 
    cout << a << endl;  
    //还原标准输入输出流 
    cin.rdbuf(oldcin); // 恢复键盘输入 
    cout.rdbuf(oldcout); //恢复屏幕输出   
    //打开的文件，最终需要手动关闭  
    fin.close();   
    fout.close();  
    return 0;
}
```

### 控制台重定向

以上 2 种方法，都是从代码层面实现输入输出流的重定向。除此之外，我们还可以通过控制台实现输入输出的重定向。

举个例子，假设有如下代码（文件名为 `demo.cpp`）：

```cpp
#include <iostream>
#include <string>
using namespace std;
int main()
{   
    string name, url; 
    cin >> name >> url;    
    cout << name << '\n' << url;  
    return 0;
}
```

通过编译、链接后，会生成一个 `demo.exe `可执行文件，该执行文件可以双击执行，也可以在控制台上执行。例如，打开控制台（Windows 系统下指的是 CMD命令行窗口，Linux 系统下指的是 Shell 终端），并输入如下指令：

```
C:\Users\mengma>D:\demo.exe
C++ hi
C++
hi
```

可以看到，`demo.ext` 成功被执行，但程序中的 `cin` 和 `cout `并没有被重定向，因此这里仍需要我们手动输入测试数据。

在此基础上，继续在控制台执行如下指令：

```
C:\Users\mengma>D:\demo.exe <in.txt >out.txt
```

> 需要注意的是，执行此命令前，需保证 C:\Users\mengma 目录下有 in.txt 文件。

执行后会发现，控制台没有任何输出。这是因为，我们使用了`<in.txt`对程序中的 `cin` 输入流做了重定向，同时还用 `>out.txt`对程序中的` cout `输出流做了重定向。

如果此时读者进入 `C:\Users\mengma `目录就会发现，当前目录生成了一个` out.txt `文件，其中就存储了 `demo.exe` 的执行结果。

> 在控制台中使用 > 或者 < 实现重定向的方式，DOS、windows、Linux 以及 UNIX 都能自动识别。

## 缓冲区

每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下而的代码：

```cpp
cout << "hi";
```

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。

有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。

导致缓冲刷新（数据真正写到输出设备或文件）的原因有很多：

- 程序正常结束，作为 `main() `函数的 `return` 操作的一部分，缓冲刷新被执行。
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
- 我们可以使用操纵符如 `endl `来显式刷新缓冲区。
- 在每个输出操作之后，我们可以用操作符` unitbuf `设置流的内部状态，来清空缓冲区。默认情况下，对 `cerr` 是设置 `unitbuf` 的，因此写到 `cerr `的内容都是立即刷新的。
- 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，`cin `和 `cerr `都关联到 `cout`。因此，读` cin` 或写` cerr `都会导致 `cout `的缓冲区被刷新。

### 刷新输出缓冲区

我们已经使用过操作符 `endl`，它完成换行并刷新缓冲区的工作。IO 库中还有两个类似的操纵符`flush` 和 `ends`：

- `flush` 刷新缓冲区，但不输出任何额外的字符；
- `ends`向缓冲区插入一个空字符，然后刷新缓冲区。

> 值得一提得是，`cout` 所属 `ostream `类中还提供有 `flush() `成员方法，它和`flush `操纵符的功能完全一样，仅在使用方法上（ `cout.flush() `）有区别。

请看下面的例子：

```cpp
cout << "hi!" << endl;  //输出hi和一个换行，然后刷新缓冲区
cout << "hi!" << flush;  //输出hi，然后刷新缓冲区，不附加任何额外字符
cout << "hi!" << ends;  //输出hi和一个空字符，然后刷新缓冲区
```

### `unitbuf` 操作符

如果想在每次输出操作后都刷新缓冲区，我们可以使用`unitbuf` 操作符，它告诉流在接下来的每次写操作之后都进行一次 `flush` 操作。而 `nounitbuf `操作符则重置流， 使其恢复使用正常的系统管理的缓冲区刷新机制：

```cpp
cout << unitbuf;  //所有输出操作后都会立即刷新缓冲区
//任何输出都立即刷新，无缓冲
cout << nounitbuf;  //回到正常的缓冲方式
```

**警告：如果程序崩溃，输出缓冲区不会被刷新**

如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。

### 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将 `cout` 和` cin `关联在一起，因此下面语句：

```cpp
cin >> ival;
```

导致 `cout` 的缓冲区被刷新。

交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。

`tie()` 函数可以用来绑定输出流，它有两个重载的版本：

```cpp
ostream* tie ( ) const; //返回指向绑定的输出流的指针。
ostream* tie ( ostream* os ); //将 os 指向的输出流绑定的该对象上，并返回上一个绑定的输出流指针。
```

第一个版本不带参数，返冋指向出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。

`tie()` 的第二个版本接受一个指向` ostream` 的指针，将自己关联到此 `ostream`，即，`x.tie(&o)` 将流 `x `关联到输出流` o`。

我们既可以将一个 `istream `对象关联到另一个 `ostream`，也可以将一个 `ostream `关联到另一个` ostream`：

```cpp
cin.tie(&cout);  //仅仅是用来展示，标准库已经将 cin 和 cout 关联在一起
//old_tie 指向当前关联到 cin 的流（如果有的话）
ostream *old_tie = cin.tie(nullptr);  // cin 不再与其他流关联
//将 cin 与 cerr 关联，这不是一个好主意，因为 cin 应该关联到
coutcin.tie(&cerr);  //读取 cin 会刷新 cerr 而不是 cout
cin.tie(old_tie);  //重建 cin 和 cout 间的正常关联
```

在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了 `tie()`。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流， 但多个流可以同时关联到同一个`ostream`。

## `get()`

`get() `是 `istream `类的成员函数，它有多种重载形式，不过本文只介绍最简单最常用的一种：

```cpp
int get();
```

此函数从输入流中读入一个字符，返回值就是该字符的 ASCII 码。如果碰到输入的末尾，则返回值为 `EOF`。

`istream` 类中从输入流（包括文件）中读取数据的成员函数，在把输入数据都读取完后再进行读取，就会返回 `EOF`。`EOF` 是在` iostream `类中定义的一个整型常量，值为` -1`。

`get()` 函数不会跳过空格、制表符、回车等特殊字符，所有的字符都能被读入。例如下面的程序：

```cpp
#include <iostream>
using namespace std;
int main()
{  
    int c; 
    while ((c = cin.get()) != EOF)  
        cout.put(c);    
    return 0;
}
```

程序运行情况如下：

```
hi
hi
C++ Tutorial
C++ Tutorial
^Z
```

`^Z`表示 <kbd>Ctrl</kbd>+<kbd>Z</kbd> 组合键。

程序中的变量 `c` 应为 `int `类型，而不能是 `char` 类型。在输入流中碰到 ASCII 码等于 `0xFF` 的字符时，`cin.get() `返回 `0xFF`，`0xFF `赋值给` c`，此时如果 `c `是 `char `类型的，那么其值就是 `-1`（因为符号位为 `1` 代表负数），即等于` EOF`，于是程序就错误地认为输入已经结束。

而在 `c` 为` int `类型的情况下，将` 0xFF `赋值给 `c`，`c` 的值是` 255`（因为符号位为 `0`，是正数），而非` -1`，即除非读到输入末尾，`c `的值都不可能是 `-1`。

要将文本文件` test.txt` 中的全部内容原样显示出来，程序可以如下编写：

```cpp
#include <iostream>
using namespace std;
int main()
{   
    int c;    
    freopen("test.txt", "r", stdin);  //将标准输入重定向为 test.txt 
    while ((c = cin.get()) != EOF)  
        cout.put(c);   
    return 0;
}
```

## `getline()`

`getline()` 是` istream`类的成员函数，它有如下两个重载版本：

```cpp
istream & getline(char* buf, int bufSize);
istream & getline(char* buf, int bufSize, char delim);
```

第一个版本从输入流中读取 `bufSize`-1 个字符到缓冲区 `buf`，或遇到`\n`为止（哪个条件先满足就按哪个执行）。函数会自动在` buf `中读入数据的结尾添加`\0`。

第二个版本和第一个版本的区别在于，第一个版本是读到`\n`为止，第二个版本是读到 `delim` 字符为止。`\n`或 `delim` 都不会被读入` buf`，但会被从输入流中取走。

这两个函数的返回值就是函数所作用的对象的引用。如果输入流中`\n`或 `delim `之前的字符个数达到或超过 `bufSize`，就会导致读入出错，其结果是：虽然本次读入已经完成，但是之后的读入都会失败。

从输入流中读入一行，可以用第一个版本。用`cin >> str`这种写法是不行的，因为此种读法在碰到行中的空格或制表符时就会停止，因此就不能保证 `str` 中读入的是整行。

第一个版本的 `getline` 函数的用法示例如下：

```cpp
#include <iostream>
using namespace std;
int main()
{   
    char szBuf[20];  
    int n = 120;  
    if(!cin.getline(szBuf,6))  //如果输入流中一行字符超过5个，就会出错  
        cout << "error" << endl;   
    cout << szBuf << endl;   
    cin >> n;  
    cout << n  << endl;  
    cin.clear(); //clear能够清除cin内部的错误标记，使之恢复正常 
    cin >> n;    
    cout << n << endl;   
    return 0;
}
```

程序的运行过程如下：

```
ab cd
ab cd
33
33
44
44
```

在上面的输入情况下，程序是正常的。程序运行过程中还可能出现如下情况：

```
ab cd123456k
error
ab cd
120
123456
```

第 7 行，读入时因字符串超长导致出错，于是第 11 行并没有从输入流读入 `n`，`n` 维持了原来的值 120。

第 12 行，调用` istream `的成员函数 `clear() `清除 `cin `内部的错误标记，此后 `cin `又能正常读入了。因此，123456 在第 13 行被读入` n`。

可以用 `getline() `函数的返回值（为` false `则输入结束）来判断输入是否结束。例如，要将文件 `test.txt` 中的全部内容（假设文件中一行最长有 10 000个字符）原样显示，程序可以如下编写：

```cpp
#include <iostream>
using namespace std;
const int MAX_LINE_LEN = 10000;  //假设文件中一行最长 10000 个字符
int main()
{   
    char szBuf[MAX_LINE_LEN + 10];   
    freopen("test.txt", "r", stdin);  //将标准输入重定向为 test.txt  
    while (cin.getline(szBuf, MAX_LINE_LEN + 5))    
        cout << szBuf << endl;   
    return 0;
}
```

程序每次读入文件中的一行到 `szBuf` 并输出。`szBuf` 中不会读入回车符，因此输出 `szBuf `后要再输出 `endl `以换行。

## `ignore()`

`ignore()` 是 `istream` 类的成员函数，它的原型是：

```cpp
istream & ignore(int n =1, int delim = EOF);
```

此函数的作用是跳过输入流中的 `n `个字符，或跳过 `delim `及其之前的所有字符，哪个条件先满足就按哪个执行。两个参数都有默认值，因此` cin.ignore() `就等效于` cin.ignore(1, EOF)`， 即跳过一个字符。

该函数常用于跳过输入中的无用部分，以便提取有用的部分。例如，输入的电话号码形式是`Tel:63652823`，`Tel:`就是无用的内容。例如下面的程序：

```cpp
#include <iostream>
using namespace std;
int main()
{  
    int n;  
    cin.ignore(5, 'A');    
    cin >> n;    
    cout << n;  
    return 0;
}
```

程序的运行过程可能如下：

```
abcde34
34
```

`cin.ignore()` 跳过了输入中的前 5 个字符，其余内容被当作整数输入 `n` 中。

该程序的运行过程也可能如下：

```
abA34
34
```

`cin.ignore() `跳过了输入中的 `A` 及其前面的字符，其余内容被当作整数输入 `n `中。

## `peek()`

`peek()` 是 `istream` 类的成员函数，它的原型是：

```cpp
int peek();
```

此函数返回输入流中的下一个字符，但是并不将该字符从输入流中取走——相当于只是看了一眼下一个字符，因此叫 `peek`。

`cin.peek()` 不会跳过输入流中的空格、回车符。在输入流已经结束的情况下，`cin.peek() `返回 `EOF`。

在输入数据的格式不同，需要预先判断格式再决定如何输入时，`peek()` 就能起到作用。

例题：编写一个日期格式转换程序，输入若干个日期，每行一个，要求全部转换为`mm-dd-yyyy`格式输出。输入的日期格式可以是`2011.12.24`（中式格式），也可以是`Dec 24 2011`（西式格式）。要求该程序对于以下输入数据：

```
Dec 3 1990
2011.2.3
458.12.1
Nov 4 1998
Feb 12 2011
```

输出结果应为：

```
12-03-1990
02-03-2011
12-01-0458
11-04-1998
02-12-2011
```

输入数据中的 <kbd>Ctrl</kbd>+<kbd>Z</kbd> 略去不写，因为输入数据也可能来自于文件。

编写这个程序时，如果输入的是中式格式，就用 `cin>>year`（假设 `year` 是 `int` 类型变量）读取年份，然后再读取后面的内容；如果输入是西式格式，就用 `cin>>sMonth`（假设 `sMonth` 是 `string` 类型对象）读取月份，然后读取后面的内容。

可是，如果没有将数据从输入流中读取出来，就无法判断输入到底是哪种格式。即便用 `cin.get()` 读取一个字符后再作判断，也很不方便。例如，在输入为`2011.12.24`的情况下，读取第一个字符`2`后就知道是格式一，问题是输入流中的已经被读取了，剩下的表示年份的部分只有`011`，如何将这个`011`和前面读取的`2`奏成一个整数 2011，也是颇费周折的事情。使用 `peek()` 函数很容易解决这个问题。

示例程序如下：

```cpp
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;
string Months[12] = { "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug", "Sep","Oct","Nov","Dec" };
int main()
{   
    int c;  
    while((c = cin.peek()) != EOF) 
    { 
        //取输入流中的第一个字符进行查看   
        int year,month,day;   
        if(c >= 'A' && c <= 'Z') 
        { 
            //美国日期格式   
            string sMonth;       
            cin >> sMonth >> day >> year;   
            for(int i = 0;i < 12; ++i) 
                //查找月份      
                if(sMonth == Months[i]) 
                {            
                    month = i + 1;   
                    break;           
                }      
        }      
        else
        { 
            //中国日期格式   
            cin >> year ;   
            cin.ignore() >> month ; //用ignore跳过 "2011.12.3"中的'.'   
            cin.ignore() >> day;       
        }    
        cin.ignore(); //跳过行末 '\n'   
        cout<< setfill('0') << setw(2) << month ;//设置填充字符'\0'，输出宽度2   
        cout << "-" << setw(2) << day << "-" << setw(4) << year << endl; 
    }    
    return 0;
}
```

`istream `还有一个成员函数` istream & putback(char c)`，可以将一个字符插入输入流的最前面。对于上面的例题，也可以在用 `get() `函数读取一个字符并判断是中式格式还是西式格式时，将刚刚读取的字符再用 `putback() `成员函数放回流中，然后再根据判断结果进行不同方式的读入。

## cin判断输入结束

`cin` 可以用来从键盘输入数据；将标准输入重定向为文件后，`cin` 也可以用来从文件中读入数据。在输入数据的多少不确定，且没有结束标志的情况下，该如何判断输入数据已经读完了呢？

从文件中读取数据很好办，到达文件末尾就读取结束了。从控制台读取数据怎么办呢？总不能把控制台关闭吧？这样程序也运行结束了！

其实，在控制台中输入特殊的控制字符就表示输入结束了：

- 在 Windows 系统中，通过键盘输入时，按 Ctrl+Z 组合键后再按回车键，就代表输入结束。
- 在 UNIX/Linux/Mac OS 系统中，Ctrl+D 代表输入结束。

不管是文件末尾，还是 Ctrl+Z 或者 Ctrl+D，它们都是结束标志；cin 在正常读取时返回 true，遇到结束标志时返回 false，我们可以根据 cin 的返回值来判断是否读取结束。

### cin 判断控制台（键盘）读取结束

输入若干个正整数，输出其中的最大值，程序该如何编写？

```cpp
#include <iostream>
using namespace std;
int main()
{  
    int n;   
    int maxN = 0;   
    while (cin >> n)
    { 
        //输入没有结束，cin 就返回 true，条件就为真   
        if (maxN < n)    
            maxN = n;  
    }  
    cout << maxN <<endl;  
    return 0;
}
```

在 Windows 下运行该程序，先输入以下整数：

```
10
30
93
206
8
```

然后在按下 <kbd>Ctrl</kbd>+<kbd>Z</kbd> 组合键（可以在当前行，也可以在新的一行），接着按下回车键，输入就结束了，此时 `cin` 返回 `false`，循环结束，得到了最大值。

完整的输入输出结果如下所示：

```
10
30
93
206
8
^Z
206
```

### cin 判断文件读取结束

如果将标准输入重定向为某个文件，如在程序开始添加`freopen("test.txt", "r", stdin);`语句，或者不添加上述语句，但是在 Windows 的“命令提示符”窗口中输入：

```
mycin < test.txt //假设编译生成的可执行文件的名字为 mycin.exe
```

则都能使得本程序不再从键盘输入数据，而是从 `test.txt` 文件输入数据（前提是` test.txt `文件和 `mycin.exe` 在同一个文件夹中）。在这种情况下，`test.txt` 文件中并不需要包含 <kbd>Ctrl</kbd>+<kbd>Z</kbd> ，只要有用空格或回车隔开的若干个正整数即可。

`cin` 读到文件末尾时，`cin>>n`就会返回` false`，从而导致程序结束。例如，假定` test.txt` 文件中的内容如下所示：

```
112
23123
34 444 55
44
```

对于前面的代码，在“命令提示符”窗口中先 `cd` 到 `mycin.exe` 所在目录，然后输入`mycin < test.txt`，则程序的输出是：

```
23123
```

下面是实操演示图：
![将输入重定向到文件](http://c.biancheng.net/uploads/allimg/190522/1-1Z522135445509.gif)

> istream 类将`>>`重载为成员函数，而且这些成员函数的返回值是` cin `的引用。准确地说，`cin>>n`的返回值的确是` istream & `类型的，而 `while `语句中的条件表达式的返回值应该是` bool `类型、整数类型或其他和整数类型兼容的类型，`istream &` 显然和整数类型不兼容，为什么`while(cin>>n)`还能成立呢？
> 这是因为，`istream` 类对强制类型转换运算符` bool `进行了重载，这使得 `cin` 对象可以被自动转换成` bool `类型。所谓自动转换的过程，就是调用 `cin` 的 `operator bool()` 这个成员函数，而该成员函数可以返回某个标志值，该标志值在` cin` 没有读到输入结尾时为 `true`，读到输入结尾后变为 `false`。对该标志值的设置，在 `operator <<()` 成员函数中进行。
> 如果` cin `在读取过程中发生了错误，`cin>>n`这样的表达式也会返回` false`。例如下面的程序：
> ```cpp
> #include <iostream>
> using namespace std;
> int main()
> {    
>     int n;
>     while (cin >> n)  
>         cout << n << endl; 
>     return 0;
> }
> ```
> 程序本该输入整数，如果输入了一个字母，则程序就会结束。因为，应该读入整数时却读入了字母也算读入出错。

## 输入输出错误

当处理输入输出时，我们必须预计到其中可能发生的错误并给出相应的处理措施。

- 当我们输入时，可能会由于人的失误（错误理解了指令、打字错误、允许自家的小猫在键盘上散步等）、文件格式不符、错误估计了情况等原因造成读取失败。
- 当我们输出时，如果输出设备不可用、队列满或者发生了故障等，都会导致写入失败。


发生输入输出错误的可能情况是无限的！但C++将所有可能的情况归结为四类，称为<mark>流状态</mark>（stream state）。每种流状态都用一个 `iostate `类型的标志位来表示。

| 标志位    | 意义                                                         |
| --------- | ------------------------------------------------------------ |
| `badbit`  | 发生了（或许是物理上的）致命性错误，流将不能继续使用。       |
| `eofbit`  | 输入结束（文件流的物理结束或用户结束了控制台流输入，例如用户按下了 <kbd>Ctrl</kbd>+<kbd>Z</kbd> 或 <kbd>Ctrl</kbd>+<kbd>D</kbd> 组合键。 |
| `failbit` | I/O 操作失败，主要原因是非法数据（例如，试图读取数字时遇到字母）。流可以继续使用，但会设置 `failbit` 标志。 |
| `goodbit` | 一切止常，没有错误发生，也没有输入结束。                     |

`ios_base` 类定义了以上四个标志位以及` iostate `类型，但是` ios `类又派生自` ios_base `类，所以可以使用 `ios::failbit `代替` ios_base::failbit `以节省输入。

一旦流发生错误，对应的标志位就会被设置，我们可以通过下表列出的函数检测流状态。

| 检测函数 | 对应的标志位 | 说明                                                         |
| -------- | ------------ | ------------------------------------------------------------ |
| `good()` | `goodbit`    | 操作成功，没有发生任何错误。                                 |
| `eof()`  | `eofbit`     | 到达输入末尾或文件尾。                                       |
| `fail()` | `failbit`    | 发生某些意外情况（例如，我们要读入一个数字，却读入了字符 `x`）。 |
| `bad()`  | `badbit`     | 发生严重的意外（如磁盘读故障）。                             |

不幸的是，`fail()` 和` bad()` 之间的区别并未被准确定义，程序员对此的观点各种各样。但是，基本的思想很简单：

- 如果输入操作遇到一个简单的格式错误，则使流进入 fail() 状态，也就是假定我们（输入操作的用户）可以从错误中恢复。
- 如果错误真的非常严重，例如发生了磁盘故障，输入操作会使得流进入 bad() 状态。也就是假定面对这种情况你所能做的很有限，只能退出输入。

以上观点导致如下逻辑：

```cpp
int i = 0;
cin >> i;
if(!cin)
{ 
    //只有输入操作失败，才会跳转到这里  
    if(cin.bad())
    { 
        //流发生严重故障，只能退出函数  
        error("cin is bad!"); //error是自定义函数，它抛出异常，并给出提示信息 
    }  
    if(cin.eof())
    {  
        //检测是否读取结束  
        //TODO: 
    }   
    if(cin.fail())
    { 
        //流遇到了一些意外情况  
        cin.clear();//清除/恢复流状态    
        //TODO:   
    }
}
```

`!cin `可以理解为“`cin` 不成功”或者“`cin` 发生了某些错误”或者“` cin` 的状态不是 `good()`”， 这与“操作成功”正好相反。

请注意我们在处理 `fail() `时所使用的 `cin.clear()`。当流发生错误时，我们可以进行错误恢复。为了恢复错误，我们显式地将流从` fail()` 状态转移到其他状态，从而可以继续从中读取字符。`clear() `就起到这样的作用——执行 `cin.clear() `后，`cin` 的状态就变为 `good()`。

下面是一个如何使用流状态的例子。假定我们要读取一个整数序列并存入 `vector `中，字符`*`或“文件尾”表示序列结束。Windows 平台按下 <kbd>Ctrl</kbd>+<kbd>Z</kbd>  组合键，再按下回车键表示到达文件末尾；类Unix系统按下 <kbd>Ctrl</kbd>+<kbd>D</kbd>  组合键表示到达文件末尾。

上述功能可通过如下函数来实现：

```cpp
//从 ist 中读入整数到 v 中，直到遇到 eof() 或终结符
void fill_vector(istream& ist, vector<int>& v, char terminator)
{   
    for( int i; ist>>i; )
        v.push_back(i);    //正常情况  
    if(ist.eof()) 
        return;  //发现到了文件尾，正确，返回  
    //发生严重错误，只能退出函数 
    if (ist.bad())
    {     
        error("cin is bad!");  //error是自定义函数，它抛出异常，并给出提示信息
    }    
    //发生意外情况  
    if (ist.fail())
    {  
        //最好清除混乱，然后汇报问题      
        ist.clear();  //清除流状态     
        //检测下一个字符是否是终结符     
        char c;       
        ist>>c;  //读入一个符号，希望是终结符    
        if(c != terminator) 
        { 
            // 非终结符    
            ist.unget(); //放回该符号 
            ist.clear(ios_base::failbit);  //将流状态设置为fail()   
        } 
    }
}
```

如果发生了` fail()`，我们尝试检测下一个字符是否是结束符：如果是，那么就完整得读取了数据，使用`clear()` 恢复状态就可以；如果不是，我们就没有办法处理了，所以将状态重新设置为` fail()`，以期望 `fill_vector() `的调用者（上层函数）有能力处理。

我们通过调用 `ist.clear(ios_base::failbit) `来将流状态设置为 `fail()`。对照简单的`cleal()`，带参数的用法有些令人迷惑：当 `clear() `带参数时，参数中所指出的` iostream `状态位会被置位（进入相应状态)，而未指出的状态位会被复位。通过将流状态设置为` fail()`，我们表明遇到了一个格式错误，而不是一个更为严重的问题。

可以用` unget()` 将字符放回` ist`，以便 `fill_vector()` 的调用者可能使用该字符。`unget()` 函数是 `putback() `的简化版本，它依赖于流对象记住最后一个字符是什么，所以在这里可以不用考虑它的用法。

如果` fill_vector() `的调用者想知道是什么原因终止了输入，那么可以检测流是处于 `fail()` 还是 `eof()` 状态。当然也可以捕获 `error()` 抛出的 `runtime_error `异常，但当 `istream` 处于 `bad() `状态时，继续获取数据是不可能的。大多数的调用者无须为此烦恼。因为这意味着，几乎在所有情况下，对于 `bad() `状态，我们所能做的只是抛出一个异常。

简单起见，可以让 `istream `帮我们抛出这个异常。

```cpp
//当 ist 出现问题时拋出异常
ist.exceptions(ist.exceptions() | ios_base:: badbit);
```

这样的写法也许看起来有些奇怪，但结果却很简单，当此语句执行时，如果 `ist `处于` bad()` 状态，它会抛出一个标准库异常` ios_base::failure`。在一个程序中，我们只需要调用 `exceptions()` 一次。这允许我们简化关联于` ist `的所有输入过程，同时忽略对` bad() `的处理：

```cpp
//从ist中读入整数到v中，直到遇到eof()或终结符
void fill_vector(istream& ist, vector<int>& v, char terminator)
{    
    ist.exceptions(ist.exceptions() | ios_base:: badbit);  
    for (int i; ist>>i; ) 
        v.push_back(i); 
    if (ist.eof())
        return;  //发现到了文件尾 
    //不是good()，不是bad()，不是eof()，ist的状态一定是fail() 
    ist.clear();  //清除流状态 
    char c;  
    ist>>c;    //读入一个符号，希望是终结符   
    if (c != terminator)
    { 
        //不是终结符号，一定是失败了    
        ist.unget();    //也许程序调用者可以使用这个符号    
        ist.clear(ios_base::failbit); //将流状态设置为 fail()  
    }
}
```

这里使用了 `ios_base`，它是` iostream` 的一部分，包含了对常量如 `badbit `的定义、异常如` failure` 的定义，以及其他一些有用的定义。可以通过`::`操作符来使用它们，例如 `ios_ base::badbit`。

与` istream`—样，`ostream `也有四个状态：`good()`、`fail()`、`eof()` 和 `bad()`。不过，输出错误要比输入错误少得多，因此通常不对 `ostream `进行状态检测。如果程序运行环境中输出设备不可用、队列满或者发生故障的概率很高，我们就可以像处理输入操作那样，在每次输出操作之后都检测其状态。

# fstream

`ifstream` 类和` fstream `类是从 `istream `类派生而来的，因此` ifstream `类拥有` istream `类的全部成员方法。同样地，`ofstream `和 `fstream `类也拥有 `ostream` 类的全部成员方法。这也就意味着，`istream `和` ostream `类提供的供` cin `和` cout `调用的成员方法，也同样适用于文件流。并且这 3 个类中有些成员方法是相同的，比如 `operator <<()`、`operator >>()`、`peek()`、`ignore()`、`getline()`、`get()` 等。

值得一提的是，和 `<iostream> `头文件中定义有` ostream` 和 `istream `类的对象 `cin `和 `cout` 不同，`<fstream> `头文件中并没有定义可直接使用的` fstream`、`ifstream` 和` ofstream `类对象。因此，如果我们想使用该类操作文件，需要自己创建相应类的对象。

> 为什么 C++ 标准库不提供现成的类似 `fin `或者 `fout `的对象呢？其实很简单，文件输入流和输出流的输入输出设备是硬盘中的文件，硬盘上有很多文件，到底应该使用哪一个呢？所以，C++ 标准库就把创建文件流对象的任务交给用户了。

`fstream `类拥有` ifstream `和 `ofstream `类中所有的成员方法，表罗列了` fstream `类一些常用的成员方法。

| 成员方法名          | 适用类对象                                                   |
| ------------------- | ------------------------------------------------------------ |
| `open()`            | 打开指定文件，使其与文件流对象相关联。                       |
| `is_open()`         | 检查指定文件是否已打开。                                     |
| `close()`           | 关闭文件，切断和文件流对象的关联。                           |
| `swap()`            | 交换 2 个文件流对象。                                        |
| `operator>>`        | 重载 `>>` 运算符，用于从指定文件中读取数据。                 |
| `gcount()`          | 返回上次从文件流提取出的字符个数。该函数常和 `get()`、`getline()`、`ignore()`、`peek()`、`read()`、`readsome()`、`putback() `和 `unget()` 联用。 |
| `get()`             | 从文件流中读取一个字符，同时该字符会从输入流中消失。         |
| `getline(str,n,ch)` | 从文件流中接收 $n-1$ 个字符给 `str `变量，当遇到指定 `ch `字符时会停止读取，默认情况下` ch `为 `\0`。 |
| `ignore(n,ch)`      | 从文件流中逐个提取字符，但提取出的字符被忽略，不被使用，直至提取出$ n $个字符，或者当前读取的字符为 `ch`。 |
| `peek()`            | 返回文件流中的第一个字符，但并不是提取该字符。               |
| `putback(c)`        | 将字符`c `置入文件流（缓冲区）。                             |
| `operator<<`        | 重载 `<< `运算符，用于向文件中写入指定数据。                 |
| `put()`             | 向指定文件流中写入单个字符。                                 |
| `write()`           | 向指定文件中写入字符串。                                     |
| `tellp()`           | 用于获取当前文件输出流指针的位置。                           |
| `seekp()`           | 设置输出文件输出流指针的位置。                               |
| `flush()`           | 刷新文件输出流缓冲区。                                       |
| `good()`            | 操作成功，没有发生任何错误。                                 |
| `eof()`             | 到达输入末尾或文件尾。                                       |

这里就以 `fstream `类举例，简单演示一下如何使用表中的一些成员方法操作文件：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
int main()
{ 
    const char *url ="hi"; 
    //创建一个 fstream 类对象  
    fstream fs; 
    //将 test.txt 文件和 fs 文件流关联   
    fs.open("test.txt", ios::out);  
    //向test.txt文件中写入 url 字符串   
    fs.write(url, 30);  
    fs.close();  
    return 0;
}
```

执行程序，该程序同目录下会生成一个 `test.txt `文件，该文件的内容为：

```
hi
```

## 打开文件

在对文件进行读写操作之前，先要打开文件。打开文件有以下两个目的：

- 通过指定文件名，建立起文件和文件流对象的关联，以后要对文件进行操作时，就可以通过与之关联的流对象来进行。
- 指明文件的使用方式。使用方式有只读、只写、既读又写、在文件末尾添加数据、以文本方式使用、以二进制方式使用等多种。

打开文件可以通过以下两种方式进行：

- 调用流对象的 `open` 成员函数打开文件。
- 定义文件流对象时，通过构造函数打开文件。

### 使用 `open` 函数打开文件

先看第一种文件打开方式。以` ifstream `类为例，该类有一个 `open` 成员函数，其他两个文件流类也有同样的 `open `成员函数：

```cpp
void open(const char* szFileName, int mode)
```

第一个参数是指向文件名的指针，第二个参数是文件的打开模式标记。

文件的打开模式标记代表了文件的使用方式，这些标记可以单独使用，也可以组合使用。表 1 列出了各种模式标记单独使用时的作用，以及常见的两种模式标记组合的作用。

| 模式标记                          | 适用对象                          | 作用                                                         |
| --------------------------------- | --------------------------------- | ------------------------------------------------------------ |
| `ios::in`                         | `ifstream ` `fstream`             | 打开文件用于读取数据。如果文件不存在，则打开出错。           |
| `ios::out`                        | `ofstream  ` `fstream`            | 打开文件用于写入数据。如果文件不存在，则新建该文件；如果文件原来就存在，则打开时清除原来的内容。 |
| `ios::app`                        | `ofstream ` `fstream`             | 打开文件，用于在其尾部添加数据。如果文件不存在，则新建该文件。 |
| `ios::ate`                        | `ifstream`                        | 打开一个已有的文件，并将文件读指针指向文件末尾（读写指 的概念后面解释）。如果文件不存在，则打开出错。 |
| `ios:: trunc`                     | `ofstream`                        | 打开文件时会清空内部存储的所有数据，单独使用时与 `ios::out `相同。 |
| `ios::binary`                     | `ifstream ` `ofstream ` `fstream` | 以二进制方式打开文件。若不指定此模式，则以文本模式打开。     |
| `ios::in | ios::out`              | `fstream`                         | 打开已存在的文件，既可读取其内容，也可向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。 |
| `ios::in | ios::out`              | `ofstream`                        | 打开已存在的文件，可以向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错。 |
| `ios::in | ios::out | ios::trunc` | `fstream`                         | 打开文件，既可读取其内容，也可向其写入数据。如果文件本来就存在，则打开时清除原来的内容；如果文件不存在，则新建该文件。 |

`ios::binary `可以和其他模式标记组合使用，例如：

- `ios::in | ios::binary`表示用二进制模式，以读取的方式打开文件。
- `ios::out | ios::binary`表示用二进制模式，以写入的方式打开文件。


一般来说，如果处理的是文本文件，那么用文本方式打开会方便一些。但其实任何文件都可以以二进制方式打开来读写。在流对象上执行` open` 成员函数，给出文件名和打开模式，就可以打开文件。判断文件打开是否成功，可以看“对象名”这个表达式的值是否为` true`，如果为 `true`，则表示文件打开成功。

下面的程序演示了如何打开文件：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
int main()
{  
    ifstream inFile;   
    inFile.open("c:\\tmp\\test.txt", ios::in);  
    if (inFile)  //条件成立，则说明文件打开成功   
        inFile.close(); 
    else    
        cout << "test.txt doesn't exist" << endl;   
    ofstream oFile; 
    oFile.open("test1.txt", ios::out);  
    if (!oFile)  //条件成立，则说明文件打开出错   
        cout << "error 1" << endl;   
    else       
        oFile.close(); 
    oFile.open("tmp\\test2.txt", ios::out | ios::in); 
    if (oFile)  //条件成立，则说明文件打开成功  
        oFile.close();   
    else      
        cout << "error 2" << endl;   
    fstream ioFile;  
    ioFile.open("..\\test3.txt", ios::out | ios::in | ios::trunc);  
    if (!ioFile)    
        cout << "error 3" << endl;  
    else    
        ioFile.close();
    return 0;
}
```

调用` open` 成员函数时，给出的文件名可以是全路径的，如第 7 行的`c:\\tmp\\test.txt`， 指明文件在 c 盘的` tmp `文件夹中；也可以只给出文件名，如第 13 行的`test1.txt`，这种情况下程序会在当前文件夹（也就是可执行程序所在的文件夹）中寻找要打开的文件。

第 18 行的`tmp\\test2.txt`给出的是相对路径，说明` test2.txt` 位于当前文件夹的 `tmp `子文件夹中。第 24 行的`..\\test3.txt`也是相对路径，代表上一层文件夹，此时要到当前文件夹的上一层文件夹中查找 `test3.txt`。此外，`..\\..\\test4.txt`、`..\\tmp\\test4.txt`等都是合法的带相对路径的文件名。

### 使用流类的构造函数打开文件

定义流对象时，在构造函数中给出文件名和打开模式也可以打开文件。以 `ifstream `类为例，它有如下构造函数：

```cpp
ifstream::ifstream (const char* szFileName, int mode = ios::in, int);
```

第一个参数是指向文件名的指针；第二个参数是打开文件的模式标记，默认值为`ios::in`; 第三个参数是整型的，也有默认值，一般极少使用。

在定义流对象时打开文件的示例程序如下（用流类的构造函数打开文件）：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
int main()
{   
    ifstream inFile("c:\\tmp\\test.txt", ios::in);  
    if (inFile)    
        inFile.close();  
    else     
        cout << "test.txt doesn't exist" << endl; 
    ofstream oFile("test1.txt", ios::out);  
    if (!oFile)    
        cout << "error 1"; 
    else     
        oFile.close(); 
    fstream oFile2("tmp\\test2.txt", ios::out | ios::in);   
    if (!oFile2)     
        cout << "error 2";   
    else    
        oFile.close();  
    return 0;
}
```

## `close()`

我们知道，调用 `open()` 方法打开文件，是文件流对象和文件之间建立关联的过程。那么，调用 `close() `方法关闭已打开的文件，就可以理解为是切断文件流对象和文件之间的关联。注意，`close() `方法的功能仅是切断文件流与文件之间的关联，该文件流并会被销毁，其后续还可用于关联其它的文件。

`close() `方法的用法很简单，其语法格式如下：

```cpp
void close()
```

可以看到，该方法既不需要传递任何参数，也没有返回值。

举个例子：

```cpp
#include <fstream>
using namespace std;
int main()
{    
    const char *url="hi";  
    ofstream outFile("url.txt", ios::out);   
    //向 url.txt 文件中写入字符串    
    outFile.write(url, 30);   
    //关闭已打开的文件  
    outFile.close();   
    return 0;
}
```

运行程序，在该程序同目录下会生成一个 url.txt 文件，其内部存储的数据为：

```
hi
```

有些读者可能发现，即便上面程序中不调用 `close() `方法，也能成功向 `url.txt `文件中写入` url `字符串。这是因为，当文件流对象的生命周期结束时，会自行调用其析构函数，该函数内部在销毁对象之前，会先调用 `close()` 方法切断它与任何文件的关联，最后才销毁它。

> 强烈建议读者，使用` open() `方法打开的文件，一定要手动调用 `close() `方法关闭，这样可以避免程序发生一些奇葩的错误！

值得一提的是，4 种流状态也同样适用于文件流。当文件流对象未关联任何文件时，调用` close() `方法会失败，其会为文件流设置 `failbit` 状态标志，该标志可以被` fail() `成员方法捕获。例如：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
int main()
{ 
    const char *url="hi";  
    ofstream outFile; 
    outFile.close();   
    if (outFile.fail())
    {      
        cout << "文件操作过程发生了错误！"; 
    }  
    return 0;
}
```

程序执行结果为：

```
文件操作过程发生了错误！
```

## 文件读写

在讲解具体读写文件的方法之前，读者首先要搞清楚的是，对文件的读/写操作又可以细分为 2 类，分别是以文本形式读写文件和以二进制形式读写文件。

- 我们知道，文件中存储的数据并没有类型上的分别，统统都是字符。所谓以文本形式读/写文件，就是直白地将文件中存储的字符（或字符串）读取出来，以及将目标字符（或字符串）存储在文件中。

- 而以二进制形式读/写文件，操作的对象不再是打开文件就能看到的字符，而是文件底层存储的二进制数据。更详细地讲，当以该形式读取文件时，读取的是该文件底层存储的二进制数据；同样，当将某数据以二进制形式写入到文件中时，写入的也是其对应的二进制数据。

举个例子，假设我们以文本形式将浮点数 19.625 写入文件，则该文件会直接将 "19.625" 这个字符串存储起来。当我们双击打开此文件，也可以看到 19.625。值得一提的是，由非字符串数据（比如这里的浮点数 19.625）转换为对应字符串（转化为 "19.625"）的过程，C++ 标准库已经实现好了，不需要我们操心。

但如果以二进制形式将浮点数 19.625 写入文件，则该文件存储的不再是 "19.625" 这个字符串，而是 19.625 浮点数对应的二进制数据。以 `float` 类型的 19.625 来说，文件最终存储的数据如下所示：

`0100 0001 1001 1101 0000 0000 0000 0000`

显然，如果直接将以上二进制数据转换为 `float `类型，仍可以得到浮点数 19.625。但对于文件来说，它只会将存储的二进制数据根据既定的编码格式（如 `utf-8`、`gbk `等）转换为一个个字符。这也就意味着，如果我们直接打开此文件，看到的并不会是 19.625，往往是一堆乱码。

C++ 标准库中，提供了 2 套读写文件的方法组合，分别是：

1. 使用 `>>` 和 `<< `读写文件：适用于以文本形式读写文件；
2. 使用 `read() `和 `write() `成员方法读写文件：适用于以二进制形式读写文件。

### `>>`和`<<`读写文本文件

`fstream `或者 `ifstream` 类负责实现对文件的读取，它们内部都对 `>>` 输出流运算符做了重载；同样，`fstream `和 `ofstream` 类负责实现对文件的写入，它们的内部也都对 `<<` 输出流运算符做了重载。

所以，当` fstream `或者` ifstream `类对象打开文件（通常以` ios::in `作为打开模式）之后，就可以直接借助 `>> `输入流运算符，读取文件中存储的字符（或字符串）；当 `fstream `或者` ofstream` 类对象打开文件（通常以 `ios::out`作为打开模式）后，可以直接借助 `<<` 输出流运算符向文件中写入字符（或字符串）。

举个例子：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
int main()
{   
    int x,sum=0;   
    ifstream srcFile("in.txt", ios::in); //以文本模式打开in.txt备读  
    if (!srcFile) 
    { 
        //打开失败   
        cout << "error opening source file." << endl;   
        return 0;  
    }  
    ofstream destFile("out.txt", ios::out); //以文本模式打开out.txt备写  
    if (!destFile) 
    {     
        srcFile.close(); //程序结束前不能忘记关闭以前打开过的文件     
        cout << "error opening destination file." << endl;   
        return 0;   
    }   
    //可以像用cin那样用ifstream对象  
    while (srcFile >> x)
    {      
        sum += x;     
        //可以像 cout 那样使用 ofstream 对象   
        destFile << x << " ";   
    }   
    cout << "sum：" << sum << endl;  
    destFile.close();   
    srcFile.close();   
    return 0;
}
```

> 注意，此程序中分别采用 `ios::in` 和 `ios::out `打开文件，即以文本模式而非二进制模式打开文件。感兴趣的读者可在其基础上添加` ios::binary`，即以二进制模式打开文件，程序依旧会正常执行。这是因为，以文本模式打开文件和以二进制模式打开文件，并没有很大的区别（后续章节会做详细讲解）。

执行此程序之前，必须在和该程序源文件同目录中手动创建一个` in.txt` 文件，假设其内部存储的字符串为：

```
10 20 30 40 50
```

建立之后，执行程序，其执行结果为：

```
sum：150
```

同时在 `in.txt `文件同目录下，会生成一个` out.txt `文件，其内部存储的字符和` in.txt `文件完全一样，读者可自行打开文件查看。通过分析程序的执行结果不难理解，对于` in.txt `文件中的 `10 20 30 40 50` 字符串，`srcFile` 对象会依次将 `10`、`20`、`30`、`40`、`50` 读取出来，将它们解析成 int 类型的整数 10、20、30、40、50 并赋值给` x`，同时完成和 `sum` 的加和操作。同样，对于每次从 `in.txt `文件读取并解析出的整形 `x`，`destFile `对象都会原封不动地将其再解析成对应的字符串（如整数 10 解析成字符串 `10`），然后和 ` ` 空格符一起写入 `out.txt` 文件。

### `read()`和`write()`读写二进制文件

现在要做一个学籍管理程序，其中一个重要的工作就是记录学生的学号、姓名、年龄等信息。这意味着，我们需要用一个类来表示学生，如下所示：

```cpp
class CStudent
{
    char szName[20];  //假设学生姓名不超过19个字符，以 '\0' 结尾
    char szId[l0];  //假设学号为9位，以 '\0' 结尾
    int age;  //年龄
};
```

前面章节中，我们学会了如何以文本形式读写文件，如果使用此方式存储学生的信息，则最终的文件中存储的学生信息可能是这个样子：

```
Micheal Jackson 110923412 17
Tom Hanks 110923413 18
......
```

要知道，这种存储学生信息的方式不但浪费空间，而且后期不利于查找指定学生的信息（查找效率低下），因为每个学生的信息所占用的字节数不同。

这种情况下，以二进制形式将学生信息存储到文件中，是非常不错的选择，因为以此形式存储学生信息，可以直接把 `CStudent `对象写入文件中，这意味着每个学生的信息都只占用` sizeof(CStudent) `个字节。

值得一提的是，要实现以二进制形式读写文件，`<< `和 `>> `将不再适用，需要使用 C++ 标准库专门提供的` read() `和 `write() `成员方法。其中，`read() `方法用于以二进制形式从文件中读取数据；`write() `方法用于以二进制形式将数据写入文件。

#### `ostream::write()`方法写文件

`ofstream` 和` fstream` 的` write() `成员方法实际上继承自` ostream` 类，其功能是将内存中` buffer` 指向的 `count `个字节的内容写入文件，基本格式如下：

```cpp
ostream & write(char* buffer, int count);
```

其中，`buffer `用于指定要写入文件的二进制数据的起始位置；`count `用于指定写入字节的个数。

> 也就是说，该方法可以被` ostream `类的 `cout `对象调用，常用于向屏幕上输出字符串。同时，它还可以被 `ofstream` 或者` fstream `对象调用，用于将指定个数的二进制数据写入文件。

同时，该方法会返回一个作用于该函数的引用形式的对象。举个例子，`obj.write() `方法的返回值就是对 `obj `对象的引用。

需要注意的一点是，`write() `成员方法向文件中写入若干字节，可是调用` write() `函数时并没有指定这些字节写入文件中的具体位置。事实上，`write() `方法会从文件写指针指向的位置将二进制数据写入。所谓文件写指针，是是` ofstream `或 `fstream` 对象内部维护的一个变量，文件刚打开时，文件写指针指向的是文件的开头（如果以` ios::app `方式打开，则指向文件末尾），用 `write() `方法写入` n `个字节，写指针指向的位置就向后移动` n `个字节。

下面的程序演示了如何将学生信息以二进制形式写入文件：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
class CStudent
{
public:
    char szName[20];
    int age;
};
int main()
{
    CStudent s;
    ofstream outFile("students.dat", ios::out | ios::binary);
    while (cin >> s.szName >> s.age)
        outFile.write((char*)&s, sizeof(s));
    outFile.close();
    return 0;
}
```

输入：

```
Tom 60
Jack 80
Jane 40
^Z
```

执行程序后，会自动生成一个` students.dat `文件，其内部存有 72 字节的数据，如果用“记事本”打开此文件，可能看到如下乱码：

```
Tom 烫烫烫烫烫烫烫烫<  Jack 烫烫烫烫烫烫烫蘌  Jane 烫烫烫烫烫烫烫?
```

值得一提的是，程序中第 13 行指定文件的打开模式为 `ios::out | ios::binary`，即以二进制写模式打开。在 Windows平台中，以二进制模式打开文件是非常有必要的，否则可能出错。

另外，第 15 行将 `s` 对象写入文件。`s `的地址就是要写入文件的内存缓冲区的地址，但是` &s `不是 `char * `类型，因此要进行强制类型转换；第 16 行，文件使用完毕一定要关闭，否则程序结束后文件的内容可能不完整。

#### `istream::read()`方法读文件

`ifstream `和 `fstream` 的` read() `方法实际上继承自 `istream `类，其功能正好和` write() `方法相反，即从文件中读取` count `个字节的数据。该方法的语法格式如下：

```cpp
istream & read(char* buffer, int count);
```

其中，`buffer `用于指定读取字节的起始位置，`count` 指定读取字节的个数。同样，该方法也会返回一个调用该方法的对象的引用。

和` write() `方法类似，`read() `方法从文件读指针指向的位置开始读取若干字节。所谓文件读指针，可以理解为是` ifstream `或` fstream `对象内部维护的一个变量。文件刚打开时，文件读指针指向文件的开头（如果以 `ios::app `方式打开，则指向文件末尾），用` read() `方法读取` n `个字节，读指针指向的位置就向后移动` n `个字节。因此，打开一个文件后连续调用` read() `方法，就能将整个文件的内容读取出来。

通过执行` write()` 方法的示例程序，我们将 3 个学生的信息存储到了 `students.dat `文件中，下面程序演示了如何使用` read() `方法将它们读取出来：

```cpp
#include <iostream>
#include <fstream>
using namespace std;
class CStudent
{
public:
    char szName[20];
    int age;
};
int main()
{
    CStudent s;       
    ifstream inFile("students.dat",ios::in|ios::binary); //二进制读方式打开
    if(!inFile) {
        cout << "error" <<endl;
        return 0;
    }
    while(inFile.read((char *)&s, sizeof(s))) { //一直读到文件结束
        cout << s.szName << " " << s.age << endl;   
    }
    inFile.close();
    return 0;
}
```

程序的输出结果是：

```
Tom 60
Jack 80
Jane 40
```

注意，程序中第 18 行直接将` read() `方法作为` while `循环的判断条件，这意味着，`read() `方法会一直读取到文件的末尾，将所有字节全部读取完毕，`while `循环才会终止。

> 另外，在使用 `read() `方法的同时，如果想知道一共成功读取了多少个字节（读到文件尾时，未必能读取 `count `个字节），可以在` read() `方法执行后立即调用文件流对象的 `gcount() `成员方法，其返回值就是最近一次`read() `方法成功读取的字节数。感兴趣的读者可自行尝试，这里不再做具体演示。

## 文件读写指针

在读写文件时，有时希望直接跳到文件中的某处开始读写，这就需要先将文件的读写指针指向该处，然后再进行读写。

- `ifstream` 类和` fstream` 类有` seekg `成员函数，可以设置文件读指针的位置；
- `ofstream` 类和 `fstream `类有` seekp `成员函数，可以设置文件写指针的位置。

所谓“位置”，就是指距离文件开头有多少个字节。文件开头的位置是 0。

这两个函数的原型如下：

```cpp
ostream & seekp (int offset, int mode);
istream & seekg (int offset, int mode);
```

`mode` 代表文件读写指针的设置模式，有以下三种选项：

- `ios::beg`：让文件读指针（或写指针）指向从文件开始向后的 `offset` 字节处。`offset` 等于 0 即代表文件开头。在此情况下，`offset `只能是非负数。
- i`os::cur`：在此情况下，`offset `为负数则表示将读指针（或写指针）从当前位置朝文件开头方向移动 `offset` 字节，为正数则表示将读指针（或写指针）从当前位置朝文件尾部移动 `offset`字节，为 0 则不移动。
- `ios::end`：让文件读指针（或写指针）指向从文件结尾往前的 |`offset`|（`offset` 的绝对值）字节处。在此情况下，`offset` 只能是 0 或者负数。

此外，我们还可以得到当前读写指针的具体位置：

- `ifstream `类和` fstream `类还有` tellg` 成员函数，能够返回文件读指针的位置；
- `ofstream `类和` fstream `类还有 `tellp `成员函数，能够返回文件写指针的位置。

这两个成员函数的原型如下：

```cpp
int tellg();
int tellp();
```

要获取文件长度，可以用 `seekg` 函数将文件读指针定位到文件尾部，再用 `tellg` 函数获取文件读指针的位置，此位置即为文件长度。

