---
layout: post
title:  "LaTeX <img src='https://img.shields.io/badge/-原创-019733?style=flat'>"
date:   2020-09-05 00:00:00 +0800
categories: toturial
tags: LaTeX
comments: 1
mathjax: true
---

本文主要介绍了$\LaTeX$的相关语法及命令，以及$\LaTeX$公式的写法。

<!-- more -->

**目录**

[TOC]

![](https://img.shields.io/badge/original-Chenyang-blue) ![](https://img.shields.io/badge/reproduced-CSDN-blue) ![](https://img.shields.io/badge/reproduced-Wikipedia-blue) ![](https://img.shields.io/badge/license-GPL 3.0-orange)![](https://img.shields.io/badge/article quality-A-green)

# $\LaTeX$的安装与使用

## $\LaTeX$ 何物

简而言之，他就是码农的 $Word$。

- 是一种富文本格式，最终输出成凡人可读的格式（大多数情况下是 $PDF$）
- 本质是一门宏语言，可以调用各种宏包来扩展语法
- 并不是常用的所见即所得的排版程序，需要编译才能输出（通常需要数十秒）
- 通过各个宏包的扩展，他能实现比 $Word$ 更丰富的排版格式
- 对细节有非常细致的微调，每个单词间距，行间距，分词都极为考究，而且全部是自动的
- 强大的学术写作支持，包括公式编辑，内文引用，文献引用，图片插入等，非常便于维护
- 兼容性好，每个平台下对于同一源文件编译效果几乎完全一致
- 由于是纯文本，可以轻松地使用各种版本控制工具进行管理
- 良好的复用性，你可以把常用的内容做成模板进行复用，不会有各种隐藏符号干扰
- 对输出格式的完全控制，他给你提供了相当大的折腾的空间，不会有 $Word$ 经常失控的感觉
- 因为是纯文本，所以源文件超小，配合矢量图可以进一步压缩空间占用

在模板的基础上，就算是小白也可以排出非常规整的效果，以至于熟练使用 $\LaTeX$ 的用户几乎一眼就可以区分出 $\LaTeX$ 和 $Word$ 的输出文件。我随便贴一张我最近的实验报告好了：

![preview](https://www.towdium.me/img/posts/2017/latex-for-beginners-1_3.png)

这只是我随便找的一个报告，并不能完全体现出 $\LaTeX$ 的实际能力。既然是代码，我就再随便帖一段源码好了：

```latex
\def\studentgroup{47} 
\def\studentid{201219267} 
\def\moduleid{ELEC273} 
\def\reporttitle{Lab 5 Report} 
\def\theabstract{ 
The aim of the experiment is to design and simulate an amplifier with ... 
} 

% INFORMATION END 
\input{res/header} 
\usepackage[hidelinks]{hyperref} 
\usepackage{silence} 
\WarningFilter{latex}{Text page} 
\begin{document} 
\input{res/titlepage} 

% CONTENT 
\section{Introduction} 
In analogue circuits, amplifiers are essential parts for signal manipulation. ... 
```

当然这代码也是我随手找的，并不具有参考价值。其实我的码字习惯相当不好，所以就纯当是看了意思意思就行。

## $\LaTeX$ 发行版的安装

在我们开始写作之前，先要装一个编译环境，有点类似于 jre 之于 Java。这里我给出的是 `Tex Live` 的安装方法，这也是目前社区较为推崇的版本，其他版本还请自行解决。

如果你是 Windows 或者 Mac 用户的话，去 [这里](https://www.tug.org/texlive/) 能找到下载。Windows 下如果我没有记错的话，是一个安装器，他会从网上下载需要的模块并安装。这一过程耗时取决于你的网速，必要时请考虑科学上网。下载内容大于等于 1G。安装好之后，如果他没有帮你添加环境变量，我建议你手动添加，我的路径是 `C:/texlive/2016/bin/win32`，对于不同的人应该大同小异。

如果你是 Linux 用户的话，我觉得应该不必我多说啥了，不过我还是稍微说一点吧。如果你是 Ubuntu 用户，可以在 ppa 或者 apt 上找到，但是 Ubuntu 的包都偏老，容易出各种事情，而且质量参差不齐（所以我建议你用 Arch 系）。如果你是 Arch 系用户，官方源里可以直接搜索到，直接全选安装即可。你可以不用装那个额外的字体包，我目前还没有用到过。

## Atom 环境配置

安装好环境之后我们还需要一个顺手的编辑器，类似于编程的 IDE，这里我们使用 Atom，通过安装一堆插件实现各种辅助功能。

首先安装这个插件 `latex`，效果拔群。他提供了自动化编译 $\LaTeX$ 的各种操作，能给你提供相当多的便利。此外还有 `pdf-view`，这个$PDF$阅读器可以和 $\LaTeX$ 良好互动，编译之后自动刷新，非常方便。 `language-tex` 或者 `language-latex` 提供了语法高亮。值得注意的一点是 Atom 本身有个 bug （不知到现在有没有修好），就是当你的文本很长的时候，他后边的一大段就没法高亮了，当然如果你习惯够好的话，基本不会遇到这个问题。

安装好插件之后，到 `latex` 的设置里边把 `engine` 设置成 `xelatex`。这也就是之前说的 XeTeX 实现，这一实现提供了良好的 unicode 兼容，当然如果你不用中文的话，用默认引擎也完全没有问题。`Output Directory` 项你可以自定义输出文件的地址。$\LaTeX$ 编译会输出一大堆文件（99% 的情况只有 pdf 对我们是有用的），所以我建议你设一个文件夹来存放输出文件，这样起码可以让你的工作路径保持干净，我这里填的是 `out`，当然你也可以按需自定。

Atom 内建了拼写检查，但是说实在话，能用，但是有点智障。他会把 $\LaTeX$ 的各种命令都识别成拼写错误，而且不能在字典中添加新的项目。当然，如果你不在意的话，你可以对 $\LaTeX$ 源文件开启拼写检测。你只需要在 `spell-check` 这个包的 `Grammars` 列表里添加 `text.tex.latex`。如果你用的是中文的 Linux 系统，你可能需要在 `Locales` 框里填写 `en-US`，配置我给在下图中：

![spell-ckeck](https://www.towdium.me/img/posts/2017/latex-for-beginners-1_2.png)

## $\LaTeX$ 在线编辑

长期使用的话我自然是建议你用本地环境的，当然如果你只是想试试，用在线环境也无妨（有时可能更简单）。这里我个人推荐 [Overleaf](https://www.overleaf.com/)，你可以在线编辑，并且在线编译。对于用用玩的人来说，确实是一个极好的渠道。同时它还提供富文本编辑模式，我个人是觉得相当新奇。同时他还是一个很好的模板下载网站，我们后面还会说到。不过你如果要长期用的话，本地环境应该更适合你，毕竟要管理那么多图片，引用和其他文件，全部在线我是有点不放心的。他的界面大概是这样（请无视右侧生物）：

![Overleaf](https://www.towdium.me/img/posts/2017/latex-for-beginners-1_1.png)

# $\LaTeX$基础

## 你的第一个 $\LaTeX$ 文档

这里我们要做的事情很简单：新建一个文件夹，新建一个后缀为 `.tex` 的空文本文件，然后填入下面的代码：

```latex
\documentclass{article} 
\begin{document} 
Hello \LaTeX
\end{document} 
```

然后，执行这个命令 `Latex: Build`（hint: `ctrl+alt+P`），如果一切正常，你就可以在上一篇中你配置的位置找到输出文件了。在我的环境中，编译效果如下图：

![Build result 1](https://www.towdium.me/img/posts/2017/latex-for-beginners-2_1.png)

在 `out` 文件夹中（上一篇中我自定的位置），就可以找到我们要的 pdf 文件了。如果你已经安装了 `pdf-view` 插件，就可以直接打开了。之后的每次编译，内容也会相应的更新。

### 重要语法

说完操作步骤，我们稍微说说原理。你可以看到这一段文本有很多转义符（反斜杠）。在 $\LaTeX$ 中，这用来表示一个命令。配合编辑器的高亮，你可以轻松地分辨出各个部分。对于普通的指令，一般是这样的格式 `\command[arg1]{arg2}{arg3}` 前面的一部分是指令名，方括号中是可选参数，花括号中是必选参数。对于最基础的命令来说，至多有一个可选参数，任意个必选参数。当然，对于一些简单的命令，没有参数也是完全可以的。比如这里的 `\LaTeX`，就只是表示了一段特殊文本。在我们深入学习之后，完全是可以自定义命令的，就像各种编程语言中自定义函数一样。

另外一个非常重要的概念是这里的环境，也就是 `\begin{document}` 和 `\end{document}`。环境的范围由 `\begin{env}` 和 `\end{env}` 来确定。在这一范围中的文本会有特殊的效果。这里的环境 `document` 表示着文本的内容范围，在此之外是不允许出现文章内容的，你可以用那些位置来定义各种格式，或者配置各种宏包。除此之外，还有巨量的环境可以使用，比如文本对齐的 `align`， 插入公式的 `equation`，插入源代码的 `lstlisting`。他们可能会重新定义环境内文本的显示方式，充满着玄学，但是很好用。

### 内容解释

这里的 `\documentclass{article}` 是每个 $\LaTeX$ 文本必备的部分。这里相当于你告诉编译器这个文本是一个文档，那么编译器就会用文档的格式来编译。除此之外，常用的还有 `\documentclass{book}` 这就意味着这是一本书籍的排版。在这种情况下，编译器可能会考虑更大的标题，更多分页。具体效果取决于 $\LaTeX$ 内嵌的排版格式。当然格式都是可以魔改的，不过这就略玄学了，我们先不说。`document` 环境里我们就打了一行字，正如你在 pdf 文件中看到的那样。

## 你的第二个 $\LaTeX$ 文档

大概知道他的原理之后，我们不如激进一点，下面是整个文档的源码，你可以着手准备编译了。

```latex
\documentclass[11pt]{ctexart} 

%导入宏包 
\usepackage{esint,bm}       %提供环路重积分符号和数学粗体
\usepackage{indentfirst}    %修改首行缩进的行为 
\usepackage{fullpage}       %两边边距填充 
\usepackage{graphicx}       %插图 
\usepackage{listings}       %插代码

%配置宏包 
\renewcommand{\lstlistingname}{代码}       %重定义代码命名 

%文档信息 
\title{一篇 \$\LaTeX${} 入门介绍} 
\author{chenyang} 
\begin{document} 

% 绘制标题 
\maketitle 

% 正文内容 

\section{数学公式} 
这是一段示例公式，最简单的方式是使用两个美元符号，像这样：
$$\oiint \bm{E}\cdot d\bm{s}=\frac{Q}{\epsilon_0}$$ 
对于内文公式，还可以这样写：$E=mc^2$。 
当然，你也可以用更复杂的方法，如公式\ref{eq}。
好处在于这种用法可以对公式添加序号，以便进行内文引用。 \begin{equation}  
	\mathcal{L}_t{f}=\int^\infty _0 e^{-st}f(t)dt  \label{eq} 
\end{equation} 

\section{图片插入} 
通过 \verb+graphicx+ 这个包，我们可以非常轻松的插入图片。 图\ref{fig}是一张示例图片，同样使用了内文引用。当然插图的方法还有很多， 来实现不同的效果，我们这里只讲基础。这里的图片是浮动的，在没有位置的时候， 他可能会浮动到其他页面上，这样可以防止文档里出现大量的空白。
\begin{figure}[!ht] 
	\centering 
    \includegraphics[width=0.4\textwidth]{pic}  
    \caption{一个示例图片}  
    \label{fig} 
\end{figure} 

\section{代码插入} 
这里提供了一个最小化的代码插入方式。效果给出在代码\ref{code}中。 包 \verb+listings+ 提供了无比强大的代码高亮支持， 只不过我这里没有进行相关的设置，所以内容均是黑白的。 有机会的话我会在后文中提供一些思路。 
\begin{lstlisting}[language=python, frame=single, caption=一段示例代码, label=code, captionpos=b, basicstyle=\footnotesize]
usage = "Run the script: ./geolocate.py IPAddress" 
if len(sys.argv)!=2:    
	print(usage)   
    sys.exit(0) 
\end{lstlisting} 

\section{表格插入} 
老实说表格在 \LaTeX{} 中的使用比较反人类，尤其当你想要合并单元格的时候。 不过这也是没有办法，任何一个富文本语言对表格这种东西基本上都相性不合。 表格\ref{tab}提供了一个较为简陋的表格实现。 
\begin{table}[!h] 
	\centering  
	\begin{tabular}{ c | c | c }  
    	\hline   
        cell1 & cell2 & cell3 \\ \hline   
        cell4 & cell5 & cell6 \\ \hline   
        cell7 & cell8 & cell9 \\  \hline  
    \end{tabular}
    \caption{一个示例表格} 
    \label{tab}
\end{table} 

\section{枚举} 
枚举什么的其实也很简单，大概像这样： 
\begin{enumerate} 
	\itemsep-0.5em %缩小间距 
    \item 第一条  
    \item 第二条
\end{enumerate} 
在枚举环境中，他也会完全帮你搞定编号排序的问题。
当然，你也可以使用没有编号的版本：
\begin{itemize}  
	\itemsep-0.5em %缩小间距 
    \item 第一条 
    \item 第二条
    \end{itemize}
\end{document} 
```

### 排错

当然这个文档在你的电脑上很可能不能成功编译。有下边几个原因：

- 你没有使用 XeLaTeX 引擎：看前一章我们说的引擎配置。
- 你没有图片 `pic.pdf`：我已经上传到了 [Github 仓库](https://github.com/chenyang/towdium.github.io/blob/master/share/latex-for-beginners_pic.pdf) ，下载并放置到源文件的同一文件夹，并命名为 `pic.pdf` 即可。当然你如果想用自己的图片也没有问题，`\includegraphics[width=0.4\textwidth]{pic}`中的 `pic` 就是插入图片的路径。我个人建议 pdf 图片，他长期以来发挥稳定，其它格式有时则会翻车。你可能还要尝试带后缀名和不带后缀名的写法。

对于新手而言，阅读 $\LaTeX$ 的错误日志是相当痛苦的事情。我刚开始学的时候，基本上每次编译都是几十个警告，只能硬着头皮写，当你逐渐熟悉之后，你才能明白这些警告在说什么。当然最好的方法是找一些模板或者非常短的文章来编译，从一开始就不要允许大规模警告的出现。

### 简要讲解

如果你能成功编译的话，我觉得我也没必要说太多了，各个排版结构的效果和源码你都能看到，重要的命令我也给出了注释。而某一些命令的作用，你完全可以删除特定代码来观察结果的变化。

关于内文应用，他的逻辑是在某一个部件的内部定义 `\label{foo}`, 然后在文档的任何地方引用只需要 `\ref{foo}` 即可。因为 $\LaTeX$ 会编译多次，所以即使先引用后定义也是完全没有问题的。

关于中文的显示，这里我用的是 CTeX 宏包进行的配置。不得不说确实非常好用，配置简单，发挥稳定。你只需要在第一行使用 `ctexart` 即可。

关于段落和分词，$\LaTeX$ 以两个换行作为段落分割，一个换行没有任何作用，只是方便代码排版。如果要强制换行，可以使用 `\\`。类似地，$\LaTeX$ 也会自行处理单词间的间距。无论使用多少个空格，$\LaTeX$ 只会把它当作单词分割，输出的结果都是一样的。

如果你之前习惯使用 markdown 的话，可能会难以接受 $\LaTeX$ 代码的复杂度。本质上来说，markdown 代码只含有文本内容，而没有特定格式，但是 $\LaTeX$ 是完全不同的，他的强大之处在于你可以自定义任何的一个格式，对于一些常用的代码块，你完全可以自定义成函数，这样就可以大大减小冗余文本的数量。现在你大概可以知道，$\LaTeX$ 和 markdown 完全不是一个数量级的产品。

当然每个命令可以配置的选项都是异常复杂，我这里只是给出最简便的方法。如果想要最完整的介绍，你可以找到各个宏包的官方文档，基本上都是几十页起步。对于中文文本格式和插入图片的细节，我在 [这篇文章](https://towdium.github.io/2016/08/16/about-layout-in-latex/) 里做过一些介绍。当然 $\LaTeX$ 可以挖掘的内容几乎是无限的，我所介绍的内容仅仅是我日常用到的范畴。如果对任何一个细节有更高的要求，你都可以在搜索引擎上找到更具体的介绍，我这里只提供方法，不提供细节。

考虑到有些人可能还是难以编译，或者懒得编译，这里我给出我的编译结果，图看不清的话可以右键查看原图：

![Build result 2](https://www.towdium.me/img/posts/2017/latex-for-beginners-2_2.png)

如果你有任何编译的困难，也欢迎在评论区（需要科学上网才能显示）发给我。

## 模板

在用了这么久 $\LaTeX$ 之后，老实说我没有一次是从零开始码起的，绝大部分情况下，都是基于模板进行工作。我们上次说到的 [overleaf](https://www.overleaf.com/) 就是一个很好的模板下载网站，你可以搞到成吨的模板。如果是作业的话，学校一般会提供 $\LaTeX$ 模板来统一画风，所以直接那它来改就好。这里再贴一个我自改自用的模板，他其实已经深度魔改了，带有一百多行的导言，包括各种函数定义以及大量高亮语法的定义，另外还有一个自改的 IEEE 引用格式，至于引用的部分，我们会在下次说到。这个模板我也发到 [Github 仓库](https://github.com/chenyang/towdium.github.io/blob/master/share/latex-for-beginners_template.zip) 了，有需要的可以自行下载使用。

# $\LaTeX$引用

## 何为引用

说真的如果你还不清楚引用是啥，你可能不需要看这一章。不过你既然来了，我们就稍微说一说。粗略地说，当你在论文里引用了其他人说的话，你不能像我写博客这么随意，直接丢个超链接，取而代之的是，你需要在论文结尾提供这个来源的详细信息，诸如作者，年份，文章标题，或者是期刊刊号，图书页码。你需要在文章末尾的参考文献目录中列举这些信息，以及在对应地在文本里添加注释。下图我给出了我某一篇论文的参考文献目录，当然内容不重要（不仅不正式，甚至还有错别字），大概就长这样。当然是用 $\LaTeX$ 直接生成的。

![Example bibliography](https://www.towdium.me/img/posts/2017/latex-for-beginners-3_1.png)

说到这里我不禁要婊一婊 word，你在 word 里很难把参考文献排的这么规整，特别是你有一些很鬼畜的超链接时。这个例子我们使用了 IEEE 格式，如你所见，一个典型的 IEEE 引用格式是：

> [序号] 名首字母.姓全拼, “文章名,” 年份. 其他信息.

参考文献还有各种不同的格式，这里给出的 IEEE 是理工科常用的，而人文学科多会使用 APA 或者 Harvard 格式。这些格式基本大同小异，按照作业要求选取就可以了。不同引用格式的区别你可以在 [这里](http://pitt.libguides.com/c.php?g=12108&p=64729) 找到。当然引用的具体格式你根本不用知道的那么清楚，$\LaTeX$ 会帮我们直接生成。不管你用什么格式，我们只需要给 $\LaTeX$ 提供必要的字段，他就可以帮我们生成需要的格式。

除去参考文献列表，文本内的引用格式也是各不相同的，你要做的同样是告诉 $\LaTeX$ 你需要的格式，他会搞定一切。

## 操作方法

### bib 文件

$\LaTeX$ 使用 BibTeX 文件来管理引用列表。要添加引用，最简单的方法是在 tex 文件的同一目录下新建一个文件，名为 `reference.bib`,内容大概像这样：

```bibtex
@misc{example,
  author = {chenyang},
  title = {An Example Article},
  year = 2020
}
```

抱歉我这里用的高亮插件 rouge 不支持 bib 语法，但是在 atom 里他是可以正常高亮的。

- 第一行的 misc 表示这是一条杂项引用，他表示了你这个引用是书籍，文章还是杂项。
- 括号的开始是一个标识符，用于引用内容的识别，相当于这个条目的名字。
- 后面是条目的各个字段。不同的引用类型对应不同的字段。杂项引用只需要这三条即可。
- 这里的逗号非常重要！逗号错误会导致神秘的编译失败。

同一个文件可以容纳同一片文章里所有的引用信息，只要列举在同一个文件里就可以。

### 正文引用

当你完成这一个条目之后，你要做的就是在正文里引用这个条目。正文内容可以是这样的：

```latex
\documentclass{article} 

\begin{document}

chenyang wrote a stupid article about \$\LaTeX${} \cite{example}. 
\bibliographystyle{IEEEtran}  % set style to IEEE 
\bibliography{reference.bib}  % set reference file name 

\end{document} 
```

将这两个文件放在同一文件夹进行编译，你得到的结果大概是这样：

![Example bibliography](https://www.towdium.me/img/posts/2017/latex-for-beginners-3_2.png)

值得注意的是正文中的 `\cite{}` 命令就是用来引用文献的，这里的参数就是我们之前提到的标识符。下边的 `\bibliography{}` 命令提供了源文件的文件名。执行引用时，他会到这个文件里寻找相关的条目，然后添加进来。

这里的 `IEEEtran` 是 $\LaTeX$ 自带的 IEEE 引用格式，不过如果你安装的是精简版的 TexLive 的话，也许会没有这个格式。在 archlinux 下边，你需要安装 `texlive-publishers` 这个包，其他系统还请自行解决。

## 操作细节

### 引用类型

BibTeX 提供了相当多的模板来帮助你填充引用信息。最简陋的有 misc （杂项），你可以用它来做网页的引用。除此之外，它还提供诸如学术文章，书籍，会议记录，手册等各种引用模板。不同的模板有会用到不同的字段，这些信息在 [Wiki 的 BibTeX 页面](https://zh.wikipedia.org/zh-cn/BibTeX) 上都有比较详细的解释。最简单的是杂项，没有必选字段，你给什么信息他就填充什么信息；而正式一点的 Article 之流，则必须提供作者，标题，期刊名，年份，可选的字段有：期数，文章编号，页码和额外注释。你可以在各种模板中选取你需要的来使用。文档编译后，各种模板的信息都会被转化对应的引用格式。

### 自动生成 bib 文件

严格来说这并不是 $\LaTeX$ 的技巧，只能算是写论文时候偷懒的办法。你完全没必要手动写 bib 文件，取而代之的是，大部分数据库都会提供引用导出的功能。

![ref export](https://www.towdium.me/img/posts/2017/latex-for-beginners-3_4.png)

这里拿 google scholar 作为例子。点击条目下的“引用”就会弹出图示界面；点击 bibtex，就可以直接导出成 bibtex。其他数据库，其他文献管理程序同样适用。大数据库导出的文件一般比较可靠，但是也有一些需要手动微调。

### URL

严谨地说 URL 跟引用并没有什么关系，我之所以在这里说，是因为相当一部分引用都会自带一个超长的超链接。如我之前所说，超链接这种东西你很难把它排的好看，因为大部分的排版工具都难以决定如何分割这么长的文本。$\LaTeX$ 的好处就在于它把超链接处理成另外一种文本，甚至用另外一个包来管理超链接相关的排版，这就给我们的暴力切割提供了机会。可喜可贺的是，url 包甚至可以自动解决排版问题。

你可以考虑编译以下的内容：

```latex
\documentclass{article}
\usepackage{lipsum} 
\usepackage[hyphens]{url}
\usepackage[hidelinks]{hyperref} 

\begin{document} 
\lipsum[1] 

Here is an example link: \url{http://assume-this-is-a-super-duper-long-url. let's-give-it-a-stupid-domain.com} Maybe you can find something there

\lipsum[2] 
\end{document} 
```

这里我用 lipsum 包只是为了展示普通段落的宽度。重点在第三行。当你选择了 `hyphens` 参数的时候，url 包就会接管换行的操作。第四行的 `hyperref` 包可以将 url 转换成超链接，完全是自动的。不过记得加上 `hidelinks` 不然会有略难看的彩色方框。效果如下：

![url demo](https://www.towdium.me/img/posts/2017/latex-for-beginners-3_3.png)

当你使用这一配置的时候，参考列表中的 url 也会遵循同一模式，效果大概就像我一开始给出的图那样。

### filecontent

和上一小节一样，filecontent 也是 $\LaTeX$ 的一个包，我们把它放在这里说只是因为在引用的范例中经常会看到他。filecontent 这个包用于编辑其他的文件，或者说，在一个文件中伪造出其他的文件。你可能要说了，这不就是脱裤子放屁么。在某些情况下，是的，但是在 bibtex 的使用上，他能提供一些便利。

我们之前说了 bibtex 需要存放在另一个 `.bib` 文件中。但是对于短文件或者示例而言，写在一个文件里可能更方便。这里 `filecontents` 环境就是用来定义另一个文件的内容。这里我们通过他建立了 `reference.bib` 这个文件。

```latex
\documentclass{article}
\usepackage{filecontents} 

\begin{filecontents}{reference.bib}
@misc{example,  
	author = {chenyang}, 
    title = {An Example Article}, 
    year = 2020 
} 
\end{filecontents}

\begin{document}
chenyang wrote a stupid article about \LaTeX{} \cite{example}. 
\bibliographystyle{IEEEtran}  % set style to IEEE 
\bibliography{reference.bib}  % set reference file name 
\end{document} 
```

直接编译以上的代码，可以获得和之前的示例完全一致的效果。这样就省去了我们操作文件的麻烦。

### biblatex

我们一直在讲的都是最最基础的 $\LaTeX$ 的引用方式。他的局限性还是相当大的。你可以人为操作的配置也比较有限。包 `biblatex` 提供了更为强大的自定义余地，同时也提供了更多的条目模板。下边是一个用 biblatex 进行引用管理的例子。

```latex
\documentclass{article} 

% sometimes it won't work without setting bibtex 
\usepackage[backend=bibtex, style=ieee]{biblatex}
\usepackage{filecontents} 

% allow stretch for better hbox filling, optional 
\emergencystretch=1em 

% declare reference data location, no suffix 
\bibliography{ref} 
% override default date style to [Accessed: MM/DD/YY] 
\DeclareFieldFormat{urldate}{\mkbibbrackets{Accessed: #1}} 

\begin{filecontents}{ref.bib}
@online{example,  
	author = {chenyang}, 
    title = {An Example Article}, 
    year = 2020, 
    url = {http://www.google.com/},  
    urldate = {2020-01-01} 
}
\end{filecontents}

\begin{document}
chenyang wrote a stupid article about \$\LaTeX${} \cite{example}. 
\printbibliography 
\end{document} 
```

下面是排版的效果：

![example biblatex](https://www.towdium.me/img/posts/2017/latex-for-beginners-3_5.png)

不得不承认使用 biblatex 应该算是更为“现代”的引用管理方式。不过就我目前的需要，使用原生的引用管理就可以满足我绝大部分的需要了。鉴于 biblatex 的资料还算比较多，使用也比较直观，我这里就只是抛砖引玉，不再细说了。

### 魔改 bst 文件

除去 biblatex 以外，我们自然可以用最基础的方法自定义引用格式。看过最初的例子之后，当你观察输出的结果 `"An example article," 2017`，肯定会有人对这个逗号的位置无比焦虑。又或者当你想要注明在线内容的访问时间，事情就会有些尴尬。如果是个人用的话，修改 bst 文件不失为一个高效的解决方法。当然这个方法比起 biblatex 来，就要难懂得多了，而且比较野蛮。

顾名思义，bst 就是 bib style，他决定了你的引用内容的排版样式。通过修改 bst 文件，我们就可以自定义排版的格式。对于前面两个问题，我拿 IEEE 格式举个例子。首先你要找到 IEEE 格式默认的 bst 文件。我这里的位置在 `/bibtex/bst/IEEEtran/IEEEtran.bst`。然后，复制一份到你的工作目录，按需要命名。最后，把 `\bibliographystyle{IEEEtran}` 改成 `\bibliographystyle{fileName}`。这样编译的时候就会使用你提供的格式文件进行排版了。通过魔改这个 bst 文件，我们就可以相应地修改引用格式。

- **逗号位置**：搜索字段 `output.nonnull`，把 `prev.status.quote quote.close` 对应的一段提到最前面即可。
- **访问时间**：搜索字段 `misc`，把 `format.note output` 放到 `format.url output` 的后边，然后在 bib 文件的对应条目添加 `note = {[Accessed: DD-MM-YYYY]},` 这一条目，就可以正确的排版了。

如你所见，bst 文件对于普通用户而言是相当难懂的，我这里只是提供一个案例，需要时可以作为参考。大部分时间你完全可以使用 biblatex 完成你的需要。

# $\LaTeX$命令

## 值与命令

### 调用格式

其实在不同的宏包中，作者可能会自己定义命令的调用方式（参见listings），不过这些就不是我们关心的内容了，我们这里只说最简单的情景。一个典型的 $\LaTeX$ 命令可以有一个可选参数，和 n（n>=0）个必选参数。调用一个命令的典型操作是这样的：

```latex
\afunction[optional]{compulsory1}{compulsory2} 
```

方括号指代可选参数，花括号指代必选参数。当然，方括号内既然是可选参数，你完全可以不提供，就像这样：

```latex
\afunction{compulsory1}{compulsory2} 
```

### 值定义

命令的使用自然是很简单的，定义就稍微复杂一些了。我们先说值的定义，用 `\newcommand` 这个命令就可以：

```latex
\documentclass{article} 
\newcommand{\name}{chenyang the Stupid}

\begin{document} 
This guy call himself \name .
\end{document} 
```

编译结果：

```
This guy call himself chenyang the Stupid. 
```

### 命令定义

命令定义就稍微复杂一点。我们这里现设定一个情景吧。我们平时插入独立的公式有两种方法，第一种是通过环境：

```latex
\begin{equation} 
	\mathcal{L}_t{f}=\int^\infty _0 e^{-st}f(t)dt 
    \label{eq} 
\end{equation} 
```

第二种是用美元符号：

```latex
$$\mathcal{L}_t{f}=\int^\infty _0 e^{-st}f(t)dt$$ 
```

你也许对于这种设定有点纠结：第一种语法很繁琐，第二种不能使用内文引用（label）。所以我们有没有办法建立一种语法简洁的公式插入格式，同时又支持内文引用呢？这时候你就可以参考下面给出的文档。当然，最好的方法是自己拿去编译一下。

```latex
\documentclass{article} 
\usepackage{ifthen, amsmath} 

\newcommand{\eq}[2][]{ 
	\ifthenelse{\equal{#1}{}}{ %  
    	\begin{equation*} #2 \end{equation*} % 
    }{ %  
    	\begin{equation} #2 \label{#1} \end{equation} % 
    } 
} 

\begin{document}
Now you can create an equation with inline cite like equation \ref{eq}.

\eq[eq]{\mathcal{L}_t{f}=\int^\infty _0 e^{-st}f(t)dt}

But you can also use it for normal equations: 

\eq{\mathcal{L}_t{f}=\int^\infty _0 e^{-st}f(t)dt} 

All super easy! 
\end{document} 
```

我知道有心编译的人毕竟是少的，所以，我这里给出结果：

![equation example](https://www.towdium.me/img/posts/2017/latex-for-beginners-4_1.png)

这样我们便成功地解决了问题，语法简单，并且同时支持含引用和不含引用的内容。当然你可能一头雾水，我们就来解释一下这一段代码。主要内容在第四行开始，其余部分均是非常普通的语法。这里我们新建了一个命令为 `\eq`。第一个方括号我们声明这个命令有两个参数，第二个方括号是可选参数的默认值，后面则是命令体了。

后面的 if 判断来自于 `ifthen` 宏包。大致相当于：

```latex
if #1 == '': 
	\begin{equation*} #2 \end{equation*} 
else:  
	\begin{equation} #2 \label{#1} \end{equation} 
```

这里 `#1` 指代第一个参数，即可选参数，默认值为空。`#2` 指代第二个参数，也就是实际的公式内容。$\LaTeX$ 中，命令的参数从1开始编号，如果有可选参数，则可选参数为1，必选参数后移；如果没有可选参数，则必选参数从1开始计数。这里命令的内容是：如果可选参数为空，即不需要内文引用，则执行前一种不带序号的格式；如果提供了引用的 label，则执行后一种带 label 声明的格式。

你可能注意到了里边有几行末尾有迷之 `%`。这是因为定义的内容会被原封不动的替换到原来文本的位置上，这里行末有换行符，调用之后可能就会造成多余的换行。在行尾加上 `%` 之后相当于把这个换行符给注释掉了，也就自然不会有多出的换行符了。

## 文件导入

说完命令定义之后，可以看到定义命令确实给我们提供了一些便利，但是在导言部分多出了一大坨命令定义，可以说是非常让人难受了。我们自然有办法解决这种问题，方法就是使用文件导入。类似于 C 语言的 `#inclide`。我们可以这样搞

```latex
\documentclass{article}
\usepackage{ifthen, amsmath, filecontents} 

\begin{filecontents}{header.tex} 
\newcommand{\name}{chenyang the Stupid} 
\end{filecontents} 

\input{header} 

\begin{document} 
This guy call himself \name .
\end{document} 
```

我这里使用了 `filecontents` 环境把两个文件写在一起了，实际上你可以把你的各种函数定义转移到另一个文件里，需要时将其导入即可。使用 `\input{文件名}` 就可以，这里不写后缀名似乎没有问题。

## 带你折腾 listings

介绍了文件导入之后，你就可以开始折腾自己的配置文件了，不管是什么模板，只要在需要时导入相关内容，就可以获得各种预先定义的特性。当然我并不可能把可以折腾的东西说的面面俱到，我这里只说 `listings` 的折腾内容，大概展示一下可以达到什么效果。有工夫的话，不妨编译一下下面这一段代码。其中我使用了大量的自定义格式，代码渲染终于可以有所改观了。

```latex
\documentclass{article} 
\usepackage{color, listings}

\definecolor{mygray}{rgb}{0.5,0.5,0.4} 
\definecolor{mygreen}{rgb}{0,0.7,0.5} 
\definecolor{myorange}{rgb}{1.0,0.4,0}
\definecolor{mylilas}{rgb}{0.8,0.3,1.0}

\lstdefinestyle{mybase} {
	breaklines=true, 
	showstringspaces=false, 
	basicstyle=\small\tt,
    frame=single,
    xleftmargin=20pt,
    xrightmargin=20pt,  
    numbersep=9pt,  
    numberstyle={\color{black} \footnotesize \sf}, 
    stringstyle=\color{myorange},  
    keywordstyle=\color{mygreen},  
    commentstyle=\color{mygray}\ttfamily
} 

\lstdefinestyle{mycpp} {  
	style=mybase, 
    language=C++
} 

\lstdefinestyle{myjava} { 
	style=mybase, 
    language=java
}

\lstdefinestyle{myahdl} { 
	style=mybase, 
    language = ahdl,
    keywordstyle=\color{mylilas},  
    commentstyle=\color{mygreen}
} 

\lstdefinelanguage{ahdl}{ 
	morekeywords={  
    	AND, ASSERT, BEGIN, BIDIR, BiTS, BURIED,   
        CASE, CLIQUE, CONNECTED_PINS, CONSTANT,    
        DEFAULTS, DEFINE, DESIGN, DEVICE, DIV,  
        ELSE, ELSEIF, END, FOR, FUNCTION,   
        GENERATE, GND, HELP_ID,  
        IF, INCLUDE, INPUT, IS, LOG2,  
        MACHINE, MOD, NAND, NODE, NOR, NOT, 
        OF, OPTIONS, OR, OTHERS, OUTPUT,  
        PARAMETERS, REPORT, RETURNS,  
        SEGMENTS, SEVERITY, STATES, SUBDESIGN, 
        TABLE, THEN, TITLE, TO, TRI_STATE_NODE,   
        VARIABLE, VCC, WHEN, WITH, XNOR, XOR,  
        CARRY, CASCADE, CEIL, DFFE, DFF,  
        EXP, FLOOR, GLOBAL, JEFFE, JKFF,  
        LATCH, LCELL, MCELL, MEMORY, OPNDRN, 
        SOFT, SRFFE, SRFF, TFFE, TFF, TRI,
        WIRE, X 
    }, 
    sensitive=false, 
    morecomment=[l]{--}, 
    morecomment=[s]{\%}{\%}, 
    tabsize = 4 
} 

\begin{document}

\begin{lstlisting}[style = mycpp] 
/* Hello World in cpp */ 
#include<stdio.h>

main() 
{  
	printf("Hello World");
} 
\end{lstlisting} 

\begin{lstlisting}[style = myjava] 
// Hello World in java 
public class HelloWorld {  
	public static void main(String[] args) {   
    	System.out.println("Hello, World"); 
    } 
} 
\end{lstlisting} 

\begin{lstlisting}[style = myahdl]
SUBDESIGN dec_count 
( 
	enc, ent, clk	:INPUT;
    clear			:INPUT;
    value[3..0]		:OUTPUT;
    rco				:OUTPUT; 
) 

VARIABLE 
	count[3..0]		:DFF;
    
BEGIN 
	count[].clk = clk; 
	value[] = count[];
    IF (clear) THEN 
    	count[].d = 0;
    ELSIF (enc & ent & (count[].q != 11)) THEN 	
    	count[].d = count[].q + 1;
    ELSIF (enc & ent & (count[].q == 11)) THEN 
    	count[].d = 0;
    ELSE 	
    	count[].d = count[].q; 
	END IF; 
	rco = ((count[].q == 11) & ent);
END;
\end{lstlisting}

\end{document} 
```

抱歉这段代码有点长，只是为了展示更多内容。你可以看到这里我们自己定义了 C++，Java 的语法高亮，甚至添加了 AHDL 的支持，并自定义了高亮。你可能没有听说过 AHDL，这并不重要，你只要当他是某门快要消失的语言就好了。编译结果如下：

![listing example](https://www.towdium.me/img/posts/2017/latex-for-beginners-4_2.png)

这里 `\lstdefinestyle` 用于自定义自己的格式，`\lstdefinelanguage` 用于定义新的语言。其余的我也就不多作解释了，如果你有这方面的需要，网上可以找到很多相关的资料。或者你可以删减定义中的某些项，观察其中的影响。我这里只是给出一个具体的例子，展示一下 $\LaTeX$ 的自定义程度。

# $\LaTeX$公式

## 公式

|   代码   |    符号    |        代码        |         符号         |
| :------: | :--------: | :----------------: | :------------------: |
| f(x)=a+b | $f(x)=a+b$ | f(x)=a+b \tag{1.1} | $f(x)=a+b \tag{1.1}$ |

## 通用运算符号

|   代码   |    符号    |   代码   |    符号    |    代码     |     符号      |    代码     |     符号      |
| :------: | :--------: | :------: | :--------: | :---------: | :-----------: | :---------: | :-----------: |
|    +     |    $+$     |    -     |    $-$     |   \times    |   $\times$    | \frac{a}{b} | $\frac{a}{b}$ |
| \log_a k | $\log_a k$ | \sqrt{a} | $\sqrt{a}$ | \sqrt[a]{b} | $\sqrt[a]{b}$ |             |               |

## 上下标

|      代码      |       符号       |   代码   |    符号    |        代码         |         符号          |  代码   |   符号    |
| :------------: | :--------------: | :------: | :--------: | :-----------------: | :-------------------: | :-----: | :-------: |
|    {a}^{b}     |    ${a}^{b}$     | {a}_{b}  | ${a}_{b}$  |    \sum_{a}^{b}     |    $\sum_{a}^{b}$     |   a'    |   $a'$    |
|    \dot{a}     |    $\dot{a}$     | \ddot{a} | $\ddot{a}$ | \overrightarrow{AB} | $\overrightarrow{AB}$ | \vec{a} | $\vec{a}$ |
| \overline{aaa} | $\overline{aaa}$ | \bar{a}  | $\bar{a}$  |                     |                       |         |           |

## 括号

|   代码    | 符号 |    代码    | 符号 |   代码   | 符号 |   代码    | 符号 |
| :-------: | :--: | :--------: | :--: | :------: | :--: | :-------: | :--: |
| `\left(`  | `(`  | `\right)`  | `)`  | `\left[` | `[`  | `\right]` | `]`  |
| `\left\{` | `{`  | `\right\}` | `}`  | `\left<` | `<`  | `\right>` | `>`  |

还有几个因为与Markdown的表格冲突单独列了出来
`\left|` `\right|` `\left\|` `\right\|` `\left.\frac{a}{b}\right|_{a=1}`

$\left|\qquad\qquad\right|\qquad\qquad\left\|\qquad\qquad\right\|\qquad\qquad\qquad\qquad\left.\frac{a}{b}\right|_{a=1}$

## 大型符号

|     代码     |      符号      |     代码      |      符号       |     代码     |      符号      |
| :----------: | :------------: | :-----------: | :-------------: | :----------: | :------------: |
| \sum_{a}^{b} | $\sum_{a}^{b}$ | \prod_{a}^{b} | $\prod_{a}^{b}$ | \int_{a}^{b} | $\int_{a}^{b}$ |
|  \iint_{D}   |  $\iint_{D}$   |  \iiint_{D}   |  $\iiint_{D}$   |  \oint_{D}   |  $\oint_{D}$   |

## 字母

|  代码  |   符号   |  代码  |   符号   |   代码   |    符号    |   代码   |    符号    |
| :----: | :------: | :----: | :------: | :------: | :--------: | :------: | :--------: |
| \alpha | $\alpha$ | \beta  | $\beta$  |  \Gamma  |  $\Gamma$  |  \gamma  |  $\gamma$  |
| \Delta | $\Delta$ | \delta | $\delta$ | \epsilon | $\epsilon$ |  \zeta   |  $\zeta$   |
|  \eta  |  $\eta$  | \theta | $\theta$ | \lambda  | $\lambda$  |   \mu    |   $\mu$    |
|  \nu   |  $\nu$   |  \xi   |  $\xi$   |   \pi    |   $\pi$    |   \rho   |   $\rho$   |
| \Sigma | $\Sigma$ | \sigma | $\sigma$ |   \tau   |   $\tau$   |   \psi   |   $\psi$   |
|  \Phi  |  $\Phi$  |  \phi  |  $\phi$  | \varphi  | $\varphi$  | \partial | $\partial$ |
| \Omega | $\Omega$ | \omega | $\omega$ |  \nabla  |  $\nabla$  |          |            |

## 其他符号

|    代码     |     符号      |   代码    |    符号     |    代码    |     符号     |  代码   |   符号    |
| :---------: | :-----------: | :-------: | :---------: | :--------: | :----------: | :-----: | :-------: |
|    \leq     |    $\leq$     |   \geq    |   $\geq$    |    \ll     |    $\ll$     |   \gg   |   $\gg$   |
|   \subset   |   $\subset$   | \subseteq | $\subseteq$ | \nsubseteq | $\nsubseteq$ | \equiv  | $\equiv$  |
|   \approx   |   $\approx$   |   \cong   |   $\cong$   |    \sim    |    $\sim$    |  \neq   |  $\neq$   |
|   \propto   |   $\propto$   |    \in    |    $\in$    |   \notin   |   $\notin$   |   \pm   |   $\pm$   |
|     \mp     |     $\mp$     |   \div    |   $\div$    |    \cap    |    $\cap$    |  \cup   |  $\cup$   |
|    \vee     |    $\vee$     |  \wedge   |  $\wedge$   |  \exists   |  $\exists$   | \forall | $\forall$ |
| \varnothing | $\varnothing$ | \implies  | $\implies$  |    \iff    |    $\iff$    |   \to   |   $\to$   |
| \therefore  | $\therefore$  | \because  | $\because$  |   \cdot    |   $\cdot$    | \bullet | $\bullet$ |
|   \infty    |   $\infty$    |  \angle   |  $\angle$   |            |              |         |           |

## 其他公式

|                代码                |                 符号                 |                   代码                    |                     符号                     |
| :--------------------------------: | :----------------------------------: | :---------------------------------------: | :------------------------------------------: |
| \lim\limits_{x\to\infty}\exp(-x)=0 | $\lim\limits_{x\to\infty}\exp(-x)=0$ | \int_0^\infty\mathrm{e}^{-x}\,\mathrm{d}x | $\int_0^\infty \mathrm{e}^{-x}\,\mathrm{d}x$ |
|              a\bmod b              |             $a \bmod b$              |             x\equiv a\pmod{b}             |            $x \equiv a \pmod{b}$             |
|  \frac{n!}{k!(n-k)!}=\binom{n}{k}  | $\frac{n!}{k!(n-k)!} = \binom{n}{k}$ |                                           |                                              |

## 多行公式

```latex
\begin{equation}
  x = a_0 + \cfrac{1}{a_1 
          + \cfrac{1}{a_2 
          + \cfrac{1}{a_3 + \cfrac{1}{a_4} } } }
\end{equation}
```

$$\begin{equation}
  x = a_0 + \cfrac{1}{a_1 
          + \cfrac{1}{a_2 
          + \cfrac{1}{a_3 + \cfrac{1}{a_4} } } }
\end{equation}$$

```latex
\sum_{\substack{
   0<i<m \\
   0<j<n
  }} 
 P(i,j)
```

$$\sum_{\substack{
   0<i<m \\
   0<j<n
  }} 
 P(i,j)$$

```latex
\begin{matrix}
  a & b & c \\
  d & e & f \\
  g & h & i
\end{matrix}
```

$$\begin{matrix}
  a & b & c \\
  d & e & f \\
  g & h & i
 \end{matrix}$$

```latex
A_{m,n} = 
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n} 
 \end{pmatrix}
```

$$A_{m,n} = 
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n} 
 \end{pmatrix}$$

```latex
f(n) =
  \begin{cases}
    n/2       & \quad \text{if } n \text{ is even}\\
    -(n+1)/2  & \quad \text{if } n \text{ is odd}
  \end{cases}
```

$$f(n) =
  \begin{cases}
    n/2       & \quad \text{if } n \text{ is even}\\
    -(n+1)/2  & \quad \text{if } n \text{ is odd}
  \end{cases}$$