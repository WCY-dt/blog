---
layout: post
title:  "现代 CSS 特性"
date:   2025-10-02 05:00:00 +0800
categories: 前端
tags: css
summary: "现代 CSS 引入了许多新特性和功能，距离成为图灵完备语言指日可待！"
comments: true
copyrights: 原创
---

现代 CSS 引入了许多新特性和功能，提升了网页设计的灵活性和表现力。本文将介绍一些现代 CSS 的重要特性，包括容器大小查询、`:has()` 伪类、选择器嵌套、滚动驱动动画、锚、`@scope` 规则、`@layer` 规则、`color-mix()` 函数、相对颜色、`margin-trim` 等。

## 容器大小查询

普通的 CSS 可以通过 `@media` 查询视口大小，而现代 CSS 则还可以通过 `@container` 查询容器大小：

```css
.element-wrap {
  container: element / inline-size;
}

@container element (min-inline-size: 150px) {
  .element {
    background: lightblue;
  }
}
```

`container` 属性用于定义一个容器查询上下文。查询类型包括：

| 查询类型 | 说明                     |
| -------- | ------------------------ |
| `normal` | 样式   |
| `size`   | 布局、样式和大小 |
| `inline-size` | 布局、样式和内联大小 |
| `scroll-state` | 滚动状态 |

`@container` 规则用于根据容器的大小应用不同的样式。

大小查询类似 `@container (min-width: 300px)`，条件包括：

| 条件               | 说明               |
| ------------------ | ------------------ |
| `aspect-ratio`   | 宽高比       |
| `block-size`    | 块级大小     |
| `inline-size`   | 内联大小     |
| `height`        | 高度         |
| `width`         | 宽度         |
| `orientation` | 方向 (`landscape` / `portrait`) |

滚动状态查询类似 `@container scroll-state(scrollable: top)`，条件包括：

| 条件               | 说明               | 可选项           |
| ------------------ | ------------------ | ---------------- |
| `scrollable` | 是否可以沿给定反向滚动 | `none`<br>`top` / `bottom` / `left` / `right`<br>`x` / `y`<br>`block` / `inline`<br>`block-start` / `block-end`<br>`inline-start` / `inline-end` |
| `snapped` | 是否要沿给定轴捕捉 | `none`<br>`x` / `y`<br>`block` / `inline` / `both` |
| `stuck` | 位置值为 `sticky` 的容器<br>是否粘在<br>其滚动容器祖先的边缘 | `none`<br>`top` / `bottom` / `left` / `right`<br>`block-start` / `block-end`<br>`inline-start` / `inline-end` |

样式查询类似 `@container style(--theme: dark)`，条件包括：

| 条件               | 样例           |
| ------------------ | ---------------- |
| 自定义属性 | `<style-feature>` |
| 计算值 | `--computed-feature: <value>` |
| CSS 属性 | `color: <value>` |

{% code_preview title="容器大小查询" %}
```html
<div class="element-wrap">
  <div class="element">
    Resize the window to see the background color change.
  </div>
</div>
```

```css
.element-wrap {
  container: element / inline-size;
  border: 2px solid black;
  padding: 10px;
  resize: both;
  overflow: auto;
  width: 100px;
  height: 100px;
}

@container element (min-inline-size: 150px) {
  .element {
    background: #5f9ea0;
  }
}
```
{% endcode_preview %}

## `:has()` 伪类

`:has()` 伪类用于选择包含特定后代元素的元素：

```css
.parent:has(.child) {
  background: lightgreen;
}
```

{% code_preview title=":has() 伪类" %}
```html
<div class="parent">
  Parent
  <div class="child">Child</div>
</div>
<div class="parent">
  Parent without child
</div>
```

```css
.parent {
  background: lightgray;
  padding: 10px;
  margin-bottom: 10px;
}

.parent:has(.child) {
  background: #5f9ea0;
}
```
{% endcode_preview %}

## 选择器嵌套

选择器嵌套允许在 CSS 中嵌套选择器，从而使代码更简洁：

```css
.parent {
  background: lightblue;
 
  .child {
    background: lightcoral;
  }
}
```

{% code_preview title="选择器嵌套" %}
```html
<div class="parent">
  Parent
  <div class="child">Child</div>
</div>
```

```css
.parent {
  background: lightgray;
  padding: 10px;

  .child {
    background: #5f9ea0;
    padding: 10px;
  }
}
```
{% endcode_preview %}

## 滚动驱动动画

原先的动画只能通过时间驱动，而现代 CSS 则可以通过滚动驱动。

`animation-timeline` 指定了动画的触发方式。其包括两种：

- 一种方式是使用 `scroll()` 函数，其参数包括：

  - 滚动容器，包括 `root`（视口）/ `nearest`（最近的滚动容器）/ `self`（元素本身）
  - 滚动方向，包括 `block`（块方向）/ `inline`（内联方向）/ `x`（水平）/ `y`（垂直）

  ```css
  .element {
    animation: fade-in linear;
    animation-timeline: scroll(root block);
  }

  @keyframes fade-in {
    from { opacity: 0; transform: translateY(50px); }
    to { opacity: 1; transform: translateY(0); }
  }
  ```

- 另一种方式是使用 `view()` 函数，用于视口交叉观察,当元素进入/离开视口时触发:

  ```css
  .element {
    animation: slide-in linear;
    animation-timeline: view();
    animation-range: entry 0% cover 50%;
  }

  @keyframes slide-in {
    from { 
      opacity: 0; 
      transform: translateX(-100px);
    }
    to { 
      opacity: 1; 
      transform: translateX(0);
    }
  }
  ```

`animation-range` 定义了动画的起止点。其包括 4 种：

- `entry`：元素进入视口时触发
- `exit`：元素离开视口时触发
- `cover`：元素完全进入视口时触发
- `contain`：元素完全离开视口时触发

{% code_preview title="滚动驱动动画" %}
```html
<div class="container">
  <div class="spacer"></div>
  <div class="element">Scroll<br>to<br>See</div>
  <div class="spacer"></div>
</div>
```

```css
.container {
  height: 300vh;
  padding: 20px;
  background: linear-gradient(to bottom, #1a1a2e, #16213e, #0f3460);
}

.spacer {
  height: 80vh;
}

.element {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 60px 40px;
  text-align: center;
  font-size: 2rem;
  font-weight: bold;
  color: white;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  animation: spectacular-reveal linear both;
  animation-timeline: view();
  animation-range: entry 0% cover 40%;
}

@keyframes spectacular-reveal {
  0% {
    opacity: 0;
    transform: perspective(1000px) rotateX(-90deg) translateY(100px) scale(0.5);
    filter: blur(20px) brightness(0.3);
  }
  50% {
    opacity: 0.8;
    transform: perspective(1000px) rotateX(-45deg) translateY(50px) scale(0.8);
    filter: blur(10px) brightness(0.7);
  }
  100% {
    opacity: 1;
    transform: perspective(1000px) rotateX(0deg) translateY(0) scale(1);
    filter: blur(0) brightness(1);
  }
}
```
{% endcode_preview %}

## 锚

锚允许为某个容器命名，然后别的地方可以通过 `anchor()` 函数引用该容器，从而实现相对于该容器的定位。

锚点元素通过 `anchor-name` 属性定义:

```css
.anchor {
  anchor-name: --my-anchor;
}
```

定位元素使用 `position-anchor` 关联锚点,然后通过 `anchor()` 函数引用:

```css
.positioned {
  position: absolute;
  position-anchor: --my-anchor;
  top: anchor(bottom);
  left: anchor(left);
}
```

{% code_preview title="锚" %}
```html
<div class="anchor">Anchor Point</div>
<div class="positioned">Positioned Element</div>
```

```css
.anchor {
  anchor-name: --my-anchor;
  background: #ff7e5f;
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  position: relative;
  top: 30vh;
  left: 50%;
  transform: translateX(-50%);
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.positioned {
  position: absolute;
  position-anchor: --my-anchor;
  top: anchor(bottom);
  left: anchor(left);
  background: #43cea2;
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}
```
{% endcode_preview %}

## `@scope` 规则

`@scope` 规则用于定义一个作用域,从而限制 CSS 变量的影响范围:

```css
@scope (.scoped) {
  :root {
    --main-color: lightcoral;
  }
}
.scoped {
  color: var(--main-color);
}
```

这也可以使用 `to` 关键字指定作用域范围:

```css
@scope (.scoped1) to (.scoped2) {
  :root {
    --main-color: lightcoral;
  }
}
.scoped1, .scoped2 {
  color: var(--main-color);
}
```

{% code_preview title="@scope 规则" %}
```html
<div class="scoped1">
  This text is scoped and should be lightcoral.
</div>
<div>
  This text is not scoped and should be black.
</div>
<div class="scoped2">
  This text is also scoped and should be lightcoral.
</div>
```

```css
@scope (.scoped1) to (.scoped2) {
  :root {
    --main-color: lightcoral;
  }
}

.scoped1, .scoped2 {
  color: var(--main-color);
  font-weight: bold;
}

div {
  margin-bottom: 10px;
}
```
{% endcode_preview %}

## layer

`@layer` 规则用于定义样式层，从而控制样式的优先级:

```css
@layer base {
  body {
    font-family: Arial, sans-serif;
    background: white;
    color: black;
  }
}
@layer theme {
  body {
    background: lightgray;
    color: darkblue;
  }
}
```

样式层的优先级由定义顺序决定，后定义的层优先级更高。

```css
@layer reset, base, theme;
```

{% code_preview title="@layer 规则" %}
```html
<div class="content">
  This text should be darkblue on lightgray background.
</div>
```

```css
@layer base {
  body {
    font-family: Arial, sans-serif;
    background: white;
    color: black;
  }
}

@layer theme {
  body {
    background: lightgray;
    color: darkblue;
  }
}

@layer reset, base, theme;

.content {
  padding: 20px;
}
```
{% endcode_preview %}

## `color-mix()` 函数

`color-mix()` 函数用于混合两种颜色，从而生成新的颜色:

```css
.element {
  background: color-mix(in srgb, red 50%, blue 50%);
}
```

{% code_preview title="color-mix() 函数" %}
```html
<div class="element-1">
  Color 1
</div>
<div class="element-2">
  Color 2
</div>
<div class="element-mixed">
  Mixed Color
</div>
```

```css
.element-1 {
  background: red;
}

.element-2 {
  background: blue;
}

.element-mixed {
  background: color-mix(in srgb, red 50%, blue 50%);
}

.element-1, .element-2, .element-mixed {
  color: white;
  padding: 20px;
  text-align: center;
  margin-bottom: 10px;
  font-weight: bold;
}
```
{% endcode_preview %}

## 相对颜色

现代 CSS 支持相对颜色,可以基于现有颜色进行调整:

```css
.element {
  background: color(display-p3 0.5 0.2 0.7);
  border: 2px solid color-contrast(background against white);
}
```
`color-contrast()` 函数用于计算与指定颜色对比度最高的颜色。

{% code_preview title="相对颜色" %}
```html
<div class="element">
  This element has a background color in Display P3 color space and a border color that contrasts with white.
</div>
```

```css
.element {
  background: color(display-p3 0.5 0.2 0.7);
  border: 2px solid color-contrast(background against white);
  color: white;
  padding: 20px;
  text-align: center;
  font-weight: bold;
}
```
{% endcode_preview %}

## `margin-trim`

`margin-trim` 属性用于修剪元素的外边距，从而避免外边距重叠:

```css
.element {
  margin: 20px;
  margin-trim: both;
}
```

其参数包括：

| 参数   | 说明           |
| ------ | -------------- |
| `none` | 不修剪外边距   |
| `start`| 修剪起始外边距 |
| `end`  | 修剪结束外边距 |
| `both` | 修剪起始和结束外边距 |

{% code_preview title="margin-trim" %}
```html
<div class="container">
  <div class="element">Element 1</div>
  <div class="element">Element 2</div>
</div>
```

```css
.container {
  background: lightgray;
  padding: 20px;
}

.element {
  background: #5f9ea0;
  color: white;
  margin: 20px;
  margin-trim: both;
  padding: 20px;
  text-align: center;
  font-weight: bold;
}
```
{% endcode_preview %}

## `text-wrap`

`text-wrap` 属性用于控制文本的换行行为:

```css
.element {
  text-wrap: pretty;
}
```

其参数包括：

| 参数       | 说明                     |
| ---------- | ------------------------ |
| `wrap`    | 普通换行                 |
| `nowrap`  | 不换行                   |
| `balance` | 尽量均匀分布文本行宽     |
| `pretty`  | 优化文本布局，减少孤行等 |
| `stable`  | 保持文本布局稳定         |

{% code_preview title="text-wrap" %}
```html
<div class="element">
  This is a long text that should demonstrate the pretty text wrapping feature of modern CSS. Resize the window to see how the text layout changes.
</div>
```

```css
.element {
  text-wrap: pretty;
  width: 200px;
  border: 2px solid #5f9ea0;
  padding: 20px;
  font-size: 1.2rem;
  line-height: 1.5;
  margin: 20px auto;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}
```
{% endcode_preview %}

## `subgrid`

`subgrid` 允许子网格继承父网格的行和列定义，从而实现更复杂的布局:

```css
.parent {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.child {
  grid-column: span 2;
}

.child-grid {
  display: grid;
  grid-template-columns: subgrid;
  gap: 5px;
}
```

{% code_preview title="subgrid" %}
```html
<div class="parent">
  <div class="child">
    <div class="child-grid">
      <div class="item">Item 1</div>
      <div class="item">Item 2</div>
      <div class="item">Item 3</div>
      <div class="item">Item 4</div>
    </div>
  </div>
  <div class="item">Item 5</div>
  <div class="item">Item 6</div>
</div>
```

```css
.parent {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  padding: 20px;
  background: lightgray;
}

.child {
  grid-column: span 2;
}

.child-grid {
  display: grid;
  grid-template-columns: subgrid;
  gap: 5px;
  background: #5f9ea0;
  padding: 10px;
}

.item {
  background: white;
  padding: 20px;
  text-align: center;
  font-weight: bold;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}
```
{% endcode_preview %}

## `field-sizing`

`field-sizing` 属性用于控制表单字段的大小行为:

```css
input, textarea, select {
  field-sizing: border-box;
}
```

其参数包括：

| 参数           | 说明                     |
| -------------- | ------------------------ |
| `content-box`  | 字段大小仅包含内容       |
| `border-box`   | 字段大小包含内容和边框   |
| `auto`         | 根据内容自动调整大小     |
| `stretch`      | 字段拉伸以填充可用空间   |

{% code_preview title="field-sizing" %}
```html
<form class="form">
  <label for="name">Name:</label>
  <input type="text" id="name" name="name" placeholder="Enter your name">
  <label for="message">Message:</label>
  <textarea id="message" name="message" placeholder="Enter your message"></textarea>
  <label for="options">Options:</label>
  <select id="options" name="options">
    <option value="option1">Option 1</option>
    <option value="option2">Option 2</option>
    <option value="option3">Option 3</option>
  </select>
</form>
```

```css
.form {
  display: flex;
  flex-direction: column;
  gap: 15px;
  width: 300px;
  margin: 20px auto;
}

input, textarea, select {
  field-sizing: border-box;
  padding: 10px;
  font-size: 1rem;
  border: 2px solid #5f9ea0;
  border-radius: 5px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}
```
{% endcode_preview %}
