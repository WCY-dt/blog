---
layout: post
title:  "【C++】modernC++ <img src='https://img.shields.io/badge/-原创-019733?style=flat'> <img src='https://img.shields.io/badge/-未完待续-blue?style=flat'> <img src='https://img.shields.io/badge/-推荐-F7DF1E?style=flat'>"
date:   2021-01-03 00:00:00 +0800
categories: toturial
tags: C++ ModernC++
comments: 1
mathjax: true
---

本文介绍C++11、14、17相关特性。

# 预备知识

## 左值引用和右值引用

### 左值引用

先看一下传统的左值引用。

```cpp
int a = 10;
int &b = a;  // 定义一个左值引用变量
b = 20;      // 通过左值引用修改引用内存的值
```

左值引用在汇编层面其实和普通的指针是一样的；定义引用变量必须初始化，因为引用其实就是一个别名，需要告诉编译器定义的是谁的引用。

```cpp
int &var = 10;
```

上述代码是无法编译通过的，因为10无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：

```cpp
const int &var = 10;
```

使用常引用来引用常量数字10，因为此刻内存上产生了临时变量保存了10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：

```cpp
const int temp = 10; 
const int &var = temp;
```

根据上述分析，得出如下结论：

**左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。**

那么C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。

### 右值引用

C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法：

- 可以取地址的，有名字的，非临时的就是左值；
- 不能取地址的，没有名字的，临时的就是右值；

可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，`const`对象等都是左值。

从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及`const`对象)。

定义右值引用的格式如下：

```cpp
类型 &&引用名 = 右值表达式;
```

右值引用是C++ 11新增的特性，所以C++ 98的引用为左值引用。右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。

```cpp
int &&var = 10;
```

在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量。但是，唯一 一点的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。

右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。

用C++98实现一个简单的顺序栈：

```cpp
class Stack
{
public:
    // 构造
    Stack(int size = 1000) 
	:msize(size), mtop(0)
    {
		cout << "Stack(int)" << endl;
		mpstack = new int[size];
    }
	
    // 析构
    ~Stack()
    {
		cout << "~Stack()" << endl;
		delete[]mpstack;
		mpstack = nullptr;
    }
	
    // 拷贝构造
    Stack(const Stack &src)
	:msize(src.msize), mtop(src.mtop)
    {
		cout << "Stack(const Stack&)" << endl;
		mpstack = new int[src.msize];
		for (int i = 0; i < mtop; ++i) {
	    	mpstack[i] = src.mpstack[i];
		}
    }
	
    // 赋值重载
    Stack& operator=(const Stack &src)
    {
		cout << "operator=" << endl;
		if (this == &src)
    	 	    return *this;

		delete[]mpstack;

		msize = src.msize;
		mtop = src.mtop;
		mpstack = new int[src.msize];
		for (int i = 0; i < mtop; ++i) {
		    mpstack[i] = src.mpstack[i];
		}
		return *this;
    }

    int getSize() 
    {
		return msize;
    }
private:
    int *mpstack;
    int mtop;
    int msize;
};

Stack GetStack(Stack &stack)
{
    Stack tmp(stack.getSize());
    return tmp;
}

int main()
{
    Stack s;
    s = GetStack(s);
    return 0;
}
```

运行结果如下：

```text
Stack(int)             // 构造s
Stack(int)             // 构造tmp
Stack(const Stack&)    // tmp拷贝构造main函数栈帧上的临时对象
~Stack()               // tmp析构
operator=              // 临时对象赋值给s
~Stack()               // 临时对象析构
~Stack()               // s析构
```

为了解决浅拷贝问题，为类提供了自定义的拷贝构造函数和赋值运算符重载函数，并且这两个函数内部实现都是非常的耗费时间和资源(首先开辟较大的空间，然后将数据逐个复制)，我们通过上述运行结果发现了两处使用了拷贝构造和赋值重载，分别是`tmp`拷贝构造`main`函数栈帧上的临时对象、临时对象赋值给`s`，其中`tmp`和临时对象都在各自的操作结束后便销毁了，使得程序效率非常低下。

那么我们为了提高效率，是否可以把`tmp`持有的内存资源直接给临时对象？是否可以把临时对象的资源直接给`s`？

在C++11中，我们可以解决上述问题，方式是提供带右值引用参数的拷贝构造函数和赋值运算符重载函数.

```cpp
// 带右值引用参数的拷贝构造函数
Stack(Stack &&src)
    :msize(src.msize), mtop(src.mtop)
{
    cout << "Stack(Stack&&)" << endl;

    /*此处没有重新开辟内存拷贝数据，把src的资源直接给当前对象，再把src置空*/
    mpstack = src.mpstack;  
    src.mpstack = nullptr;
}

// 带右值引用参数的赋值运算符重载函数
Stack& operator=(Stack &&src)
{
    cout << "operator=(Stack&&)" << endl;

    if(this == &src)
        return *this;
	    
    delete[]mpstack;

    msize = src.msize;
    mtop = src.mtop;

    /*此处没有重新开辟内存拷贝数据，把src的资源直接给当前对象，再把src置空*/
    mpstack = src.mpstack;
    src.mpstack = nullptr;

    return *this;
}
```

运行结果如下：

```text
Stack(int)             // 构造s
Stack(int)             // 构造tmp
Stack(Stack&&)         // 调用带右值引用的拷贝构造函数，直接将tmp的资源给临时对象
~Stack()               // tmp析构
operator=(Stack&&)     // 调用带右值引用的赋值运算符重载函数，直接将临时对象资源给s
~Stack()               // 临时对象析构
~Stack()               // s析构
```

程序自动调用了带右值引用的拷贝构造函数和赋值运算符重载函数，使得程序的效率得到了很大的提升，因为并没有重新开辟内存拷贝数据。

```cpp
mpstack = src.mpstack;  
```

可以直接赋值的原因是临时对象即将销毁，不会出现浅拷贝的问题，我们直接把临时对象持有的资源赋给新对象就可以了。

所以，临时量都会自动匹配右值引用版本的成员方法，旨在提高内存资源使用效率。

带右值引用参数的拷贝构造和赋值重载函数，又叫移动构造函数和移动赋值函数，这里的移动指的是把临时量的资源移动给了当前对象，临时对象就不持有资源，为`nullptr`了，实际上没有进行任何的数据移动，没发生任何的内存开辟和数据拷贝。

# 类型推导

## 理解模板类型推导

先来看C++98，一段函数模板看起来会是这样：

```cpp
template<typename T>
void f(ParamType param);
```

调用会是这样：

```cpp
f(expr); // 用一些表达式来调用f
```

在编译的时候，编译器通过 `expr` 来进行推导出两个类型：一个是 `T` 的，另一个是`ParamType` 。通常来说这些类型是不同的，因为 `ParamType` 通常包含一些类型的装饰，比如 `const `或引用特性。举个例子，模板通常采用如下声明：

```cpp
template<typename T>
void f(const T& param); // ParamType 是 const T&
```

如果有这样的调用：

```cpp
int x = 0；
f(x)； // 使用int调用f
```

`T` 被推导成` int `，` ParamType` 被推导成 `const int&` 。

### 值、指针、引用推导

一般会很自然的期望 `T `的类型和传递给他的参数的类型一致，也就是说` T` 的类型就是`expr` 的类型。在上面的例子中，` x `是一个` int `， `T` 也就被推导成 `int` 。但是并不是所有的情况都是如此。 `T` 的类型不仅和 `expr` 的类型独立，而且还和 `ParamType` 的形式独立。下面是三个例子：

- `ParamType` 是一个指针或者是一个引用类型，但并不是一个通用的引用类型
- `ParamType` 是一个通用的引用
- `ParamType` 既不是指针也不是引用

这样的话，我们就有了三种类型需要检查的类型推导场景。每一种都是基于我们队模板的通用的调用封装：

```cpp
template<typename T>
void f(ParamType param);
f(expr); // 从expr推导出T和ParamType的类型
```

#### `ParamType` 是个非通用的引用或者是一个指针

最简单的情况是当 `ParamType` 是一个引用类型或者是一个指针，但并非是通用的引用。在这种情况下，类型推导的过程如下：

1. 如果 `expr` 的类型是个引用，忽略引用的部分。
2. 然后利用 `expr` 的类型和 `ParamType` 对比去判断 `T` 的类型。

举一个例子，如果这个是我们的模板，

```cpp
template<typename T>
void f(T& param); // param是一个引用类型
```

我们有这样的代码变量声明：

```cpp
int x = 27; // x是一个int
const int cx = x; // cx是一个const int
const int& rx = x; // rx是const int的引用
```

`param` 和 `T` 在不同的调用下面的类型推导如下：

```cpp
f(x); // T是int，param的类型时int&
f(cx); // T是const int，
// param的类型是const int&
f(rx); // T是const int
// param的类型时const int&
```

在第二和第三部分的调用，注意 `cx` 和 `rx` 由于被指定为 `const` 类型变量， T 被推导成 `const int` ，这也就导致了参数的类型被推导为 `const int&` 。这对调用者非常重要。当传递一个 `const` 对象给一个引用参数，他们期望对象会保留常量特性，也就是说，参数变成了 `const` 的引用。这也就是为什么给一个以 `T&` 为参数的模板传递一个 `const` 对象是安全的：对象的 `const` 特性是 `T` 类型推导的一部分。

在第三个例子中，注意尽管 `rx `的类型是一个引用， `T` 仍然被推导成了一个非引用的。这是因为 `rx` 的引用特性会被类型推导所忽略。

这些例子展示了左值引用参数的处理方式，但是类型推导在右值引用上也是如此。当然，右值参数只可能传递给右值引用参数，但是这个限制和类型推导没有关系。

如果我们把 `f` 的参数类型从 `T&` 变成 `const T&` ，情况就会发生变化，但是并不会令人惊讶。由于 `param` 的声明是 `const` 引用的， `cx `和 `rx` 的 `const` 特性会被保留，这样的话 `T` 的 `const` 特性就没有必要了。

```cpp
template<typename T>
void f(const T& param); // param现在是const的引用
int x = 27; // 和之前一样
const int cx = x; // 和之前一样
const int& rx = x; // 和之前一样
f(x); // T是int，param的类型是const int&
f(cx); // T是int，param的类型是const int&
f(rx); // T是int，param的类型是const int&
```

和之前一样， `rx` 的引用特性在类型推导的过程中会被忽略。

如果 `param` 是一个指针（或者指向 `const` 的指针）而不是引用，情况也是类似：

```cpp
template<typename T>
void f(T* param); // param是一个指针
int x = 27; // 和之前一样
const int *px = &x; // px是一个指向const int x的指针
f(&x); // T是int，param的类型是int*
f(px); // T是const int
// param的类型时const int*
```

到目前为止，你或许瞌睡了，因为C++在引用和指针上的类型推导法则是如此的自然，我写出来读者看显得很没意思。所有的事情都这么明显！这就是读者所期望的的类型推导系统吧。

#### `ParamType` 是个Universal Reference

对于通用的引用参数，情况就变得不是那么明显了。这些参数被声明成右值引用（也就是函数模板使用一个类型参数 `T` ，一个通用的引用参数的申明类型是 `T&&` ），但是当传递进去右值参数情况变得不一样。

如果 `expr` 是一个左值， `T` 和 `ParamType` 都会被推导成左值引用。这有些不同寻常。第一，这是模板类型 `T `被推导成一个引用的唯一情况。第二，尽管 `ParamType` 利用右值引用的语法来进行推导，但是他最终推导出来的类型是左值引用。

如果 `expr` 是一个右值，那么就执行“普通”的法则（第一种情况）举个例子：

```cpp
template<typename T>
void f(T&& param); // param现在是一个通用的引用
int x = 27; // 和之前一样
const int cx = x; // 和之前一样
const int& rx = x; // 和之前一样
f(x); // x是左值，所以T是int&
// param的类型也是int&
f(cx); // cx是左值，所以T是const int&
// param的类型也是const int&
f(rx); // rx是左值，所以T是const int&
// param的类型也是const int&
f(27); // 27是右值，所以T是int
// 所以param的类型是int&&
```

关键的地方在于通用引用的类型推导法则和左值引用或者右值引用的法则大不相同。特殊的情况下，当使用了通用的引用，左值参数和右值参数的类型推导大不相同。这在非通用的类型推到上面绝对不会发生。

#### `ParamType` 既不是指针也不是引用

当 `ParamType` 既不是指针也不是引用，我们把它处理成pass-by-value：

```cpp
template<typename T>
void f(T param); // param现在是pass-by-value
```

这就意味着 `param `就是完全传给他的参数的一份拷贝——一个完全新的对象。基于这个事实可以从` expr` 给出推导的法则：

1. 和之前一样，如果 `expr` 的类型是个引用，将会忽略引用的部分。
2. 如果在忽略 `expr` 的引用特性， `expr` 是个 `const` 的，也要忽略掉 `const` 。如果是 `volatile` ，照样也要忽略掉（ `volatile` 对象并不常见。它们常常被用在实现设备驱动上面。）

这样的话：

```cpp
int x = 27; // 和之前一样
const int cx = x; // 和之前一样
const int& rx = x; // 和之前一样
f(x); // T和param的类型都是int
f(cx); // T和param的类型也都是int
f(rx); // T和param的类型还都是int
```

注意尽管 `cx` 和 `rx` 都是 `const` 类型， `param`却不是 `const `的。这是有道理的。` param` 是一个和 `cx` 和 `rx` 独立的对象——一个 `cx `和` rx `的拷贝。 `cx` 和 `rx` 不能被修改和 `param` 能不能被修改是没有关系的。这就是为什么 `expr` 的常量特性（或者是易变性）（在很多的C++书籍上面 `const` 特性和 `volatile` 特性被称之为CV特性）在推导 `param` 的类型的时候被忽略掉了： `expr` 不能被修改并不意味着它的一份拷贝不能被修改。

认识到 `const` （和 `volatile` ）在按值传递参数的时候会被忽略掉。正如我们所见，引用的 `const` 或者是指针指向 `const` ， `expr` 的 `const` 特性在类型推导的过程中会被保留。但是考虑到 `expr` 是一个 `const` 的指针指向一个` const `对象，而且 `expr `被通过按值传递传递给 `param` ：

```cpp
template<typename T>
void f(T param); // param仍然是按值传递的（pass by value）
const char* const ptr = // ptr是一个const指针，指向一个const对象
	"Fun with pointers";
f(ptr); // 给参数传递的是一个const char * const类型
```

这里，位于星号右边的 `const` 是表明指针是常量 `const `的： `ptr` 不能被修改指向另外一个不同的地址，并且也不能置成 `null` 。（星号左边的 `const` 表明 `ptr` 指向的字符串是 `const `的，也就是说字符串不能被修改。）

当这个 `ptr` 传递给 `f` ，组成这个指针的内存bit被拷贝给 `param` 。这样的话，指针自己（` ptr `）本身是被按值传递的。按照按值传递的类型推导法则，` ptr `的 `const` 特性会被忽略，这样 `param` 的推导出来的类型就是 `const char*` ，也就是一个可以被修改的指针，指向一个 `const`的字符串。 `ptr `指向的东西的 `const` 特性被加以保留，但是 `ptr` 自己本身的 `const` 特性会被忽略，因为它要被重新复制一份而创建了一个新的指针 `param `。

### 数组参数

这主要出现在mainstream的模板类型推导里面，但是有一种情况需要特别加以注意。就是数组类型和指针类型是不一样的，尽管它们通常看起来是可以替换的。一个最基本的幻觉就是在很多的情况下，一个数组会被退化成一个指向其第一个元素的指针。这个退化的代码常常如此：

```cpp
const char name[] = "J. P. Briggs"; // name的类型是const char[13]
const char * ptrToName = name; // 数组被退化成指针
```

在这里， `const char*` 指针 `ptrToName` 使用 `name` 初始化，实际的 `name` 的类型是 `const char[13]` 。这些类型（ `const char*` 和 `const char[13]` ）是不一样的，但是因为数组到指针的退化规则，代码会被正常编译。

但是如果一个数组传递给一个安置传递的模板参数里面情况会如何？会发生什么呢？

```cpp
template<typename T>
void f(T param); // 模板拥有一个按值传递的参数
f(name); // T和param的类型会被推到成什么呢？
```

我们从一个没有模板参数的函数开始。是的，是的，语法是合法的，

```cpp
void myFunc(int param[]); // 和上面的函数相同
```

但是以数组声明，但是还是把它当成一个指针声明，也就是说 `myFunc` 可以和下面的声明等价：

```cpp
void myFunc(int* param); // 和上面的函数是一样的
```

这样的数组和指针等价的声明经常会在以C语言为基础的C++里面出现，这也就导致了数组和指针是等价的错觉。

因为数组参数声明会被当做指针参数，传递给模板函数的按值传递的数组参数会被退化成指针类型。这就意味着在模板 `f `的调用中，模板参数 `T` 被推导成 `const char*` ：

```cpp
f(name); // name是个数组，但是T被推导成const char*
```

但是来一个特例。尽管函数不能被真正的定义成参数为数组，但是可以声明参数是数组的引用！所以如果我们修改模板` f `的参数成引用，

```cpp
template<typename T>
void f(T& param); // 引用参数的模板
```

然后传一个数组给他

```cpp
f(name); // 传递数组给f
```

`T` 最后推导出来的实际的类型就是数组！类型推导包括了数组的长度，所以在这个例子里面， `T` 被推导成了 `const char [13]` ，函数 `f` 的参数（数组的引用）被推导成了 `const char(&)[13]` 。是的，语法看起来怪怪的，但是理解了这些可以升华你的精神。

有趣的是，声明数组的引用可以使的创造出一个推导出一个数组包含的元素长度的模板：

```cpp
// 在编译的时候返回数组的长度（数组参数没有名字，
// 因为只关心数组包含的元素的个数）
template<typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept
{
	return N; // constexpr和noexcept在随后的条款中介绍
}
```

`constexpr` 是一种比` const` 更加严格的常量定义， `noexcept` 是说明函数永远都不会抛出异常。定义为 `constexpr` 说明函数可以在编译的时候得到其返回值。这就使得创建一个和一个数组长度相同的一个数组，其长度可以从括号初始化：

```cpp
int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 }; // keyVals有七个元素
int mappedVals[arraySize(keyVals)]; // mappedVals长度也是七
```

当然，作为一个现代的C++开发者，应该优先选择内建的 `std::array` ：

```cpp
std::array<int, arraySize(keyVals)> mappedVals; // mappedVals长度是七
```

由于 `arraySize` 被声明称 `noexcept` ，这会帮助编译器生成更加优化的代码。

### 函数参数

数组并不是C++唯一可以退化成指针的东西。函数类型可以被退化成函数指针，和我们之前讨论的数组的推导类似，函数可以被推华城函数指针：

```cpp
void someFunc(int， double); // someFunc是一个函数
// 类型是void(int, double)
template<typename T>
void f1(T param); // 在f1中 参数直接按值传递
template<typename T>
void f2(T& param); // 在f2中 参数是按照引用传递
f1(someFunc); // param被推导成函数指针
// 类型是void(*)(int, double)
f2(someFunc); // param被推导成函数指针
// 类型时void(&)(int, double)
```

这在实践中极少有不同，如果你知道数组到指针的退化，或许你也就会就知道函数到函数指针的退化。
所以你现在知道如下： `auto` 相关的模板推导法则。我把最重要的部分单独在下面列出来。在通用引用中对待左值的处理有一点混乱，但是数组退化成指针和函数退化成函数指针的做法更加混乱呢。有时候你要对你的编译器和需求大吼一声，“告诉我到底类型推导成啥了啊！”

### 总结

- 在模板类型推导的时候，有引用特性的参数的引用特性会被忽略
- 在推导通用引用参数的时候，左值会被特殊处理
- 在推导按值传递的参数时候，` const` 和/或 `volatile` 参数会被视为非 `const` 和非 `volatile`
- 在模板类型推导的时候，参数如果是数组或者函数名称，他们会被退化成指针，除非是用在初始化引用类型

## 理解`auto`类型推导

如果你已经阅读了第一节关于模板相关的类型推导，你就已经知道了机会所有关于 `auto` 的类型推导，因为除了一个例外，` auto` 类型推导就是模板类型推导。但是它怎么就会是模板类型推导呢？模板类型推导涉及模板和函数以及参数，但是 `auto `和上面的这些没有任何的关系。这是对的，但是没有关系。模板类型推导和 `auto` 类型推导是有一个直接的映射。有一个书面上的从一种情况转换成另外一种情况的算法。

在第一节，模板类型推导是使用下面的通用模板函数来解释的：

```cpp
template<typename T>
void f(ParamType param);
```

在这里通常调用：

```cpp
f(expr); // 使用一些表达式来当做调用f的参数
```

在调用 `f` 的地方，编译器使用 `expr` 来推导` T `和 `ParamType `的类型。

当一个变量被声明为` auto` ，` auto` 相当于模板中的` T `，而对变量做的相关的类型限定就像 `ParamType `。这用代码说明比直接解释更加容易理解，所以看下面的这个例子：

```cpp
auto x = 27;
```

这里，对` x` 的类型定义就仅仅是 `auto `本身。从另一方面，在这个声明中：

```cpp
const auto cx = x;
```

类型被声明成` const auto` ，在这儿：

```cpp
const auto& rx = x;
```

类型被声明称 `const auto&` 。在这些例子中推导` x `， `cx `，` rx` 的类型的时候，编译器处理每个声明的时候就和处理对应的表达式初始化的模板：

```cpp
template<typename T> // 推导x的类型的
void func_for_x(T param); // 概念上的模板
func_for_x(27); // 概念上的调用：
// param的类型就是x的类型
template<typename T>
void func_for_cx(const T param); // 推导cx的概念上的模板
func_for_cx(x); // 概念调用：param的推导类型就是cx的类型
template<typename T>
void func_for_rx(const T& param); // 推导rx概念上的模板
func_for_rx(x); // 概念调用：param的推导类型就是rx的类型
```

正如我所说，对 `auto` 的类型推导只存在一种情况的例外（这个后面就会讨论），其他的就和模板类型推导完全一样了。

条款1把模板类型推导划分成三部分，基于在通用的函数模板的 `ParamType` 的特性和 `param` 的类型声明。在一个用 `auto` 声明的变量上，类型声明代替了` ParamType` 的作用，所以也有三种情况：

- 情况1：类型声明是一个指针或者是一个引用，但不是一个通用的引用
- 情况2：类型声明是一个通用引用
- 情况3：类型声明既不是一个指针也不是一个引用

我们已经看了情况1和情况3的例子：

```cpp
auto x = 27; // 情况3（x既不是指针也不是引用）
const auto cx = x; // 情况3（cx二者都不是）
const auto& rx = x; // 情况1（rx是一个非通用的引用）
情况2正如你期待的那样：
auto&& uref1 = x; // x是int并且是左值
// 所以uref1的类型是int&
auto&& uref2 = cx; // cx是int并且是左值
// 所以uref2的类型是const int&
auto&& uref3 = 27; // 27是int并且是右值
// 所以uref3的类型是int&&
```

第一节讲解了在非引用类型声明里，数组和函数名称如何退化成指针。这在 `auto `类型推导上面也是一样：

```cpp
const char name[] = // name的类型是const char[13]
"R. N. Briggs";
auto arr1 = name; // arr1的类型是const char*
auto& arr2 = name; // arr2的类型是const char (&)[13]
void someFunc(int, double); // someFunc是一个函数，类型是
// void (*)(int, double)
auto& func2 = someFunc; // func1的类型是
// void (&)(int, double)
```

正如你所见，` auto` 类型推导和模板类型推导工作很类似。它们就像一枚硬币的两面。除了有一种情况是不一样的。我们从如果你想声明一个用27初始化的 `int` ， C++98你有两种语法选择：

```cpp
int x1 = 27;
int x2(27);
```

C++11，通过标准支持的统一初始化（使用花括号初始化），可以添加下面的代码：

```cpp
int x3 = { 27 };
int x4{ 27 };
```

综上四种语法，都会生成一种结果：一个拥有27数值的 `int` 。

但是使用` auto` 来声明变量比使用固定的类型更好，所以在上述的声明中把 `int` 换成 `auto` 更好。最直白的写法就如下面的代码：

```cpp
auto x1 = 27;
auto x2(27);
auto x3 = {27};
auto x4{ 27 };
```

上面的所有声明都可以编译，但是他们和被替换的相对应的语句的意义并不一样。头两个的确是一样的，声明一个初始化值为27的 `int` 。然而后面两个，声明了一个类型为 `std::intializer_list<int>` 的变量，这个变量包含了一个单一的元素27！

```cpp
auto x1 = 27; // 类型时int，值是27
auto x2(27); // 同上
auto x3 = { 27 }; // 类型是std::intializer_list<int>
// 值是{ 27 }
auto x4{ 27 }; // 同上
```

这和 `auto` 的一种特殊类型推导有关系。当使用一对花括号来初始化一个 `auto` 类型的变量的时候，推导的类型是` std::intializer_list `。如果这种类型无法被推导（比如在花括号中的变量拥有不同的类型），代码会编译错误。

```cpp
auto x5 = { 1, 2, 3.0 }; // 错误！ 不能讲T推导成
// std::intializer_list<T>
```

正如注释中所说的，在这种情况，类型推导会失败，但是认识到这里实际上是有两种类型推导是非常重要的。一种是 `auto`: `x5` 的类型被推导。因为 `x5 `的初始化是在花括号里面， `x5` 必须被推导成 `std::intializer_list ` 。但是` std::intializer_list` 是一个模板。实例是对一些 `T` 实例化成 `std::intializer_list<T>` ，这就意味着 `T` 的类型必须被推导出来。类型推导就在第二种的推导的范围上失败了。在这个例子中，类型推导失败是因为在花括号里面的数值并不是单一类型的。

对待花括号初始化的行为是` auto `唯一和模板类型推导不一样的地方。当 `auto` 声明变量被使用一对花括号初始化，推导的类型是 `std::intializer_list` 的一个实例。但是如果相同的初始化递给相同的模板，类型推导会失败，代码不能编译。

```cpp
auto x = { 11, 23, 9 }; // x的类型是
// std::initializer_list<int>
template<typename T> // 和x的声明等价的
void f(T param); // 模板
f({ 11, 23, 9 }); // 错误的！没办法推导T的类型
```

但是，如果你明确模板的 `param` 的类型是一个不知道 `T` 类型的` std::initializer_list<T> `：

```cpp
template<typename T>
void f(std::initializer_list<T> initList);
f({ 11, 23, 9 }); // T被推导成int，initList的
// 类型是std::initializer_list<int>
```

所以 `auto` 和模板类型推导的本质区别就是 `auto` 假设花括号初始化代表的是`std::initializer_list`，但是模板类型推导却不是。

你可能对为什么 `auto `类型推导有一个对花括号初始化有一个特殊的规则而模板的类型推导却没有感兴趣。我自己也非常奇怪。可是我一直没有能够找到一个有力的解释。但是法则就是法则，这就意味着你必须记住如果使用 `auto` 声明一个变量并且使用花括号来初始化它，类型推导的就是` std::initializer_list` 。你必须习惯这种花括号的初始化哲学——使用花括号里面的数值来初始化是理所当然的。在C++11编程里面的一个经典的错误就是误被声明成 `std::initializer_list` ，而其实你是想声明另外的一种类型。这个陷阱使得一些开发者仅仅在必要的时候才会在初始化数值周围加上花括号。（什么时候是必要的会在条款7里面讨论。）

对于C++11，这是一个完整的故事，但是对于C++14来说，故事还要继续。C++14允许 `auto` 表示推导的函数返回值，而且C++14的lambda可能会在参数声明里面使用 `auto` 。但是，这里面的使用是复用了模板的类型推导，而不是` auto` 的类型推导。所以一个使用 `auto` 声明的返回值的函数，返回一个花括号初始化就无法编译。

```cpp
auto createInitList()
{
	return { 1, 2, 3 }; // 编译错误：不能推导出{ 1, 2, 3 }的类型
}
```

在C++14的lambda里面，当 `auto `用在参数类型声明的时候也是如此：

```cpp
std::vector<int> v;
…
auto resetV =
[&v](const auto& newValue) { v = newValue; } // C++14
…
resetV({ 1, 2, 3 }); // 编译错误，不能推导出{ 1, 2, 3 }的类型
```

### 总结

- `auto` 类型推导通常和模板类型推导类似，但是 auto 类型推导假定花括号初始化代表的类型是 `std::initializer_list `，但是模板类型推导却不是这样
- `auto` 在函数返回值或者lambda参数里面执行模板的类型推导，而不是通常意义的 `auto` 类型推导

## 理解`decltype`

`decltype` 是一个怪异的发明。给定一个变量名或者表达式，` decltype` 会告诉你这个变量名或表达式的类型。 `decltype` 的返回的类型往往也是你期望的。然而有时候，它提供的结果会使开发者极度抓狂而不得参考其他文献或者在线的Q&A网站。

我们从在典型的情况开始讨论，这种情况下 `decltype` 不会有令人惊讶的行为。与 `templates` 和 `auto` 在类型推导中行为相比（请见条款一和条款二）， `decltype` 一般只是复述一遍你所给他的变量名或者表达式的类型，如下：

```cpp
const int i = 0; // decltype(i) is const int
bool f(const Widget& w); // decltype(w) is const Widget&
// decltype(f) is bool(const Widget&)
struct Point{
	int x, y; // decltype(Point::x) is int
};
Widget w; // decltype(w) is Widget
if (f(w)) ... // decltype(f(w)) is bool
template<typename T> // simplified version of std::vector
class vector {
public:
	...
	T& operator[](std::size_t index);
	...
};
vector<int> v; // decltype(v) is vector<int>
...
if(v[0] == 0) // decltype(v[0]) is int&
```

看到没有？毫无令人惊讶的地方。

在C++11中， `decltype` 最主要的用处可能就是用来声明一个函数模板，在这个函数模板中返回值的类型取决于参数的类型。举个例子，假设我们想写一个函数，这个函数中接受一个支持方括号索引（也就是`[]`）的容器作为参数，验证用户的合法性后返回索引结果。这个函数的返回值类型应该和索引操作的返回值类型是一样的。

操作子` []` 作用在一个对象类型为 `T` 的容器上得到的返回值类型为 `T&` 。对 `std::deque` 一般是成立的，例如，对 `std::vector` ，这个几乎是处处成立的。然而，对 `std::vector<bool>` ，` []` 操作子不是返回 `bool& `，而是返回一个全新的对象。发生这种情况的原理将在第六节中讨论，对于此处重要的是容器的 `[]` 操作返回的类型是取决于容器的。

`decltype` 使得这种情况很容易来表达。下面是一个模板程序的部分，展示了如何使用 `decltype` 来求返回值类型。这个模板需要改进一下，但是我们先不着急：

```cpp
template<typename Container, typename Index> // works, but
auto authAndAccess(Container& c, Index i) // requires
-> decltype(c[i]) // refinements
{
	authenticateUser();
	return c[i];
}
```

将` auto` 用在函数名之前和类型推导是没有关系的。更精确地讲，此处使用了 C++11 的尾随返回类型技术，即函数的返回值类型在函数参数之后声明(`->`后边)。尾随返回类型的一个优势是在定义返回值类型的时候使用函数参数。例如在函数 `authAndAccess `中，我们使用了 `c` 和 `i `定义返回值类型。在传统的方式下，我们在函数名前面声明返回值型， `c` 和 `i` 是得不到的，因为此时 `c` 和` i `还没被声明。使用这种类型的声明，` authAndAccess `的返回值就是` []` 操作子的返回值，这正是我们所期望
的。

C++11 允许单语句的 lambda 表达式的返回类型被推导，在 C++14 中之中行为被拓展到包括多语句的所有的 lambda表达式和函数。在上面 `authAndAccess` 中，意味着在 C++14 中我们可以忽略尾随返回类型，仅仅保留开头的 `auto`。使用这种形式的声明， 意味着将会使用类型推导。特别注意的是，编译器将从函数的实现来推导这个函数的返回类型：

```cpp
template<typename Container, typename Index> // C++14;
auto authAndAccess(Container &c, Index i) // not quite
{ // correct
authenticateUser();
return c[i];
} // return type deduced from c[i]
```

条款二解释说，对使用 `auto` 来表明函数返回类型的情况，编译器使用模板类型推导。但是这样是回产生问题的。正如我们所讨论的，对绝大部分对象类型为 `T` 的容器， `[] `操作子返回的类型是 `&T` , 然而第一节提到，在模板类型推导的过程中,初始表达式的引用会被忽略。思考这对下面代码意味着什么：

```cpp
std::deque<int> d;
...
authAndAccess(d, 5) = 10; // authenticate user, return d[5],
// then assign 10 to it;
// this won't compile!
```

此处， `d[5]` 返回的是 `int&` ，但是 `authAndAccess` 的 `auto` 返回类型声明将会剥离这个引用，从而得到的返回类型是 `int` 。 `int` 作为一个右值成为真正的函数返回类型。上面的代码尝试给一个右值` int` 赋值为10。这种行为是在 C++ 中被禁止的，所以代码无法编译通过。为了让 `authAndAccess` 按照我们的预期工作，我们需要为它的返回值使用 `decltype` 类型推导，即指定 `authAndAccess` 要返回的类型正是表达式 `c[i]` 的返回类型。 C++ 的拥护者们预期到在某种情况下有使用`decltype` 类型推导规则的需求，并将这个功能在 C++14 中通过 `decltype(auto)` 实现。这使这对原本的冤家（` decltype` 和 `auto` ）在一起完美地发挥作用：` auto` 指定需要推导的类型，` decltype` 表明在推导的过程中使用 `decltype` 推导规则。因此，我们可以重写 `authAndAccess` 如下：

```cpp
template<typename Container, typename Index> // C++14; works,
decltype(auto) // but still
authAndAccess(Container &c, Index i) // requires
{ // refinement
authenticateUser();
return c[i];
}
```

现在` authAndAccess` 的返回类型就是 `c[i]` 的返回类型。在一般情况下， `c[i]` 返回 `T&` ， `authAndAccess` 就返回 `T&` ，在不常见的情况下，` c[i] `返回一个对象，`authAndAccess `也返回一个对象。

`decltype(auto)` 并不仅限使用在函数返回值类型上。当时想对一个表达式使用 `decltype` 的推导规则时，它也可以很方便的来声明一个变量：

```cpp
Widget w;
const Widget& cw = w;
auto myWidget1 = cw; // auto type deduction
// myWidget1's type is Widget
decltype(auto) myWidget2 = cw // decltype type deduction:
// myWidget2's type is
// const Widget&
```

我知道，到目前为止会有两个问题困扰着你。一个是我们前面提到的，对 `authAndAccess` 的改进。我们在这里讨论。

再次看一下 C++14 版本的` authAndAccess` 的声明：

```cpp
template<typename Container, typename Index>
decltype(auto) anthAndAccess(Container &c, Index i);
```

这个容器是通过非` const` 左值引用传入的，因为通过返回一个容器元素的引用是来修改容器是被允许的。但是这也意味着不可能将右值传入这个函数。右值不能和一个左值引用绑定（除非是` const `的左值引用，这不是这里的情况）。

诚然，传递一个右值容器给 `authAndAccess` 是一种极端情况。一个右值容器作为一个临时对象，在 `anthAndAccess` 所在语句的最后被销毁，意味着对容器中一个元素的引用（这个引用通常是 `authAndAccess` 返回的）在创建它的语句结束的地方将被悬空。然而，这对于传给 `authAndAccess` 一个临时对象是有意义的。一个用户可能仅仅想拷贝一个临时容器中的一个元素，例如：

```cpp
std::deque<std::string> makeStringDeque(); // factory function
// make copy of 5th element of deque returned
// from makeStringDeque
auto s = authAndAccess(makeStringDeque(), 5);
```

支持这样的应用意味着我们需要修改 `authAndAccess` 的声明来可以接受左值和右值。重载可以解决这个问题（一个重载负责左值引用参数，另外一个负责右值引用参数），但是我们将有两个函数需要维护。避免这种情况的一个方法是使 `authAndAccess `有一个既可以绑定左值又可以绑定右值的引用参数，条款24将说明这正是统一引用（ universal reference ）所做的。因此 `authAndAccess` 可以像如下声明：

```cpp
template<typename Container, typename Index> // c is now a
decltype(auto) authAndAccess(Container&& c, // universal
Index i); // reference
```

在这个模板中，我们不知道我们在操作什么类型的容器，这也意味着我们等同地忽略了它用到的索引对象的类型。对于一个不清楚其类型的对象使用传值传递通常会冒一些风险，比如因为不必要的复制而造成的性能降低，对象切片的行为问题，被同事嘲笑，但是对容器索引的情况，正如一些标准库的索引（ `std::string`, `std::vector`, `std::deque` 的 `[] `操作）按值传递看上去是合理的，因此对它们我们仍坚持按值传递。

然而，我们需要更新这个模板的实现，将` std::forward` 应用给统一引用，使得它和条款25中的建议是一致的。

```cpp
template<typename Container, typename Index> // final
decltype(auto) // C++14
authAndAccess(Container&& c, Index i) // version
{
authenticateUser();
return std::forward<Container>(c)[i];
}
```

这个实现可以做我们期望的任何事情，但是它要求使用支持 C++14 的编译器。如果你没有一个这样的编译器，你可以使用这个模板的 C++11 版本。它出了要你自己必须指定返回类型以外，和对应的 C++14 版本是完全一样的，

```cpp
template<typename Container, typename Index> // final
auto // C++11
authAndAccess(Container&& c, Index i) // version
-> decltype(std::forward<Container>(c)[i])
{
authenticateUser();
return std::forward<Container>(c)[i];
}
```

另外一个容易被你挑刺的地方是我在本条款开头的那句话：` decltype` 几乎所有时候都会输出你所期望的类型，但是有时候它的输出也会令你吃惊。诚实的讲，你不太可能遇到这种以外，除非你是一个重型库的实现人员。

为了彻底的理解 `decltype` 的行为，你必须使你自己对一些特殊情况比较熟悉。这些特殊情况太晦涩难懂，以至于很少有书会像本书一样讨论，但是同时也可以增加我们对 `decltype `的认识。

对一个变量名使用 `decltype `得到这个变量名的声明类型。变量名属于左值表达式，但这并不影响 `decltype` 的行为。然而，对于一个比变量名更复杂的左值表达式， `decltype` 保证返回的类型是左值引用。因此说，如果一个非变量名的类型为 `T `的左值表达式， `decltype` 报告的类型是 `T&` 。这很少产生什么影响，因为绝大部分左值表达式的类型有内在的左值引用修饰符。例如，需要返回左值的函数返回的总是左值引用。

这种行为的意义是值得我们注意的。但是在下面这个语句中

```cpp
int x = 0;
```

`x` 是一个变量名，因此 `decltyper(x) `是 `int `。但是如果给 `x `加上括号`(x)`就得到一个比变量名复杂的表达式。作为变量名，` x` 是一个左值，同时 C++ 定义表达式` (x) `也是左值。因此 `decltype((x))` 是 `int&` 。给一个变量名加上括号会改变 `decltype` 返回的类型。

在 C++11 中，这仅仅是个好奇的探索，但是和 C++14 中对 `decltype(auto)` 支持相结合，函数中返回语句的一个细小改变会影响对这个函数的推导类型。

```cpp
decltype(auto) f1()
{
int x = 0;
...
return x; // decltype(x) is int, so f1 returns int
}
decltype(auto) f2()
{
int x = 0;
return (x); // decltype((x)) is int&, so f2 return int&
}
```

`f2` 不仅返回值类型与 `f1 `不同，它返回的是对一个局部变量的引用。这种类型的代码将把你带上一个为定义行为的快速列车-你完全不想登上的列车。

最主要的经验教训就是当使用 `decltype(auto)` 时要多留心一些。被推导的表达式中看上去无关紧要的细节都可能影响`decltype `返回的类型。为了保证推导出的类型是你所期望的，请使用条款4中的技术。

同时不能更大视角上的认识。当然， `decltype` （无论只有 `decltype` 或者还是和 `auto` 联合使用）有可能偶尔会产生类型推导的惊奇行为，但是这不是常见的情况。一般情况下， `decltype` 会产生你期望的类型。将 `decltype` 应用于变量名无非是正确的，因为在这种情况下， `decltype` 做的就是报告这个变量名的声明类型。

### 总结

- `decltype` 几乎总是得到一个变量或表达式的类型而不需要任何修改
- 对于非变量名的类型为 `T` 的左值表达式， `decltype` 总是返回 `T&`
- C++14 支持 `decltype(auto) `，它的行为就像 `auto` ,从初始化操作来推导类型，但是它推导类型时使用 `decltype` 的规则

## 查看类型推导

