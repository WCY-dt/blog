---
layout: post
title:  "【数据结构】B-Tree <img src='https://img.shields.io/badge/-原创-019733?style=flat'>"
date:   2020-02-15 00:00:00 +0800
categories: A&DS
tags: 数据结构 算法 B-Tree
comments: 1
mathjax: true
---

本文为数据结构系列第二篇，主要介绍<mark>B-Tree</mark>。

# B-Tree

## 定义

B树是一种平衡的多分树，通常我们说$m$阶的B树，它必须满足如下条件： 

- 每个节点最多只有$m$个子节点。
- 每个非叶子节点（除了根）具有至少$\frac{m}{2}$个子节点。
- 如果根不是叶节点，则根至少有两个子节点。
- 具有*k*个子节点的非叶节点包含$k -1$个键。
- 所有叶子都出现在同一水平，没有任何信息（高度一致）。

### B树的阶

B树中一个节点的子节点数目的最大值，用$m$表示，假如最大值为$10$，则为$10$阶，如图

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727111522935-981534929.png)

所有节点中，节点`13,16,19`拥有的子节点数目最多，四个子节点（灰色节点），所以可以定义上面的图片为4阶B树，现在懂什么是阶了吧

### 根节点

节点`10`即为根节点，特征：根节点拥有的子节点数量的上限和内部节点相同，如果根节点不是树中唯一节点的话，至少有俩个子节点（不然就变成单支了）。在$m$阶B树中（根节点非树中唯一节点），那么有关系式$2\leq M\leq m$，$M$为子节点数量；包含的元素数量 $1\leq K\leq m-1$,$K$为元素数量。

### 内部节点

节点`13,16,19`、节点`3,6`都为内部节点，特征：内部节点是除叶子节点和根节点之外的所有节点，拥有父节点和子节点。假定$m$阶B树的内部节点的子节点数量为$M$，则一定要符合$\frac{m}{2}\leq M \leq m$关系式，包含元素数量$M-1$；包含的元素数量 $\frac{m}{2}-1\leq K \leq m-1$,$K$为元素数量。$\frac{m}{2}$向上取整。

### 叶子节点

节点`1,2`、节点`11,12`等最后一层都为叶子节点，叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。特征：在$m$阶B树中叶子节点的元素符合$\frac{m}{2}-1\leq K \leq m-1$。

### 高度

一棵含有$N$个总关键字数的$m$阶的B树的最大高度是$\log_{\frac{m}{2}}{\frac{N+1}{2}} + 1$

## 插入

针对$m$阶高度$h$的B树，插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。

- 若该节点元素个数小于$m-1$，直接插入；
- 若该节点元素个数等于$m-1$，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；
- 重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加$1$；

上面三段话为插入动作的核心，接下来以$5$阶B树为例，详细讲解插入的动作；

$5$阶B树关键点:

- $2\leq$根节点子节点个数$\leq5$
- $3\leq$内节点子节点个数$\leq5$
- $1\leq$根节点元素个数$\leq4$
- $2\leq$非根节点元素个数$\leq4$

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727135621105-1688663582.png)   $\stackrel{插入8}{\longrightarrow}$     ![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150240628-562673561.png)

图（1）插入元素`8`后变为图（2），此时根节点元素个数为$5$，不符合$1\leq$根节点元素个数$\leq4$，进行分裂（真实情况是先分裂，然后插入元素，这里是为了直观而先插入元素，下面的操作都一样，不再赘述），取节点中间元素`7`，加入到父节点，左右分裂为$2$个节点，如图（3）

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150127189-82041957.png)

接着插入元素`5`，`11`，`17`时，不需要任何分裂操作，如图（4）

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150529778-12220622.png)

插入元素`13`

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150325549-653814900.png)

节点元素超出最大数量，进行分裂，提取中间元素`13`，插入到父节点当中，如图（6）

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150403812-1196185160.png)

 接着插入元素`6`，`12`，`20`，`23`时，不需要任何分裂操作，如图（7）

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727151202374-95300359.png)

插入`26`时，最右的叶子结点空间满了，需要进行分裂操作，中间元素`20`上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在$2$个关键字元素。

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727152815688-1828133575.png)

 

插入`4`时，导致最左边的叶子结点被分裂，`4`恰好也是中间元素，上移到父节点中，然后元素`16`,`18`,`24`,`25`陆续插入不需要任何分裂操作

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727153234424-288986187.png)

最后，当插入`19`时，含有`14`,`16`,`17`,`18`的结点需要分裂，把中间元素`17`上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素`13`上移到新形成的根结点中，这样具体插入操作的完成。

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727154112560-585266052.png)

## 删除

首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除。

- 某结点中元素数目小于$\lceil\frac{m}{2}\rceil-1$,则需要看其某相邻兄弟结点是否丰满；
- 如果丰满（结点中元素个数大于$\lceil\frac{m}{2}\rceil-1$），则向父节点借一个元素来满足条件；
- 如果其相邻兄弟都不丰满，即其结点数目等于$\lceil\frac{m}{2}\rceil-1$，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；

接下来还以$5$阶B树为例，详细讲解删除的动作；

- 关键要领，元素个数小于 $2\left(\frac{m}{2}-1\right)$就合并，大于$4\left(m-1\right)$就分裂

如图依次删除依次删除`8`,`20`,`18`,`5`

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727160351637-1629033369.png)

首先删除元素`8`，当然首先查找`8`，`8`在一个叶子结点中，删除后该叶子结点元素个数为2，符合B树规则，操作很简单，咱们只需要移动`11`至原来`8`的位置，移动`12`至`11`的位置（也就是结点中删除元素后面的元素向前移动）

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727160902710-1900336278.png)

 下一步，删除`20`,因为`20`没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者`23`(字母升序的下个元素)，将`23`上移到`20`的位置，然后将孩子结点中的`23`进行删除，这里恰好删除后，该孩子结点中元素个数大于$2$，无需进行合并操作。

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727161905571-1441211802.png)

下一步删除`18`，`18`在叶子结点中,但是该结点中元素数目为$2$，删除导致只有$1$个元素，已经小于最小元素数目$2$,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于$\lceil\frac{5}{2}\rceil-1=2$），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（$3$个元素大于$2$），所以先向父节点借一个元素`23`下移到该叶子结点中，代替原来`19`的位置，`19`前移；然`24`在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除`24`，后面元素前移。

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727162837714-1263711630.png)

最后一步删除`5`， 删除后会导致很多问题，因为`5`所在的结点数目刚好达标，刚好满足最小元素个数（$\lceil\frac{5}{2}\rceil-1=2$）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素`4`下移到已经删除`5`而只有`6`的结点中，然后将含有`4`和`6`的结点和含有`1`,`3`的相邻兄弟结点进行合并成一个结点。

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727163249830-1144020179.png)

也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素`7`，没达标（因为非根节点包括叶子结点的元素$K$必须满足于$2\leq K\leq4$，而此处的$K=1$），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。而此时兄弟节点元素刚好为$2$，刚刚满足，只能进行合并，而根结点中的唯一元素`13`下移到子结点，这样，树的高度减少一层。

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190727163912012-1560407429.png)

# B+Tree

 　B+树是应文件系统所需而产生的B树的变形树，那么可能一定会想到，既然有了B树，又出一个B+树，那B+树必然是有很多优点的

## 特征

- 有$m$个子树的中间节点包含有$m$个元素（B树中是$k-1$个元素），每个元素不保存数据，只用来索引；
- 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)；
- 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)；

## B+树对比B树优点

- B+树的磁盘读写代价更低
  B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；
- B+树查询效率更加稳定
  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；
- B+树便于范围查询（最重要的原因，范围查找是数据库的常态）
  B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低

B+树如下：

![img](https://img2018.cnblogs.com/blog/997909/201907/997909-20190728114240297-169990922.png)

