---
layout: post
title:  "【python】Pandas"
date:   2020-03-03 00:00:00 +0800
categories: toturial
tags: python pandas
comments: 1
mathjax: true
---

<mark>pandas</mark>是一种Python数据分析的利器，是一个开源的数据分析包，最初是应用于金融数据分析工具而开发出来的，因此pandas为时间序列分析提供了很好的支持。pandas是PyData项目的一部分。

pandas中主要有两种数据结构，分别是：`Series`和`DataFrame`。

- **`Series`**：一种类似于一维数组的对象，是由一组数据(各种NumPy数据类型)以及一组与之相关的数据标签(即索引)组成。仅由一组数据也可产生简单的Series对象。注意：Series中的索引值是可以重复的。
- **`DataFrame`**：一个表格型的数据结构，包含有一组有序的列，每列可以是不同的值类型(数值、字符串、布尔型等)，DataFrame即有行索引也有列索引，可以被看做是由Series组成的字典。

# `Series`

## `Series`属性

常见属性有**`values`**（获取值）、**`index`**（获得索引值）、**`dtype`**（获得类型）

```python
import pandas as pd
import numpy as np
# SERIES属性
print('值',ser01.values)
print('索引值',ser01.index)
print('类型',ser01.dtype)
ser01 = pd.Series([1,2,3,4,5])
ser01
```

```
值 [1 2 3 4 5]
索引值 RangeIndex(start=0, stop=5, step=1)
类型 int64

0    1
1    2
2    3
3    4
4    5
dtype: int64
```

## 利用`series`创建一个二维数组

```python
# 利用series创建一个二维数组
ser02=pd.Series(np.array([[1,2,3,4],[1,2,3,4,5]]))  
# 表示将numpy里array创建多维数组的方法，嵌套到series里，创建多维数组
print('值',ser02.values)
print('索引值',ser02.index)
print('类型',ser02.dtype)
ser02
```

```
值 [list([1, 2, 3, 4]) list([1, 2, 3, 4, 5])]
索引值 RangeIndex(start=0, stop=2, step=1)
类型 object

0       [1, 2, 3, 4]
1    [1, 2, 3, 4, 5]
dtype: object
```

## 为索引`index`起名称

`ser03=pd.Series([100,22,99,66])`

- `ser03`打点调用`index`方法
  - `.index=[‘数学’,‘英语’,‘语文’,‘综合’]`改写方便，数据可读性，可维护性
  - `.index=[u’数学’,u’英语’,u’语文’,u’综合’]` u其实是series里面的一个标识符关键字，和索引的位置一样—大量使用
- 直接一步写完
  - `ser04=pd.Series(data=[100,22,99,66],dtype=np.float64,index=[‘数学’,‘英语’,‘语文’,‘综合’])`

```python
# 为索引index起个名称
ser03=pd.Series([100,22,99,66]) 
# ser03.index=['数学','英语','语文','综合']  # 改写方便，数据可读性，可维护性
ser03.index=[u'数学',u'英语',u'语文',u'综合'] 
 # u其实是series里面的一个标识符关键字，和索引的位置一样---大量使用
print('ser03')
print(ser03)
print()
# 企业另一种写法
ser04=pd.Series(data=[100,22,99,66],dtype=np.float64,index=['数学','英语','语文','综合'])
print('ser04')
print(ser04)
```

```
ser03
数学    100
英语     22
语文     99
综合     66
dtype: int64

ser04
数学    100.0
英语     22.0
语文     99.0
综合     66.0
dtype: float64
```

- `series`通过下标`index`获取值，并且`Series`是创建

- pandas里下标索引一般叫数据标签，是在AI、python数据分析、大数据、数据挖掘里获取数据集的核心标签。数据标签不分数据大小，可获得1行数据也可以获得海量数据。

- 因为`series`只能创建一维数组，如果要创建二维数组，必须导入`numpy`模块，利用`np.array`（多维数组）形成维度空间-矩阵

- `ser04=pd.Series(date=[100,22,99,66],dtype=np.float64,index=[‘数学’,‘英语’,‘语文’,‘综合’]) # series`有4个参数，`data`是数据 `dtype`类型根据项目要求定义数据类型，`series`默认是整型，`index`直接赋值。

  > 不建议将data和index分开写，建议使用上述方法。

## 通过字典方式创建`series`多维数组

```python
import pandas as pd
import numpy as np
# 通过字典方式创建series多维数组
dict01=({'1001':'张三','1002':'李四','1003':'王麻子'})  # 字典存放键值对-通过key取值
ser06=pd.Series(dict01)  # 将字典数据传到series中，形成矩阵
ser06

print('字典创建的值：',ser06.values)
print('字典创建的索引：',ser06.index)
```

```
字典创建的值： ['张三' '李四' '王麻子']
字典创建的索引： Index(['1001', '1002', '1003'], dtype='object')
```

## 获取`series`值的方法

- 通过方括号+索引的方式读取对应索引的数据，有可能返回多条数据
- 通过方括号+下标值的方式读取对应下标值的数据，下标值的取值范围为：`(0，len(Series.values))`；另外下标值也可以是负数，表示从右往左获取数据
- 通过`numpy`的`ndarray`的切片机制
  `series`获取多个值得方法类似`numpy`的`bdarray`切片操作,通过[]+下标值/索引值+冒号`:`的形式获取series对象的一部分
  `ser.index=[""""""] print(ser[0:2])` 通过切片可以获取维度，矩阵的值！
- 切片的两种操作：

1. `print(ser01[0:2])`通过下标值

```python
# 方括号+下标值
ser07=pd.Series(['A','B','C','D'])
# ser07(0)
#  'Series' object is not callable
ser07[0]
```

```
'A'
```

    2. `print(ser01[‘a’:‘c’])`通过索引值

```python
# 方括号+索引
ser08=pd.Series(['A','B','C','D'])
ser08.index=(['a','b','c','d'])    
ser08['a']
```

```
'A'
```

通过numpy的ndarray的切片机制

```python
ser09=pd.Series(['A','B','C','D'])
ser09.index=(['a','b','c','d']) 
# 通过下标值
print(ser09[0:2])
# 通过索引值
print(ser09['a':'c'])
```

```
a    A
b    B
dtype: object
a    A
b    B
c    C
dtype: object
```

## `Series`的运算

`NumPy`中的数组运算，在`Series`中都保留了，均可以使用，并且`Series`进行数组运算的时候，索引与值之间的映射关系不会发生改变。

```python
ser=pd.Series({
    '201612348':1000,
    '201612347':999,
    '201612346':666,
    '201612345':555
})
print(ser)
print('------------->----------')
print(ser[ser>666])
print('-------------/----------')
print(ser/10)
print('-------------+----------')
print(ser+1)
print('------------------------')
ser01=pd.Series([-1,-2,-3,-4])
print(ser01)
print('-------指数函数-------')
print(np.exp(ser01))
print('-------绝对值---------')
print(np.fabs(ser01))
```

```
201612348    1000
201612347     999
201612346     666
201612345     555
dtype: int64
------------->----------
201612348    1000
201612347     999
dtype: int64
-------------/----------
201612348    100.0
201612347     99.9
201612346     66.6
201612345     55.5
dtype: float64
-------------+----------
201612348    1001
201612347    1000
201612346     667
201612345     556
dtype: int64
------------------------
0   -1
1   -2
2   -3
3   -4
dtype: int64
-------指数函数-------
0    0.367879
1    0.135335
2    0.049787
3    0.018316
dtype: float64
-------绝对值---------
0    1.0
1    2.0
2    3.0
3    4.0
dtype: float64
```

## `Series`缺失值检测

- 什么是缺失值？
  没有被赋值
- 确实和不赋值的区别：
  - 不赋值: 空指针异常
  - 缺失: 程序不会报空指针异常，也不会报程序异常，会用`NaN`填充
- `isnull`和`notnul`这两个函数可以用在`Series`中检查缺失值，这两个函数的返回是一个布尔类型的`Series`
  - `snull `表示字典里有缺失值的判断，有缺失值返回`true`反之`false` 返回的是`bool`类型
  - `notnull` 表示字典里有缺失值的判断，有缺失值返回`false`反之`true` 返回的是`bool`类型
- 缺失值检测

```python
# 缺失值检测
ser16=pd.Series({'1001':'a','1002':'b','1003':'c'})
ser16
ser17=pd.Series(ser16,index=['1001','1002','1008'])
ser17
```

```
1001      a
1002      b
1008    NaN
dtype: object
```

- `isnull`和`notnul`

```python
ser16=pd.Series({'1001':'a','1002':'b','1003':'c'})
ser16
ser17=pd.Series(ser16,index=['1001','1002','1008'])
ser17
# isnull
pd.isnull(ser17)  
# notnull
pd.notnull(ser17) 
```

```
1001    False
1002    False
1008     True
dtype: bool
1001   True
1002    True
1008     False
dtype: bool
```

## Series自动对齐

当多个`series`对象之间进行运算的时候，如果不同`series`之间具有不同的索引值，那么运算会自动对齐不同索引值的数据，如果某个`series`没有某个索引值，那么最终结果会赋值为`NaN`。

1. 自动对齐是基于一个列表元素或者多维数据的–矩阵/矩阵乘积
2. 原理：通过`Series`自动匹配`index`所对应的值，有匹配的值和`index`，按照原数据打印数据！如果对应位置没有`index`值，那么用`NAN`填充。—数据的安全、易维护。

- 顺序不同

```python
# 顺序不同
ser18=pd.Series([1,2,3,4],index=['a','b','c','d'])
ser18
ser19=pd.Series([10,20,30,40],index=['d','c','b','a'])
ser18+ser19
```

```
a    41
b    32
c    23
d    14
dtype: int64
```

- 没有某个索引值

```python
# 没有某个索引值
ser20=pd.Series([1,2,3,4],index=['a','b','c','d'])
ser20
ser21=pd.Series([10,20,30,40],index=['d','c','b','f'])
ser20+ser21
```

```
a     NaN
b    32.0
c    23.0
d    14.0
f     NaN
dtype: float64
```

## Series及其索引的name属性

`Series`对象本身以及索引都具有一个`name`属性，默认为空，根据需要可以进行赋值操作。

`ser22=pd.Series({‘1001’:‘a’,‘1002’:‘b’,‘1003’:‘c’})`

1. `ser22.name=‘字母’`直接调用`name`不方便数据阅读，不利于程序员去解析数据！不建议
2. `ser22.index.name=‘小写字母’`利用`index`索引充当列名称，键`key`对应的是`index`，`index`属性的值在第一位置第一列就是一个数据的`title`，所以阅读清晰，数据解析很明确。

```python
# series的name属性
ser22=pd.Series({'1001':'a','1002':'b','1003':'c'})
ser22.name='字母'
ser22.index.name='小写字母'
print(ser22)
```

```
小写字母
1001    a
1002    b
1003    c
Name: 字母, dtype: object
```

# `DataFrame`

## 通过二维数组创建

```python
df01=pd.DataFrame([['tony','marry','tom'],[18,20,25]])
print(df01)
```

```
      0      1    2
0  tony  marry  tom
1    18     20   25
```

```
arr=np.array([
    ['小雪',16],
    ['刘星',12],
    ['夏东海',35]
])
df02=pd.DataFrame(arr,index=['one','two','three'],columns=['name','age'])
print(df02)
print('值：',df02.values)
print('index:',df02.index)
```

```
      name age
one     小雪  16
two     刘星  12
three  夏东海  35
值： [['小雪' '16']
 ['刘星' '12']
 ['夏东海' '35']]
index: Index(['one', 'two', 'three'], dtype='object')
```

## 通过字典创建

```python
data={
    'apart':['101','102','103','104'],
    'month':['8月','9月','12月','6月'],
    'year':[2000,1999,2019,1998],
    'age':[18,20,15,23]
}
df03=pd.DataFrame(data)
# 重置index的值
df03.index=['01','02','03','04']
print(df03)
```

```
   apart month  year  age
01   101    8月  2000   18
02   102    9月  1999   20
03   103   12月  2019   15
04   104    6月  1998   23
```

# 索引对象

- 定义：索引对象就是不直接操作index，而是将index通过其他数据标签及逆行操作数据的完整过程！数据完全可以读写操作！

索引对象也可以利用面向对象对象思想理解–万物皆为对象–可以利用任何数据标签充当index操作数据。不管是Series还是DataFrame对象，都有索引对象。

- 数据抓取方式：
  - 列
    - 直接通过列索引获取制定列的数据。 `df04.名称 df04[‘名称’]`
    - 添加数据给列–原始数据几条就匹配添加几条。新添加的多了报数据大小不匹配。`df[‘名称’]=[值]`
    - 删除数据，利用`pop`函数 `df06.pop(‘名称’)`
    - 修改列数据，直接通过字段名称赋值修改。`df[‘名称’]=[值]`
  - 行
    - 通过`ix`获取行数据
    - 通过`loc`获取 `df.loc[] df.loc[0,’’]==df.loc[0][’’]`
    - 添加行 `df.ix[]=[] df.loc[]=[]`
    - 修改行 `df.ix[]=[] df.loc[]=[]`

不管是`ix` ` loc` 都是通过`index`取值

## 抓取列数据

- 获取列数据

```python
# 抓取列数据
df04=pd.DataFrame([['tom',22],['marry',18],['tony',20]],columns=['姓名','成绩'])
print(df04)
print()
print(df04.姓名) # 等价于df04['姓名']
```

```
      姓名  成绩
0    tom  22
1  marry  18
2   tony  20

0      tom
1    marry
2     tony
Name: 姓名, dtype: object
```

- 添加列数据

```python
df05=pd.DataFrame([['tom',22],['marry',18],['tony',20]],columns=['姓名','成绩'])
# 添加列数据
df05['性别']=['男','女','男']
df05
```

```
  姓名  成绩 性别
0    tom  22  男
1  marry  18  女
2   tony  20  男
```

- 删除列数据

```python
df06=pd.DataFrame([['tom',22],['marry',18],['tony',20]],columns=['姓名','成绩'])
print(df06)
# 删除列数据
df06.pop('成绩')
print(df06)
```

```
      姓名  成绩
0    tom  22
1  marry  18
2   tony  20
      姓名
0    tom
1  marry
2   tony
```

- 修改列数据

```python
df07=pd.DataFrame([['tom',22],['marry',18],['tony',20]],columns=['姓名','成绩'])
# 修改列数据
df07['成绩']=[99,88,100]
print(df07)
```

```
      姓名   成绩
0    tom   99
1  marry   88
2   tony  100
```

## 抓取行数据

- 获取行数据

```python
df08=pd.DataFrame([['tom',22],['marry',18],['tony',20]],columns=['姓名','成绩'])
# 获取行数据
print('ix:',df08.ix[0])
print('loc:',df08.loc[1])
```

```
ix: 姓名    tom
成绩     22
Name: 0, dtype: object
loc: 姓名    marry
成绩       18
Name: 1, dtype: object
```

- 添加行数据

```python
df08=pd.DataFrame([['tom',22],['marry',18],['tony',20]],columns=['姓名','成绩'])
# 添加行
df08.ix[3]=['bob',10]
print(df08)
df08.loc[4]=['gun',100]
print(df08)
```

```
      姓名  成绩
0    tom  22
1  marry  18
2   tony  20
3    bob  10
      姓名   成绩
0    tom   22
1  marry   18
2   tony   20
3    bob   10
4    gun  100
```

- 修改行数据

```python
# 修改行
df08=pd.DataFrame([['tom',22],['marry',18],['tony',20]],columns=['姓名','成绩'])
df08.loc[4]=['Gun',100]
print(df08)
```

```
      姓名   成绩
0    tom   22
1  marry   18
2   tony   20
3    bob   10
4    Gun  100
```
