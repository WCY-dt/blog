---
layout: post
title:  "【C++】异常"
date:   2021-01-15 00:00:00 +0800
categories: toturial
tags: C++ 异常
comments: 1
mathjax: true
copyrights: 转载
---

本文主要介绍 golang 的并发。

# goroutine

golang 的并发是通过多个 goroutine 实现的，我们可以简单的把每个 goroutine 理解为一个线程——虽然 goroutine 比线程要小。

goroutine 在单核 CPU 上表现为并发，在多核 CPU 上则表现为并行，二者在写 golang 时，不需要区别考虑。

使用 goroutine 时，在需要并发的语句前加上关键词 `go`。通常，我们有 3 中方法使用 goroutine：

```go
// 直接调用函数
go functionName(params);

// 调用匿名函数
go func(params) {
    // some code...
}(values)

// 直接执行代码块
go {
    // some code...
}
```

然而，如果你试着取运行几个程序，你会发现并发并没有提高多少效率。这很大一部分原因是因为 golang 不太聪明，往往会把所有 goroutine 塞到同一个 CPU 核上执行。我们需要手动让它们分开。

在这之前，我们可以先看一下自己的电脑/服务器有多少核：

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	cpuNum := runtime.NumCPU() //获得当前设备的 CPU 核心数
	fmt.Println("CPU 核心数:", cpuNum)
}
```

然后使用下面的语句调整并发所占资源数：

```go
runtime.GOMAXPROCS(runtime.NumCPU()) // runtime.NumCPU() 可以改为想要的 CPU 核数
```

# 竞态

我们看看 golang 是如何处理并发竞争的。下面是一个有竞争的程序：

```go
var (
	count int64
	wg    sync.WaitGroup
)

func main() {
	wg.Add(3)
	go incCount()
	go incCount()
	go incCount()
	wg.Wait()
	fmt.Println(count)
}
func incCount() {
	defer wg.Done()
	for i := 0; i < 2; i++ {
		value := count
		runtime.Gosched()
		value++
		count = value
	}
}
```

不出意外的话，程序的运行结果会是 4 或者 6。这是因为我们没有对 count 的值进行读写保护，有可能一个 goroutine 在读取的时候，另一个正在修改。

修改这一错误很简单，我们只需要让加一这个操作成为⚛原子操作即可：

```go
func incCount() {
	defer wg.Done()
	for i := 0; i < 2; i++ {
		atomic.AddInt64(&count, 1) // 原子的加法
		runtime.Gosched()
	}
}
```

除了加法外，golang 还提供了其它原子函数，例如用于读取的 `LoadInt64` 和用于写入的 `StoreInt64`。

我们也可以使用互斥锁来实现这一功能：

```go
func incCounter(id int) {
    defer wg.Done()
    for count := 0; count < 2; count++ {
        mutex.Lock()
        {
            value := counter
            runtime.Gosched()
            value++
            counter = value
        }
        mutex.Unlock()
    }
}
```

# channel

在并发代码块运行过程中，代码块与主程序、代码块与代码块之间需要进行通信。goroutine 使用 channel 实现通信。

需要注意的是，channel 只能在单个进程内通信（简单理解就是同一个程序），而跨进程则需要使用通信协议来实现。

channel 的关键词为 `chan`。channel 是类型相关的，换句话说，就是定义一个 channel 只能传递同一种类型的值。我们通常会这样定义：

```go
c1 := make(chan int) // int 类型的 channel
c2 := make(chan string) // string 类型的 channel
c3 := make(chan interface{}) // 接口类型的 channel
```

从语言底层支持 channel 是对并发编程的巨大帮助。以前在 C++ 中我们写并发时，如果遇到竞争，则需要使用 `mutex`、`promise` 之类的玩意儿。小型程序还好，如果遇到大型工程，漫天都是绕来绕去的互斥锁，想想就可怕。

channel 的收发均使用 `<-` 操作符。例如：

```go
func main() {
	ch := make(chan interface{})

	go func() {
		ch <- 0       // 将整数放入通道中
		ch <- "hello" // 将字符串放入通道中
	}()

	intData := <-ch    // 从通道中取出整数
	stringData := <-ch // 从通道中取出字符串
}
```

通道每次可以取出一个值。如果取出的值不需要，则可以直接扔掉：

```go
go func() {
    ch <- 0
}()

<-ch // 扔掉
```

需要注意的是，channel 的发送是阻塞式的，如果里面有东西一直没被接收，则发送方就无法继续执行，引起程序报错。

而对于接收则有阻塞与非阻塞两种方式：

```go
data := <-ch     // 阻塞
data, ok := <-ch // 非阻塞，ok 代表是否接收到了数据，若没有，则 data 为 channel 类型的 0
```

同时，我们也可以在循环中接收

```go
for data := range ch {
    // deal with data
}
```

以上所说的通道都是双向的。我们也可以定义单向通道：

```go
// 方法1
ch := make(chan int)
var chSend chan<- int = ch // 仅写
var chRecv <-chan int = ch // 仅读

// 方法2
ch1 := make(chan<- int) // 仅写
ch2 := make(<-chan int) // 仅读
```

方法 2 是没有意义的，因为它们要么不能读，要么不能写，无法实现任何目的。

对于用完的通道，我们可以将其关闭：

```go
close(ch)
```

我们上面提到，channel 对于发送方来说是阻塞的，这是因为，默认的 channel 没有缓冲。由于 channel 不能存储任何数据，因此当发送方准备好发送时，需要接收方也准备好，才能正常交接数据。

如果需要 channel 存储数据——即带有缓冲区，则需要在定义时指明缓冲区大小

```go
ch := make(chan int, 3) // 可以存储 3 个值

ch <- 1
ch <- 2

fmt.Println(len(ch)) // 查看当前通道的大小
```

程序不会像之前那样报错，且会输出 2，表明缓冲区里有 2 个值。

# select

我们常常利用 select 来判断通道超时。通常的结构是这样的：

```go
ch := make(chan int)
quit := make(chan bool)

go func() {
    for {
        select {
        case num := <-ch:
            fmt.Println("num = ", num)
        case <-time.After(3 * time.Second):
            fmt.Println("超时")
            quit <- true
        }
    }
}()
}
```

类似的手段也可以实现 channel 的多路复用。

