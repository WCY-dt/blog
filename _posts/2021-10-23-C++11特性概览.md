---
layout: post
title:  "C++11 特性概览"
date:   2021-10-23 00:00:00 +0800
categories: toturial
tags: C++ 异常
comments: 1
mathjax: true
copyrights: 原创
---

最近翻阅 C++ 标准时发现了不少少见但在某些情况下很实用的 C++ 11/14/17 标准。于是决定从头整理一下这些标准。

# = default

我们知道，如果一个类重载了构造函数，那么它将不再提供默认构造函数。如果我们需要保留默认构造函数，通常可以直接写一个。例如

```cpp
class ClassDefault{
    ClassDefault(){}
    ClassDefault(int num){/* some codes*/}
}
```

在 C++11 中，我们可以使用 `default` 来代替

```cpp
class ClassDefault{
    ClassDefault() = default;
    ClassDefault(int num){/* some codes*/}
}
```

嗯……好像要敲的字母变多了……

同样的，析构函数、拷贝构造函数也可以使用 `default`。

与其他函数一样，如果这个 `default` 出现在类的内部，则是内联的；否则不是内联的。

# = delete

我们可以将拷贝构造函数和拷贝赋值运算符后加上 `= delete` 来阻止拷贝。也就是说，不允许编译器默认生成拷贝构造函数和拷贝赋值运算符。例如

```cpp
class ClassDelete{
    ClassDelete() = default;
    ClassDelete(const ClassDelete&) = delete;
    ClassDelete &operator=(const ClassDelete&) = delete;
    ~ClassDelete() = default;
}
```

`delete` 只能出现在第一次声明时。

值得注意的是，析构函数不应被 `delete`，否则只能使用指针动态分配对象，且该对象不能被释放。

# auto

auto 是使用频率比较高的一个关键字。我们认为未来的 C++ 应该是这样的（bushi）

```cpp
auto auto(auto auto){
    auto auto=auto;
    for (auto auto=auto;auto;auto){
        auto.auto=auto;
    }
    return auto;
}
```

`auto` 定义变量时，必须要有初始值，否则将无法确定变量类型。在定义多个变量时，以第一个的类型为准。

```cpp
auto i = 0, *p = &i; // auto 推断为整数类型
```

值得注意到是，`auto` 常常会忽视 const 特性，所以在定义变量并赋值时，应当主动加上 const 而不是依赖原变量的 const

```cpp
const int i = 0;
const auto j = i;
```

# decltype

讲到 `auto` 就必然要提到 `decltype`。如果我们希望使用某个表达式的类型去定义另外的变量或函数，我们可以

```cpp
decltype(f()) sum = x;
```

在上面的过程中，编译器只会分析 f 的返回值类型，而不会真正执行 f。

与 `auto` 不同的是，`decltype` 返回的类型会包含 const。

如果推断的是一个指针，则得到的类型为引用

```cpp
int *p = &i;
decltype(*p) a = b; // a 的类型为 int&
```

对于一个变量或者表达式，如果在外层加了括号（也就是最外层出现了双层括号），就会被认为是引用

```cpp
decltype((i)) a; // 大错特错，a 的类型为引用
```

# constexpr

如果你认为某个表达式的值为常量，则可以加上 `constexpr`。如果不是也没有关系，编译器会逐个检查声明为 `constexpr` 的量。

```cpp
constexpr int a = 0; // 常量
constexpr int b = a + 1; // 常量
constexpr int c = size(); // 非常量
```

`constexpr` 也可以修饰函数。具体用法和 const 修饰函数基本相同，不再赘述。

