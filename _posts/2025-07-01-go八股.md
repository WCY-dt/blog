---
layout: post
title: "Go 八股文"
date: 2025-07-01 23:00:00 +0800
categories: 编程
tags: go
summary: "Go 八股文"
comments: true
copyrights: 原创
draft: true
---

本文基于 [Go 1.25](https://github.com/golang/go/tree/release-branch.go1.25) 进行分析和探讨。

## 数据结构

### 数组

Go 语言中，数组的定义有这样几种方式：

```go
var a0 [3]int                    // 长度为 3, 元素全部为 0
var a1 = [...]int{1, 2, 3}       // 长度为 3, 元素为 1, 2, 3
var a2 = [...]int{2: 3, 1: 2}    // 长度为 3, 元素为 0, 2, 3
var a3 = [...]int{1, 2, 4: 5, 6} // 长度为 6, 元素为 1, 2, 0, 0, 5, 6
```

数组的遍历方式有三种：

```go
for i := 0; i < len(a); i++ {
    fmt.Printf("a[%d]: %d\n", i, a[i])
}
for i, v := range a {
    fmt.Printf("a[%d]: %d\n", i, v)
}
for i := range a {
    fmt.Printf("a[%d]: %d\n", i, a[i])
}
```

Go 语言的数组：

- 具有固定长度，一旦定义，其长度不可改变

- 是值类型，赋值或传递时会复制整个数组。因此，函数中修改参数的数组不会影响原数组

  但如果数组存储的元素是引用类型（如切片、映射、指针等），赋值或传递时复制的是元素的引用，​元素本身并未被复制

- 对于指向数组的指针，可以自动解引用，能够正常数组一样访问和迭代：

  ```go
  var p *[3]int = &a
  fmt.Println("p[0]:", (*p)[0]) // 访问第一个元素
  for i, v := range p {
      fmt.Printf("p[%d]: %d\n", i, v) // 迭代数组
  }
  ```

- 数组长度可以为 0，此时不占用内存。常用来循环固定次数：

  ```go
  var emptyArray [20][0]int
  for range emptyArray {
      fmt.Println("This will run 20 times")
  }
  ```

### 切片

切片可以看作是动态数组，它由一个切片头（slice header）和底层数组两部分组成。切片头包含：

- 指向底层数组的指针（`ptr`）

- 切片的长度（`len`）

- 切片的容量（`cap`）

  容量取决于总的可用空间，通常为起始索引位置到底层数组末尾​可容纳​的元素数量

底层数组则是实际存储数据的地方。

Go 语言中，切片的定义有这样几种方式：

```go
var s0 []int               // len=0，cap=0，[], 与 nil 相等，底层数组未分配
var s1 = []int{}           // len=0，cap=0，[], 与 nil 不相等
var s2 = []int{1, 2, 3}    // len=3，cap=3，[1, 2, 3]
var s3 = s2[:2]            // len=2，cap=3，[1, 2]
var s4 = s2[0:2:cap(s3)]   // len=2，cap=3，[1, 2]
var s5 = s2[:0]            // len=0，cap=3，[]
var s6 = s2[1:2]           // len=1，cap=2，[2]
var s7 = make([]int, 3)    // len=3，cap=3，[0, 0, 0]
var s8 = make([]int, 3, 5) // len=3，cap=5，[0, 0, 0]
var s9 = make([]int, 0, 3) // len=0，cap=3，[]
```

- 切片追加元素使用 `append` 函数：

  ```go
  s = append(s, 1)                // 添加一个元素 1
  s = append(s, 2, 3)             // 添加多个元素 2 和 3
  s = append(s, []int{4, 5}...)   // 添加一个解包后的切片
  s = append([]int{-1}, s...)     // 在头部添加元素 -1
  s = append([]int{-3, -2}, s...) // 在头部添加多个元素 -3 和 -2
  ```

  尽管 `append` 函数会返回一个新的切片，但它会尽量复用原有切片的底层数组，以提高性能。当原有切片的容量不足以容纳新元素时，`append` 会分配一个新的底层数组，并将原有元素复制到新数组中。

  对于在头部插入的情况，往往要将整个切片复制一次以向后挪一下，有一定的性能问题。

- 切片插入元素可以通过切片拼接实现：

  ```go
  s = append(s[:3], append([]int{42}, s[3:]...)...) // 在第 3 号位置插入宇宙的答案
  ```

  问题在于，内层的 `append` 会创建一个新的临时切片，并将原有元素复制到新切片中，这会带来额外的内存开销。

  更加推荐的做法是使用 `copy` 函数：

  ```go
  s = append(s[:3], 42)
  copy(s[4:], s[3:])
  s[3] = 42
  ```

- 当切片的容量不足以容纳新元素时，`append` 会分配一个新的、更大的底层数组，并将原有元素复制到新数组中。所以，通常建议预先分配足够的容量

- 由前文可以看到，切片在赋值、传递时会复制切片头，但底层数组往往不会被复制。这样，多个切片可以共享同一个底层数组。这带来两个问题：

  - 修改一个切片的元素会影响其他共享同一底层数组的切片
  - 如果一个切片截取一部分使用，底层数组的剩余部分并不会被立即释放，这可能导致内存泄漏

## 并发
