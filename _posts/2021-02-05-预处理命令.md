---
layout: post
title:  "【C】预处理命令 <img src='https://img.shields.io/badge/-转载-C9284D?style=flat'>"
date:   2021-02-05 00:00:00 +0800
categories: toturial
tags: C 预处理
comments: 1
mathjax: true
---

本文主要介绍C预处理命令。

<!-- more -->

![](https://img.shields.io/badge/reproduced-CSDN-blue) ![](https://img.shields.io/badge/license-GPL 3.0-orange) ![](https://img.shields.io/badge/article quality-A+-brightgreen)


# 什么是预处理命令？

**以`#`号开头的命令称为预处理命令。**

C语言源文件要经过编译、链接才能生成可执行程序：

- <mark>编译</mark>（Compile）会将<mark>源文件</mark>（`.c`文件）转换为<mark>目标文件</mark>。对于 VC/VS，目标文件后缀为`.obj`；对于GCC，目标文件后缀为`.o`。

> 编译是针对单个源文件的，一次编译操作只能编译一个源文件，如果程序中有多个源文件，就需要多次编译操作。

- <mark>链接</mark>（Link）是针对多个文件的，它会将编译生成的多个目标文件以及系统中的库、组件等合并成一个可执行程序。

在实际开发中，有时候在编译之前还需要对源文件进行简单的处理。例如，我们希望自己的程序在 Windows 和 Linux 下都能够运行，那么就要在 Windows 下使用 VS 编译一遍，然后在 Linux 下使用 GCC 编译一遍。但是现在有个问题，程序中要实现的某个功能在 VS 和 GCC 下使用的函数不同（假设 VS 下使用 `a()`，GCC 下使用 `b()`），VS 下的函数在 GCC 下不能编译通过，GCC 下的函数在 VS 下也不能编译通过，怎么办呢？

这就需要在编译之前先对源文件进行处理：如果检测到是 VS，就保留 `a() `删除 `b()`；如果检测到是 GCC，就保留 `b()` 删除` a()`。这些在编译之前对源文件进行简单加工的过程，就称为<mark>预处理</mark>（即预先处理、提前处理）。

预处理主要是处理以`#`开头的命令，例如`#include <stdio.h>`等。预处理命令要放在所有函数之外，而且**一般都放在源文件的前面**。

预处理是C语言的一个重要功能，由<mark>预处理程序</mark>完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。编译器会将预处理的结果保存到和源文件同名的`.i`文件中，例如 `main.c` 的预处理结果在 `main.i` 中。和`.c`一样，`.i`也是文本文件，可以用编辑器打开直接查看内容。

C语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会**使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计**。

下面我们举个例子来说明预处理命令的实际用途。假如现在要开发一个C语言程序，让它暂停 5 秒以后再输出内容，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？这个程序的难点在于，不同平台下的暂停函数和头文件都不一样：

- Windows 平台下的暂停函数的原型是`void Sleep(DWORD dwMilliseconds)`（注意 S 是大写的），参数的单位是“毫秒”，位于 `<windows.h> `头文件。
- Linux 平台下暂停函数的原型是`unsigned int sleep (unsigned int seconds)`，参数的单位是“秒”，位于` <unistd.h>` 头文件。


不同的平台下必须调用不同的函数，并引入不同的头文件，否则就会导致编译错误，因为 Windows 平台下没有 `sleep()` 函数，也没有 `<unistd.h>` 头文件，反之亦然。这就要求我们在编译之前，也就是预处理阶段来解决这个问题。请看下面的代码：

```cpp
#include <stdio.h>
//不同的平台下引入不同的头文件
#if _WIN32  //识别windows平台
#include <windows.h>
#elif __linux__  //识别linux平台
#include <unistd.h>
#endif
int main() 
{   
    //不同的平台下调用不同的函数 
    #if _WIN32  //识别windows平台  
    Sleep(5000);   
    #elif __linux__  //识别linux平台 
    sleep(5);  
    #endif 
    puts("hi"); 
    return 0;
}
```

`#if`、`#elif`、`#endif `就是预处理命令，它们都是在编译之前由预处理程序来执行的。这里我们不讨论细节，只从整体上来理解。

对于 Windows 平台，预处理以后的代码变成：

```cpp
#include <stdio.h>
#include <windows.h>
int main() 
{   
    Sleep(5000);  
    puts("hi"); 
    return 0;
}
```


对于 Linux 平台，预处理以后的代码变成：

```cpp
#include <stdio.h>
#include <unistd.h>
int main() 
{   
    sleep(5);  
    puts("hi");  
    return 0;
}
```


你看，在不同的平台下，编译之前（预处理之后）的源代码都是不一样的。这就是预处理阶段的工作，它把代码当成普通文本，根据设定的条件进行一些简单的文本替换，将替换以后的结果再交给编译器处理。

# `#include`

`#include`叫做<mark>文件包含命令</mark>，用来引入对应的头文件（`.h`文件）。`#include` 也是C语言预处理命令的一种。`#include` 的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。

`#include` 的用法有两种，如下所示：

```cpp
#include <stdHeader.h>
#include "myHeader.h"
```

使用尖括号`< >`和双引号`" "`的区别在于头文件的搜索路径不同：

- **使用尖括号`< >`，编译器会到系统路径下查找头文件**；
- **使用双引号`" "`，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找**。


也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。

前面我们一直使用尖括号来引入标准头文件，现在我们也可以使用双引号了，如下所示：

```cpp
#include "stdio.h"
#include "stdlib.h"
```

`stdio.h `和 `stdlib.h` 都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。当然，你也可以把当前项目所在的目录添加到系统路径，这样就可以使用尖括号了，但是一般没人这么做，纯粹多此一举，费力不讨好。

> 在以后的编程中，大家既可以使用尖括号来引入标准头文件，也可以使用双引号来引入标准头文件；不过，我个人的习惯是使用尖括号来引入标准头文件，使用双引号来引入自定义头文件（自己编写的头文件），这样一眼就能看出头文件的区别。

关于` #include` 用法的注意事项：

- 一个 `#include` 命令只能包含一个头文件，多个头文件需要多个 `#include` 命令。
- 文件包含允许嵌套，也就是说在一个被包含的文件中又可以包含另一个文件。

我们早就学会使用 `#include` 引入标准头文件了，但是如何使用 `#include` 引入自定义的头文件呢？下面我们就通过一个例子来简单地演示一下。创建三个文件，分别是 `main.c`、`my.c` 和 `my.h`，如下图所示：
![演示#include的用法](http://c.biancheng.net/uploads/allimg/190114/1-1Z114155F6403.gif)

`my.c` 所包含的代码：

```cpp
//计算从m加到n的和
int sum(int m, int n)
{  
    int i, sum = 0; 
    for (i = m; i <= n; i++) 
    {     
        sum += i; 
    }   
    return sum;
}
```


`my.h `所包含的代码：

```cpp
//声明函数
int sum(int m, int n);
```


`main.c `所包含的代码：

```cpp
#include <stdio.h>
#include "my.h"
int main()
{   
    printf("%d\n", sum(1, 100));  
    return 0;
}
```


我们在 `my.c` 中定义了` sum()` 函数，在 `my.h` 中声明了 `sum()` 函数，这可能与很多初学者的认知发生了冲突：函数不是在头文件中定义的吗？为什么头文件中只有声明？

「在头文件中定义定义函数和全局变量」这种认知是原则性的错误！**不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误**。

# `#define`

## 宏定义

`#define` 叫做<mark>宏定义命令</mark>，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，**如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串**。

我们先通过一个例子来看一下 `#define` 的用法：

```cpp
#include <stdio.h>
#define N 100
int main()
{  
    int sum = 20 + N;  
    printf("%d\n", sum);  
    return 0;
}
```

运行结果：

```
120
```

注意第 5 行代码`int sum = 20 + N`，`N`被`100`代替了。

`#define N 100`就是<mark>宏定义</mark>，`N`为<mark>宏名</mark>，`100`是<mark>宏的内容</mark>（宏所表示的字符串）。在预处理阶段，对程序中所有出现的“宏名”，预处理器都会用宏定义中的字符串去代换，这称为<mark>宏替换</mark>或<mark>宏展开</mark>。

**宏定义是由源程序中的宏定义命令`#define`完成的，宏替换是由预处理程序完成的。**

宏定义的一般形式为：

```cpp
#define 宏名 字符串
```

`#`表示这是一条预处理命令，所有的预处理命令都以 `#` 开头。宏名是标识符的一种，**命名规则和变量相同**。`字符串`可以是数字、表达式、`if `语句、函数等。

> 这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号。

程序中反复使用的表达式就可以使用宏定义，例如：

```cpp
#define M (n*n+3*n)
```

它的作用是指定标识符`M`来表示`(y*y+3*y)`这个表达式。在编写代码时，所有出现 `(y*y+3*y)` 的地方都可以用 `M` 来表示，而对源程序编译时，将先由预处理程序进行宏代替，即用 `(y*y+3*y) `去替换所有的宏名 `M`，然后再进行编译。

将上面的例子补充完整：

```cpp
#include <stdio.h>
#define M (n*n+3*n)
int main()
{    
    int sum, n; 
    printf("Input a number: "); 
    scanf("%d", &n);  
    sum = 3*M+4*M+5*M;  
    printf("sum=%d\n", sum);   
    return 0;
}
```

运行结果：

```
Input a number: 10
sum=1560
```

程序的开头首先定义了一个宏 `M`，它表示` (n*n+3*n) `这个表达式。在 9 行代码中使用了宏` M`，预处理程序将它展开为下面的语句：

```cpp
sum=3*(n*n+3*n)+4*(n*n+3*n)+5*(n*n+3*n);
```

需要注意的是，**在宏定义中表达式`(n*n+3*n)`两边的括号不能少**，否则在宏展开以后可能会产生歧义。下面是一个反面的例子：

```cpp
#difine M n*n+3*n
```

在宏展开后将得到下述语句：

```cpp
s=3*n*n+3*n+4*n*n+3*n+5*n*n+3*n;
```

这相当于$3n^2+3n+4n^2+3n+5n^2+3n$，这显然是不正确的。所以进行宏定义时要注意，应该保证在宏替换之后不发生歧义。

## 对宏定义的说明

- 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，**预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现**。

- 宏定义不是说明或语句，在**行末不必加分号**，如加上分号则连分号也一起替换。

- 宏定义必须写在函数之外，**其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用`#undef`命令**。例如：
  ```cpp
  #define PI 3.14159
  int main()
  {  
    // Code  
      return 0;
  }
  #undef
  PIvoid func()
  {   
      // Code
  }
  ```
  表示 `PI` 只在 `main()` 函数中有效，在 `func()` 中无效。
  
- 代码中的**宏名如果被引号包围，那么预处理程序不对其作宏代替**，例如：
  ```cpp
  #include <stdio.h>
  #define OK 100
  int main()
  { 
      printf("OK\n");
      return 0;
  }
  ```
```
  运行结果：
```
  OK
  ```
  该例中定义宏名 `OK `表示 `100`，但在 `printf `语句中 `OK` 被引号括起来，因此不作宏替换，而作为字符串处理。
  
- **宏定义允许嵌套**，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。例如：
  
  ```cpp
  #define PI 3.1415926
  #define S PI*y*y    /* PI是已定义的宏名*/
  ```
  对语句：
  ```cpp
  printf("%f", S);
  ```
  在宏代换后变为：
  ```cpp
  printf("%f", 3.1415926*y*y);
  ```

- 习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。

- 可用宏定义表示数据类型，使书写方便。例如：
  ```
  #define UINT unsigned int
  ```
  在程序中可用 UINT 作变量说明：
  ```
  UINT a, b;
  ```
> 应注意用宏定义表示数据类型和用`typedef`定义数据说明符的区别。**宏定义只是简单的字符串替换，由预处理器来处理；而 `typedef` 是在编译阶段由编译器处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。**请看下面的例子：
>
> ```cpp
> #define PIN1 int *
> typedef int *PIN2;  //也可以写作typedef int (*PIN2);
> ```
> 从形式上看这两者相似， 但在实际使用中却不相同。下面用 `PIN1`，`PIN2` 说明变量时就可以看出它们的区别：
> ```cpp
> PIN1 a, b;
> ```
> 在宏代换后变成：
> ```cpp
> int * a, b;
> ```
> 表示 `a` 是指向整型的指针变量，而 `b` 是整型变量。然而：
> ```cpp
> PIN2 a,b;
> ```
> 表示 `a`、`b` 都是指向整型的指针变量。因为` PIN2 `是一个新的、完整的数据类型。由这个例子可见，宏定义虽然也可表示数据类型， 但毕竟只是简单的字符串替换。在使用时要格外小心，以避出错。

## 带参数宏定义

C语言允许宏带有参数。在宏定义中的参数称为<mark>形式参数</mark>，在宏调用中的参数称为<mark>实际参数</mark>，这点和函数有些类似。对带参数的宏，在展开过程中**不仅要进行字符串替换，还要用实参去替换形参**。

带参宏定义的一般形式为：

```cpp
#define 宏名(形参列表) 字符串
```

在字符串中可以含有各个形参。

带参宏调用的一般形式为：

```cpp
宏名(实参列表);
```

例如：

```cpp
#define M(y) y*y+3*y  //宏定义
// TODO:
k=M(5);  //宏调用
```

在宏展开时，用实参 `5` 去代替形参 `y`，经预处理程序展开后的语句为`k=5*5+3*5`。

再如输出两个数中较大的数：

```cpp
#include <stdio.h>
#define MAX(a,b) (a>b) ? a : b
int main()
{   
    int x , y, max; 
    printf("input two numbers: ");  
    scanf("%d %d", &x, &y);  
    max = MAX(x, y);   
    printf("max=%d\n", max); 
    return 0;
}
```

运行结果：

```
input two numbers: 10 20
max=20
```

程序第 2 行定义了一个带参数的宏，用宏名`MAX`表示条件表达式`(a>b) ? a : b`，形参 `a`、`b` 均出现在条件表达式中。程序第 7 行`max = MAX(x, y)`为宏调用，实参 `x`、`y `将用来代替形参 `a`、`b`。宏展开后该语句为：

```cpp
max=(x>y) ? x : y;
```

## 对带参宏定义的说明

- 带参宏定义中，**形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现**。例如把：
  ```
  #define MAX(a,b) (a>b)?a:b
  ```
  写为：
  ```
  #define MAX  (a,b)  (a>b)?a:b
  ```
  将被认为是<mark>无参宏定义</mark>，宏名 MAX 代表字符串`(a,b) (a>b)?a:b`。宏展开时，宏调用语句：
  ```
  max = MAX(x,y);
  ```
  将变为：
  ```
  max = (a,b)(a>b)?a:b(x,y);
  ```
  这显然是错误的。

- 在带参宏定义中，**不会为形式参数分配内存，因此不必指明数据类型**。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。
  这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。
  
- 在宏定义中，**字符串内的形参通常要用括号括起来以避免出错**。例如上面的宏定义中 `(y)*(y)` 表达式的 `y `都用括号括起来，因此结果是正确的。如果去掉括号，把程序改为以下形式：
  ```cpp
  #include <stdio.h>
  #define SQ(y) y*y
  int main()
  {   
    int a, sq;   
    printf("input a number: "); 
      scanf("%d", &a);  
      sq = SQ(a+1);  
      printf("sq=%d\n", sq); 
    return 0;
  }
  ```
  运行结果为：
```
  input a number: 9
  sq=19
```
同样输入 9，但结果却是不一样的。问题在哪里呢？这是由于宏展开只是简单的符号替换的过程，没有任何其它的处理。宏替换后将得到以下语句：
  ```cpp
  sq=a+1*a+1;
  ```
由于 `a` 为 9，故 `sq` 的值为 19。这显然与题意相违，因此参数两边的括号是不能少的。即使在参数两边加括号还是不够的，请看下面程序：
```cpp
  #include <stdio.h>
  #define SQ(y) (y)*(y)
  int main()
{   
      int a,sq;   
      printf("input a number: ");  
      scanf("%d", &a);   
      sq = 200 / SQ(a+1);   
    printf("sq=%d\n", sq); 
      return 0;
  }
```
  与前面的代码相比，只是把宏调用语句改为：
  ```cpp
  sq = 200/SQ(a+1);
  ```
  运行程序后，如果仍然输入 9，那么我们希望的结果为 2。但实际情况并非如此：
  ```
  input a number: 9
  sq=200
  ```
  为什么会得这样的结果呢？分析宏调用语句，在宏展开之后变为：
  ```cpp
  sq=200/(a+1)*(a+1);
  ```
  `a` 为 9 时，由于`/`和`*`运算符优先级和结合性相同，所以先计算 $200/(9+1)$，结果为 $20$，再计算 $20*(9+1)$，最后得到 $200$。为了得到正确答案，应该在宏定义中的整个字符串外加括号：

  ```cpp
  #include <stdio.h>
  #define SQ(y) ((y)*(y))
  int main()
  {  
      int a,sq;  
      printf("input a number: ");    
      scanf("%d", &a);   
      sq = 200 / SQ(a+1);  
      printf("sq=%d\n", sq);   
      return 0;
  }
  ```
  由此可见，**对于带参宏定义不仅要在参数两侧加括号，还应该在整个字符串外加括号**。

## 预定义宏

为了方便处理一些有用的信息，预处理器定义了一些预处理标识符，也就是<mark>预定义宏</mark>。预定义宏的**名称都是以`__`开头和结尾的，如果宏名是由两个单词组成，那么中间以`_`进行连接**。并且，宏名称一般都由大写字符组成。

在日常项目编程中，预定义宏尤其对多目标平台代码的编写通常具有重大意义。通过预定义宏，程序员使用`#ifdef`与`#endif`等预处理指令，就可使平台相关代码只在适合于当前平台的代码上编译，从而在同一套代码中完成对多平台的支持。从这个意义上讲，平台信息相关的宏越丰富，代码的多平台支持越准确。

标准 C 语言提供的一些标准预定义宏如表所示。

| 宏                         | 描 述                                                        |
| -------------------------- | ------------------------------------------------------------ |
| `__DATE__`                 | 丐前源文件的编泽口期，用 `mm dd yyy`形式的字符串常量表示     |
| `__FILE__`                 | 当前源文件的名称，用字符串常量表示                           |
| `__LINE__`                 | 当前源义件中的行号，用十进制整数常量表示，它可以随`#line`指令改变 |
| `__TIME__`                 | 当前源文件的最新编译吋间，用`hh:mm:ss`形式的宁符串常量表示   |
| `__STDC__`                 | 如果今前编泽器符合ISO标准，那么该宏的值为1，否则未定义       |
| `__STDC_VERSION__`         | 如果当前编译器符合C89，那么它被定义为199409L;如果符合C99，那么它被定义为199901L:在其他情况下，该宏为宋定义 |
| `__STDC_HOSTED__`          | (C99)如果当前是宿主系统，则该宏的值为1;如果当前是独立系统，则该宏的值为0 |
| `__STDC_IEC_559_`          | (C99)如果浮点数的实现符合IEC 60559标准时，则该宏的值为1，否则为未定义 |
| `__STDC_IEC_559_COMPLEX__` | (C99)如果复数运算实现符合IEC60559标准时，则该宏的伉为1,否则为未定义 |
| `__STDC_ISO_10646__`       | (C99 )定义为长整型常量，yyyymmL表示wchai_t值遵循ISO 10646标准及其指定年月的修订补充，否则该宏为未定义 |


除标准 C 语言提供的标准宏之外，各种编译器也都提供了自己的自定义预定义宏。可以通过表 2 所示的指令来查看不同编译器对预定义宏的支持情况。

| 编译器                    | 宏指令（c)                      | 宏指令（C++)                      |
| ------------------------- | ------------------------------- | --------------------------------- |
| Clang/LLVM                | `clang -dM -E -x c /dev/null`   | `clang++ -dM -E -x C++ /dev/null` |
| GNU GCC/G++               | `gcc -dM -E -x c /dev/null`     | `g++ -dM -E -x C++ /dev/null`     |
| Hewlett-Packard C/aC++    | `cc -dM -E -x c /clev/null`     | `aCC -dM -E -x C++ /dev/null`     |
| IBM XL C/C++              | `xlc -qshowmacros -E /dev/null` | `xlc++ -qshowmacros -E /dev/null` |
| Intel ICC7ICPC            | `icc -dM -E -x c /dev/null`     | `icpc -dM -E -x C++ /dev/null`    |
| Oracle Solaris Studio     | `cc -xduinpmacros -E /dev/null` | `CC -xduinpmacros -E /clev/null`  |
| Portland Group PGCC/PGCPP | `pgcc -dM -E`                   |                                   |


图中显示了 GCC 编译器预定义宏的查看结果。虽然各种编译器的预定义宏不尽相同，但是一般都会支持`__DATE__`、`__FILE__`、`__LINE__`与`__TIME__`这 4 种预定义宏。

![img](http://c.biancheng.net/uploads/allimg/180906/2-1PZ614221J12.jpg)

对于这些预定义宏的应用，基本上随处可见，下面举例介绍。

利用`__DATE__`和`__TIME__`宏可以用来确定程序编译的时间。如下面的示例代码所示：

```cpp
int main ()
{   
    printf("Copyright (c) Powered by baidu\n");  
    printf("Compiled on %s at %s\n", __DATE__,__TIME__);  
    return 0;
}
```

利用`__STDC__`与`__STDC_VERSION__`宏可以编写那些需要兼容标准 C 和非标准 C 编译器的程序，如下面的示例代码所示：

```cpp
#ifdef __STDC__
/* Some version of standard C */
#if defined(__STDC__VERSION__)&&__STDC_VERSION__>=199901L
/* C99 */
#elif defined(__STDC_VERSION__)&&__STDC_VERSION__>=199409L
/* C89 and amendment 1 */
#else
/* C89 but not amendment 1*/
#endif
#else 
/* __STDC__not defined *//*Not Standard C*/
#endif
```

利用`__FILE__`、`__LINE__`与`__FUNCTION__`（或者`__func__`）预定义宏的组合，在调试程序的时候可以很简单地在程序运行期进行异常跟踪。如下面的示例代码所示：

```cpp
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#define MESSAGE(message,assertion) \   
        do{\ 
            if(!(assertion)){\    
                printf("line %d in %s(%s)", __LINE__, __FILE__,__FUNCTION__);\    
                if(message)
                {\        
                    printf(":%s",message);\
                }\              
                printf("\n");\      
                abort();\  
            }\          
        }while(0)
int OpenFile(const char *filename)
{  
    int fd; 
    MESSAGE("文件名称不能够为空",filename); 
    MESSAGE("文件不存在",0==access(filename,F_OK));  
    fd = open(filename,O_RDONLY); 
    close(fd);   
    return 0;
}
int main(int argc,char **argv)
{   
    MESSAGE("命令参数不能够为空",argc==2);   
    OpenFile(argv[1]);  
    return 0;
}
```

其中，`__FILE__`、`__LINE__`与`__FUNCTION__`（或者`__func__`）预定义宏分别表示文件名、行数与函数名，这样就可以帮助我们精确地定位出现异常的文件、行数与函数名。运行结果如图所示。

![img](http://c.biancheng.net/uploads/allimg/180906/2-1PZ6142313545.jpg)

最后还需要注意的是，如果用户重定义`#define`或取消了`#undef`预定义宏，那么其结果是<mark>未定义</mark>的。因此，在代码编写中，应该尽量避免自定义宏与预定义宏名称相同的情况发生。

# `#line`

编译器会在警告消息、错误消息与调试信息中包含代码所在的行号与所在的源文件名，并提供给调试工具。你可以在源代码中利用` #line` 命令改变编译器默认指定的文件名与行号信息。`#line` 命令的语法如下：

```cpp
#line line_number ["filename"]
```

`#line `命令的下一行行号会指定为 `line_number`。如果该命令也包含可选字符串字面量`filename`，那么该编译器会把该字符串名称作为当前源文件名。`line_number `必须是大于 0 的十进制常量。如下例所示：

```cpp
#line 1200 "primary.c"
```


包含 `#line` 命令的那一行代码，也可以包含其他宏。如果包含其他宏，预处理器会先展开所有宏，然后再执行 `#line` 命令。但要确保在宏展开后，`#line` 命令是正确的。程序可以利用标准预定义宏`__LINE__` 和` __FILE__` 来访问当前的行号和文件名设置：

```cpp
printf( "This message was printed by line %d in the file %s.\n",
       __LINE__, 
       __FILE__ );
```


`#line `命令通常用在将 C 源代码作为输出的程序上。通过将对应的输入文件行号放置在` #line `命令内，程序可以让 C 编译器的错误消息指向源文件中相应的行。

# `#error`

无论是否有实际错误，`#error` 命令都会让预处理器发出错误消息。它的语法如下：

```cpp
#error [text]
```


如果上述命令存在可选项 `text`，则` text` 就会被包含在预处理器的错误消息中。然后，编译器会终止处理源代码，并结束执行，仿佛遇到了严重错误。`text`可以是任意预处理器记号序列。**如果 `text` 中有其他宏，它们都不会被展开**。最好在这里使用**字符串字面量**，以避免标点符号字符（如单引号）的影响。

下面的例子测试标准宏 `__STDC__ `是否已经被定义。如果没有，则生成一个错误消息：

```cpp
#ifndef __STDC__  
#error "This compiler does not conform to the ANSI C standard."
#endif
```

# `#pragma`

`#pragma `命令是向编译器提供额外信息的标准方法，其格式如下：

```cpp
#pragma [tokens]
```


如果 `#pragma` 之后的第一个`token`是` STDC`，那么该命令就是一个<mark>标准 pragma</mark>。否则，该 `#pragma` 命令的作用取决于实现版本。为了保障代码的可移植性，应该尽量少使用 `#pragma` 命令。

如果预处理器支持所指定的标记，就会执行这些标记所代表的动作，或者把该信息传递给编译器。如果预处理器不支持所指定的标记，就忽略该` #pragma `命令。例如，最新版本的 GNU C 编译器和微软 Visual C 编译器都支持 `#pragma pack（n）`，它使得编译器让结构成员对齐到特定的字节边界。下面的例子使用 `pack（1）`指示每个结构成员必须对齐到字节边界：

```cpp
#if defined( __GNUC__ ) || defined( _MSC_VER ) 
#pragma pack(1)                             // 对齐字节，没有填充
#endif
```


单字节对齐方式可以确保结构成员之间不会有间隙。`pack` 的参数` n `通常是 2 的幂（但幂值较小）。例如，`pack（2）`把结构成员对齐到偶数地址，而 `pack（4）`把结构成员对齐到 4 为倍数的地址。`pack（）`没有参数，它指示对齐方式设置为实现版本的默认值。

C99 新增下面三个标准的 `pragma`：

```cpp
#pragma STDC FP_CONTRACT on_off_switch
#pragma STDC FENV_ACCESS on_off_switch
#pragma STDC CX_LIMITED_RANGE on_off_switch
//on_off_switch 的值必须是 ON、OFF 或 DEFAULT。
```

## `_Pragma`

无法通过宏展开创建一个 `#pragma` 命令（或任何其他命令）。当碰到需要这么做的情况时，C99 新增了一个预处理运算符 `_Pragma`，它可以与宏配合使用。它的语法如下：

```cpp
_Pragma (string_literal )
```


`_Pragma` 运算符的工作方式是这样的。首先，该 `string_literal` 操作数会被<mark>解字符串化</mark>（destringized），或被转换为预处理器记号序列，该过程如下：删除字符串前后的双引号；使用`"`替代 `"`；使用 `\ `替代` \\`。然后，预处理器会翻译前述结果序列的记号，类似于 `#pragma` 命令。

下面这一行代码定义了一个名为 `STR` 的宏，借此可以使用 `_Pragma` 运算符重写 `#pragma` 命令：

```cpp
#define STR(s)   
#s             // 这个#是“字符串化”运算符
```


有了上述定义，下面两行代码是等同的：

```cpp
#pragma tokens
_Pragma ( STR(tokens) )
```


下面的例子是在宏中使用 `_Pragma` 运算符：

```cpp
#define ALIGNMENT(n) 
_Pragma( STR(pack(n)) )
    ALIGNMENT(2)
```


宏替换会把调用宏 `ALIGNMENT（2）`的过程重写为如下形式：

```cpp
_Pragma( "pack(2)" )
```


预处理器接着处理这行代码，实现方式与使用下面的命令一样：

```cpp
#pragma pack(2)
```

# 条件编译

假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？这个程序的难点在于，不同平台下控制文字颜色的代码不一样，我们必须要能够识别出不同的平台Windows 有专有的宏`_WIN32`，Linux 有专有的宏`__linux__`，以现有的知识，我们很容易就想到了`if else`，请看下面的代码：

```cpp
#include <stdio.h>
int main()
{  
    if(_WIN32)
    {      
        system("color 0c");   
        printf("hi\n");  
    }
    else if(__linux__)
    { 
        printf("\033[22;31mhi\n\033[22;30m"); 
    }
    else
    {   
        printf("hi\n");   
    }   
    return 0;
}
```

但这段代码是错误的，在 Windows 下提示 `__linux__` 是未定义的标识符，在 Linux 下提示 `_Win32` 是未定义的标识符。对上面的代码进行改进：

```cpp
#include <stdio.h>
int main()
{ 
    #if _WIN32   
    	system("color 0c"); 
    	printf("hi\n");  
    #elif __linux__       
    	printf("\033[22;31mhi\n\033[22;30m");  
    #else     
    	printf("hi\n");   
    #endif 
    return 0;
}
```

`#if`、`#elif`、`#else` 和 `#endif` 都是预处理命令，整段代码的意思是：如果宏` _WIN32 `的值为真，就保留第 4、5 行代码，删除第 7、9 行代码；如果宏 `__linux__ `的值为真，就保留第 7 行代码；如果所有的宏都为假，就保留第 9 行代码。

这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为<mark>条件编译</mark>。条件编译是预处理程序的功能，不是编译器的功能。条件编译需要多个预处理命令的支持，下面一一讲解。

## `#if `

`#if` 用法的一般格式为：

```cpp
#if 整型常量表达式1
  程序段1
#elif 整型常量表达式2
  程序段2
#elif 整型常量表达式3
  程序段3
#else
  程序段4
#endif
```

它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 `#else`。这一点和 `if else `非常类似。

需要注意的是，**`#if `命令要求判断条件为<mark>整型常量表达式</mark>，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行**。这是 `#if `和` if `的一个重要区别。

`#elif` 和` #else `也可以省略，如下所示：

```cpp
#include <stdio.h>
int main()
{   
    #if _WIN32  
    	printf("This is Windows!\n");  
    #else    
    	printf("Unknown platform!\n"); 
    #endif     
    #if __linux__      
    	printf("This is Linux!\n"); 
    #endif  
    return 0;
}
```

## `#ifdef`

\#ifdef 用法的一般格式为：

```cpp
#ifdef  宏名
  程序段1
#else
  程序段2
#endif
```

它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。

也可以省略 `#else`：

```cpp
#ifdef  宏名
  程序段
#endif
```

VS/VC 有两种编译模式，Debug 和 Release。在学习过程中，我们通常使用 Debug 模式，这样便于程序的调试；而最终发布的程序，要使用 Release 模式，这样编译器会进行很多优化，提高程序运行效率，删除冗余信息。为了能够清楚地看到当前程序的编译模式，我们不妨在程序中增加提示，请看下面的代码：

```cpp
#include <stdio.h>
#include <stdlib.h>
int main()
{ 
    #ifdef _DEBUG      
    	printf("正在使用 Debug 模式编译程序...\n");   
    #else   
    	printf("正在使用 Release 模式编译程序...\n"); 
    #endif  
    system("pause"); 
    return 0;
}
```

当以 Debug 模式编译程序时，宏` _DEBUG` 会被定义，预处器会保留第 5 行代码，删除第 7 行代码。反之会删除第 5 行，保留第 7 行。

## `#ifndef`

`#ifndef `用法的一般格式为：

```cpp
#ifndef 宏名
  程序段1 
#else 
  程序段2 
#endif
```

与 `#ifdef `相比，仅仅是将 `#ifdef `改为了 `#ifndef`。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。

