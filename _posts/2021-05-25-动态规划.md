---
layout: post
title:  "【算法】动态规划 <img src='https://img.shields.io/badge/-原创-019733?style=flat'> <img src='https://img.shields.io/badge/-未完待续-blue?style=flat'>"
date:   2021-05-25 00:00:00 +0800
categories: A&DS
tags: 算法 DP
comments: 1
mathjax: true
---

本文介绍DP（动态规划）。

# 背包 DP

> 对于给定的背包，求物品最大总价值。

## 0-1 背包

> 背包容量 $W$，第 $i$ 个物品重量为 $w_i$，价值为 $v_i$。

`f[i][j]` 为只能放前 $i$ 个物品，容量为 $j$ 的背包能大道的最大价值。

转移方程为 `f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i])`。

采用滚动数组 `f[j]=max(f[j],f[j-w[i]]+v[i])`。

```cpp
for (int i = 1; i <= n; i++)
    for (int j = W; j >= w[i]; j--)
        f[j] = max(f[j], f[j - w[i]] + v[i]);
```

## 完全背包

> 背包容量 $W$，第 $i$ 种物品重量为 $w_i$，价值为 $v_i$。

转移方程为 `f[i][j]=max(f[i-1][j],f[i][j-w[i]]+v[i])`

采用滚动数组 `f[j]=max(f[j],f[j-w[i]]+v[i])`。

```cpp
for (int i = 1; i <= n; i++)
    for (int j = W; j >= w[i]; j--)
        f[j] = max(f[j], f[j - w[i]] + v[i]);
```

## 多重背包

> 背包容量 $W$，第 $i$ 种物品有 $k_i$ 个，重量为 $w_i$，价值为 $v_i$。

转移方程为 `f[i][j]=max(f[i-1][j-k*w[i]]+k*v[i])` $(0\leq k\leq k_i)$。

二进制分组优化：令 `A[i][j]` 为 $2^j$ 个第 $i$ 个物品捆绑成的大物品。若 $k_i+1$ 不是 $2$ 的整数次幂，则最后再添加一个 $k_i-2^{\lfloor\log_{2}{k_i+1}\rfloor-1}$ 的捆绑物品。然后同 0-1 背包。

## 二维费用背包

> 背包容量 $W$，打包时间为 $T$，第 $i$ 种物品重量为 $w_i$，打包时间为 $t_i$，价值为 $v_i$。

转移方程 `f[i][j]=max(f[i][j],f[i-m[i]][j-t[i]]+1)`。

## 分组背包

> 背包容量 $W$，共 $t$ 组，第 $k$ 组有 $n_k$ 个物品，第 $i$ 个物品重量为 $w_{k,i}$，价值为 $v_{k,i}$。每组最多取一个物品。

```cpp
for (int k = 1; k <= t; k++)
    for (int j = W; j >= 0; j--)
        for (int i = 1; i <= n[k]; i++)
            if (j >= w[k][i])
                f[j] = max(f[j], f[j - w[k][i]] + v[k][i]);
```



# 区间 DP

> 在一个环上有 $n$ 个数 $a_1,\cdots,a_n$，进行 $n-1$ 次合并操作，每次操作将相邻的两个数相加合并成一个，得分为新的数。求最大得分。

若 $n$ 个数在一条链上，`f[i][j]` 为将区间 $[i,j]$ 上所有的数合并后的最大得分，`sum[i]` 为 $a_i$ 的前缀和。

状态转移方程 `f[i][j]=max(f[i][k]+f[k+1][j]+sum[j]-sum[i-1])`$(i<k<j)$。

对于环，将链延长两倍，取 `f[1][n]`$\cdots$`f[i][n+i-1]` 中的最优值。

```cpp
for (len = 1; len <= n; len++)
    for (i = 1; i <= 2 * n - 1; i++) {
        int j = len + i - 1;
        for (k = i; k < j && k <= 2 * n - 1; k++)
            f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1]);
    }
```



# 状压 DP

> 