---
layout: post
title:  "【数据结构】Priority Heap <img src='https://img.shields.io/badge/-原创-019733?style=flat'>"
date:   2020-06-15 00:00:00 +0800
categories: A&DS
tags: 数据结构 算法 堆
comments: 1
mathjax: true
---

本文为数据结构系列第六篇，主要介绍<mark>Priority Heap</mark>。

# 大根堆和小根堆

​           从二叉堆的结构说起，它是一棵二叉树，并且是完全二叉树，每个结点中存有一个元素（或者说，有个权值）。堆性质：**大根堆父亲的权值不小于儿子的权值**。同样的，我们可以定义小根堆。本文以大根堆为例。由堆性质，树根存的是最大值。如下图即为一个最大堆。

![在这里插入图片描述](https://raw.githubusercontent.com/WCY-dt/PictureBed/master/2020/12/1b3f86357be5135a4b744ce490b502d0-d435cd.png)

# 插入

​           插入操作是指向二叉堆中插入一个元素，要保证插入后也是一棵完全二叉树。最简单的方法就是，最下一层最右边的叶子之后插入。如果最下一层已满，就新增一层。插入之后可能会不满足，因此采用**向上调整** ：**如果这个结点的权值大于它父亲的权值，就交换，重复此过程直到不满足或者到根。**可以证明，插入之后向上调整后，没有其他结点会不满足堆性质。向上调整的时间复杂度是$O(\log{n})$的。

# 删除

​           删除操作指删除堆中最大的元素，即删除根结点。但是如果直接删除，则变成了两个堆，难以处理。所以不妨考虑插入操作的逆过程，设法将根结点移到最后一个结点，然后直接删掉。然而实际上不好做，我们通常采用的方法是，把根结点和最后一个结点直接交换。于是直接删掉（在最后一个结点处的）根结点，但是新的根结点可能不满足堆性质，因此采用**向下调整** ：**在该结点的儿子中，找一个最大的，与该结点交换，重复此过程直到底层。**可以证明，删除并向下调整后，没有其他结点不满足堆性质。时间复杂度为$O(\log{n})$。

# 调整

​           我们发现，上面介绍的几种操作主要依赖于两个核心：向上调整和向下调整。考虑使用一个序列$h$来表示堆。$h_i$的两个儿子分别是$h_{2i}$和$h_{2i+1}$，$1$是根结点：

![h 的堆结构](https://raw.githubusercontent.com/WCY-dt/PictureBed/master/2020/12/3b4b8e98f4183d86620694744e8837a1-20803d.png)

参考代码：

```cpp
void up(int x)
{
  while (x>1 && h[x]>h[x/2]) 
  {
    swap(h[x],h[x/2]);
    x/=2;
  }
}
void down(int x)
{
  while (x*2<=n)
  {
    t=x*2;
    if (t+1<=n && h[t+1]>h[t]) t++;
    if (h[t]<=h[x]) break;
    swap(h[x],h[t]);
    x=t;
  }
}
```

# 建堆

​           考虑这么一个问题，从一个空的堆开始，插入 个元素，不在乎顺序。直接一个一个插入需要 的时间，有没有更好的方法？

- 向上调整

​           从根开始，按 BFS 序进行。

```cpp
void build_heap_1() 
{
  for (i=1;i<=n;i++) up(i);
}
```

- 向下调整

​           这时换一种思路，从叶子开始，逐个向下调整

```cpp
void build_heap_2()
{
  for (i=n;i>=1;i--) down(i);
}
```

​           换一种理解方法，每次*合并*两个已经调整好的堆，这说明了正确性。总复杂度$O(n)$，堆性质很弱，二叉堆并不是唯一的。

# 完整程序

```cpp
#include<bits/stdc++.h>
using namespace std;
const int n=15;
int h[16];

void up(int temp)
{
	int x=temp;
	while (x>1 && h[x]>h[x/2]) 
	{
		swap(h[x],h[x/2]);
		x/=2;
	}
}

void init()
{
	srand(time(0));
	for (int i=1;i<=n;i++)
	{
		h[i]=rand();
		printf("%d ",h[i]);
		up(i);
	}
	printf("\n");
}

void print(int x)
{
	printf("%d ",h[x]);
	if (x*2<=n) print(x*2);
	if (x*2+1<=n) print(x*2+1);
}

int main()
{
	init();
	print(1);
}
```

**样例**

- 1.out

  ```
  22586 8178 7631 11613 2745 6208 25031 17933 20761 22800 5065 16879 23035 12814 29218
  29218 22800 17933 8178 11613 20761 2745 5065 25031 22586 6208 16879 23035 7631 12814
  ```

